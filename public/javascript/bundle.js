(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var self = self || {};// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '73' };

//

if ( typeof define === 'function' && define.amd ) {

		define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

		module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

	// Missing in Android stock browser.

	( function () {

		var lastTime = 0;
		var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

		for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

			self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
			self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

		}

		if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

			self.requestAnimationFrame = function ( callback ) {

				var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
				var id = self.setTimeout( function () {

					callback( currTime + timeToCall );

				}, timeToCall );
				lastTime = currTime + timeToCall;
				return id;

			};

		}

		if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

			self.cancelAnimationFrame = function ( id ) {

				self.clearTimeout( id );

			};

		}

	} )();

}

//

if ( self.performance === undefined ) {

	self.performance = {};

}

if ( self.performance.now === undefined ) {

	( function () {

		var start = Date.now();

		self.performance.now = function () {

			return Date.now() - start;

		}

	} )();

}

//

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, -52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

		}

	} );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// Loop styles for AnimationAction

THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;

// DEPRECATED

THREE.Projector = function () {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

};

THREE.CanvasRenderer = function () {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElement( 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.fromArray( arguments );

	}

	return this.set( color );

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = THREE.Math.euclideanModulo( h, 1 );
			s = THREE.Math.clamp( s, 0, 1 );
			l = THREE.Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = THREE.ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	get width() { return this.x },
	set width( value ) { this.x = value },

	get height() { return this.y },
	set height( value ) { this.y = value },

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
			this.z = 0;
		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function projectOnVector( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );

	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];

		return this;

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];
		this.w = attribute.array[ index + 3 ];

		return this;

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order);

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function ( q, order, update ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();
			matrix.makeRotationFromQuaternion( q );
			this.setFromRotationMatrix( matrix, order, update );

			return this;

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new THREE.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix3( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix3( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		var te = this.elements;

		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function ( m ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function ( eye, target, up ) {

			if ( x === undefined ) x = new THREE.Vector3();
			if ( y === undefined ) y = new THREE.Vector3();
			if ( z === undefined ) z = new THREE.Vector3();

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix4( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix4( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1;

		return function () {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function ( position, quaternion, scale ) {

			if ( vector === undefined ) vector = new THREE.Vector3();
			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new THREE.Vector3();
		var segDir = new THREE.Vector3();
		var diff = new THREE.Vector3();

		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),


	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box, optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint !== oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

// File:src/core/Channels.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Channels = function () {

	this.mask = 1;

};

THREE.Channels.prototype = {

	constructor: THREE.Channels,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance.now();

		this.oldTime = this.startTime;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
				}
			}
		} );

	};

	function descSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera instanceof THREE.PerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( camera instanceof THREE.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.channels = new THREE.Channels();
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new THREE.Matrix4()
		},
		normalMatrix: {
			value: new THREE.Matrix3()
		}
	} );

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set renderDepth ( value ) {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},

	//

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache ( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.rotationAutoUpdate = source.rotationAutoUpdate;

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.array.length / this.itemSize;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new THREE.Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new THREE.Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new THREE.Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new THREE.Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

	THREE.BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

	THREE.BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.stride = stride;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

	constructor: THREE.InterleavedBuffer,

	get length () {

		return this.array.length;

	},

	get count () {

		return this.array.length / this.stride;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.stride = source.stride;
		this.dynamic = source.dynamic;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

	THREE.InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	THREE.InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

	this.uuid = THREE.Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

	constructor: THREE.InterleavedBufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.data.array.length / this.data.stride;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		};

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new THREE.Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( mesh instanceof THREE.Mesh === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		var vertices = source.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		var faces = source.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'DirectGeometry';

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

	constructor: THREE.DirectGeometry,

	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

	computeFaceNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

	},

	computeVertexNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

	},

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		if ( morphTargetsLength > 0 ) {

			var morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		if ( morphNormalsLength > 0 ) {

			var morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		this.index = index;

	},

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

	},

	get drawcalls() {

		console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
		return this.groups;

	},

	get offsets() {

		console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
		return this.groups;

	},

	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},

	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

			var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
			var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object instanceof THREE.Mesh ) {

			if ( geometry instanceof THREE.Geometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object instanceof THREE.Mesh ) {

			var direct = geometry.__directGeometry;

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		if ( geometry.verticesNeedUpdate === true ) {

			var attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			var attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			var attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

				var attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			var attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		};

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},

	computeOffsets: function ( size ) {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

	},

	merge: function ( geometry, offset ) {

		if ( geometry instanceof THREE.BufferGeometry === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count );

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

	THREE.BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

	this.groups.push( {

		start: start,
		count: count,
		instances: instances

	} );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.instances );

	}

	return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/animation/AnimationAction.js

/**
 *
 * A clip that has been explicitly scheduled.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {

	if ( clip === undefined ) throw new Error( 'clip is null' );
	this.clip = clip;
	this.localRoot = null;
	this.startTime = startTime || 0;
	this.timeScale = timeScale || 1;
	this.weight = weight || 1;
	this.loop = loop || THREE.LoopRepeat;
	this.loopCount = 0;
	this.enabled = true;	// allow for easy disabling of the action.

	this.actionTime = - this.startTime;
	this.clipTime = 0;

	this.propertyBindings = [];
};

/*
THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPing = 2202;
*/

THREE.AnimationAction.prototype = {

	constructor: THREE.AnimationAction,

	setLocalRoot: function( localRoot ) {

		this.localRoot = localRoot;

		return this;

	},

	updateTime: function( clipDeltaTime ) {

		var previousClipTime = this.clipTime;
   		var previousLoopCount = this.loopCount;
   		var previousActionTime = this.actionTime;

		var duration = this.clip.duration;

		this.actionTime = this.actionTime + clipDeltaTime;

		if ( this.loop === THREE.LoopOnce ) {

			this.loopCount = 0;
			this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );

			// if time is changed since last time, see if we have hit a start/end limit
			if ( this.clipTime !== previousClipTime ) {

				if ( this.clipTime === duration ) {

					this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );

				} else if ( this.clipTime === 0 ) {

					this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );

				}

			}


			return this.clipTime;

		}

		this.loopCount = Math.floor( this.actionTime / duration );

		var newClipTime = this.actionTime - this.loopCount * duration;
		newClipTime = newClipTime % duration;

		// if we are ping pong looping, ensure that we go backwards when appropriate
		if ( this.loop == THREE.LoopPingPong ) {

			if ( Math.abs( this.loopCount % 2 ) === 1 ) {

				newClipTime = duration - newClipTime;

			}

		}

		this.clipTime = newClipTime;

		if ( this.loopCount !== previousLoopCount ) {

   			this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );

   		}

	   	return this.clipTime;

	},

	syncWith: function( action ) {

		this.actionTime = action.actionTime;
		this.timeScale = action.timeScale;

		return this;
	},

	warpToDuration: function( duration ) {

		this.timeScale = this.clip.duration / duration;

		return this;
	},

	init: function( time ) {

		this.clipTime = time - this.startTime;

		return this;

	},

	update: function( clipDeltaTime ) {

		this.updateTime( clipDeltaTime );

		var clipResults = this.clip.getAt( this.clipTime );

		return clipResults;

	},

	getTimeScaleAt: function( time ) {

		if ( this.timeScale.getAt ) {
			// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
			return this.timeScale.getAt( time );

		}

		return this.timeScale;

	},

	getWeightAt: function( time ) {

		if ( this.weight.getAt ) {
			// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
			return this.weight.getAt( time );

		}

		return this.weight;

	}

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {
		for ( var i = 0; i < this.tracks.length; i ++ ) {
			var track = this.tracks[i];
			this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
		}
	}

	// maybe only do these on demand, as doing them here could potentially slow down loading
	// but leaving these here during development as this ensures a lot of testing of these functions
	this.trim();
	this.optimize();

	this.results = [];

};

THREE.AnimationClip.prototype = {

	constructor: THREE.AnimationClip,

	getAt: function( clipTime ) {

		clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			var track = this.tracks[ i ];

			this.results[ i ] = track.getAt( clipTime );

		}

		return this.results;
	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};


THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {


	var numMorphTargets = morphTargetSequence.length;
	var tracks = [];

	for ( var i = 0; i < numMorphTargets; i ++ ) {

		var keys = [];

		keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
		keys.push( { time: i, value: 1 } );
		keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );

		keys.sort( THREE.KeyframeTrack.keyComparer );

		// if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
		if ( keys[0].time === 0 ) {
			keys.push( {
				time: numMorphTargets,
				value: keys[0].value
			});
		}

		tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
	}

	return new THREE.AnimationClip( name, -1, tracks );

};

THREE.AnimationClip.findByName = function( clipArray, name ) {

	for ( var i = 0; i < clipArray.length; i ++ ) {

		if ( clipArray[i].name === name ) {

			return clipArray[i];

		}
	}

	return null;

};

THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {

	var animationToMorphTargets = {};

	// tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
	var pattern = /^([\w-]*?)([\d]+)$/;

	// sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
	for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

		var morphTarget = morphTargets[ i ];
		var parts = morphTarget.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var name = parts[ 1 ];

			var animationMorphTargets = animationToMorphTargets[ name ];
			if ( ! animationMorphTargets ) {
				animationToMorphTargets[ name ] = animationMorphTargets = [];
			}

			animationMorphTargets.push( morphTarget );

		}

	}

	var clips = [];

	for ( var name in animationToMorphTargets ) {

		clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
	}

	return clips;

};

// parse the standard JSON format for clips
THREE.AnimationClip.parse = function( json ) {

	var tracks = [];

	for ( var i = 0; i < json.tracks.length; i ++ ) {

		tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );

	}

	return new THREE.AnimationClip( json.name, json.duration, tracks );

};


// parse the animation.hierarchy format
THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {

	if ( ! animation ) {
		console.error( "  no animation in JSONLoader data" );
		return null;
	}

	var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {

		var keys = [];

		for ( var k = 0; k < animationKeys.length; k ++ ) {

			var animationKey = animationKeys[k];

			if ( animationKey[propertyName] !== undefined ) {

				keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
			}

		}

		// only return track if there are actually keys.
		if ( keys.length > 0 ) {

			return new trackType( trackName, keys );

		}

		return null;

	};

	var tracks = [];

	var clipName = animation.name || 'default';
	var duration = animation.length || -1; // automatic length determination in AnimationClip.
	var fps = animation.fps || 30;

	var hierarchyTracks = animation.hierarchy || [];

	for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

		var animationKeys = hierarchyTracks[ h ].keys;

		// skip empty tracks
		if ( ! animationKeys || animationKeys.length == 0 ) {
			continue;
		}

		// process morph targets in a way exactly compatible with AnimationHandler.init( animation )
		if ( animationKeys[0].morphTargets ) {

			// figure out all morph targets used in this track
			var morphTargetNames = {};
			for ( var k = 0; k < animationKeys.length; k ++ ) {

				if ( animationKeys[k].morphTargets ) {
					for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

						morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
					}
				}

			}

			// create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
			for ( var morphTargetName in morphTargetNames ) {

				var keys = [];

				for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

					var animationKey = animationKeys[k];

					keys.push( {
							time: animationKey.time,
							value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
						});

				}

				tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );

			}

			duration = morphTargetNames.length * ( fps || 1.0 );

		} else {

			var boneName = nodeName + '.bones[' + bones[ h ].name + ']';

			// track contains positions...
			var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
					return new THREE.Vector3().fromArray( animationKey.pos )
				} );

			if ( positionTrack ) tracks.push( positionTrack );

			// track contains quaternions...
			var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
					if ( animationKey.rot.slerp ) {
						return animationKey.rot.clone();
					} else {
						return new THREE.Quaternion().fromArray( animationKey.rot );
					}
				} );

			if ( quaternionTrack ) tracks.push( quaternionTrack );

			// track contains quaternions...
			var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
					return new THREE.Vector3().fromArray( animationKey.scl )
				} );

			if ( scaleTrack ) tracks.push( scaleTrack );

		}
	}

	if ( tracks.length === 0 ) {

		return null;

	}

	var clip = new THREE.AnimationClip( clipName, duration, tracks );

	return clip;

};

// File:src/animation/AnimationMixer.js

/**
 *
 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationMixer = function( root ) {

	this.root = root;
	this.time = 0;
	this.timeScale = 1.0;
	this.actions = [];
	this.propertyBindingMap = {};

};

THREE.AnimationMixer.prototype = {

	constructor: THREE.AnimationMixer,

	addAction: function( action ) {

		// TODO: check for duplicate action names?  Or provide each action with a UUID?

		this.actions.push( action );
		action.init( this.time );
		action.mixer = this;

		var tracks = action.clip.tracks;

		var root = action.localRoot || this.root;

		for ( var i = 0; i < tracks.length; i ++ ) {

			var track = tracks[ i ];

			var propertyBindingKey = root.uuid + '-' + track.name;
			var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

			if ( propertyBinding === undefined ) {

				propertyBinding = new THREE.PropertyBinding( root, track.name );
				this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;

			}

			// push in the same order as the tracks.
			action.propertyBindings.push( propertyBinding );

			// track usages of shared property bindings, because if we leave too many around, the mixer can get slow
			propertyBinding.referenceCount += 1;

		}

	},

	removeAllActions: function() {

		for ( var i = 0; i < this.actions.length; i ++ ) {

			this.actions[i].mixer = null;

		}

		// unbind all property bindings
		for ( var properyBindingKey in this.propertyBindingMap ) {

			this.propertyBindingMap[ properyBindingKey ].unbind();

		}

		this.actions = [];
		this.propertyBindingMap = {};

		return this;

	},

	removeAction: function( action ) {

		var index = this.actions.indexOf( action );

		if ( index !== - 1 ) {

			this.actions.splice( index, 1 );
			action.mixer = null;

		}


		// remove unused property bindings because if we leave them around the mixer can get slow
		var root = action.localRoot || this.root;
		var tracks = action.clip.tracks;

		for ( var i = 0; i < tracks.length; i ++ ) {

			var track = tracks[ i ];

			var propertyBindingKey = root.uuid + '-' + track.name;
			var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

			propertyBinding.referenceCount -= 1;

			if ( propertyBinding.referenceCount <= 0 ) {

				propertyBinding.unbind();

				delete this.propertyBindingMap[ propertyBindingKey ];

			}
		}

		return this;

	},

	// can be optimized if needed
	findActionByName: function( name ) {

		for ( var i = 0; i < this.actions.length; i ++ ) {

			if ( this.actions[i].name === name ) return this.actions[i];

		}

		return null;

	},

	play: function( action, optionalFadeInDuration ) {

		action.startTime = this.time;
		this.addAction( action );

		return this;

	},

	fadeOut: function( action, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: 1 } );
		keys.push( { time: this.time + duration, value: 0 } );

		action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

		return this;

	},

	fadeIn: function( action, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: 0 } );
		keys.push( { time: this.time + duration, value: 1 } );

		action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

		return this;

	},

	warp: function( action, startTimeScale, endTimeScale, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: startTimeScale } );
		keys.push( { time: this.time + duration, value: endTimeScale } );

		action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );

		return this;

	},

	crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {

		this.fadeOut( fadeOutAction, duration );
		this.fadeIn( fadeInAction, duration );

		if ( warp ) {

			var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
			var endStartRatio = 1.0 / startEndRatio;

			this.warp( fadeOutAction, 1.0, startEndRatio, duration );
			this.warp( fadeInAction, endStartRatio, 1.0, duration );

		}

		return this;

	},

	update: function( deltaTime ) {

		var mixerDeltaTime = deltaTime * this.timeScale;
		this.time += mixerDeltaTime;

		for ( var i = 0; i < this.actions.length; i ++ ) {

			var action = this.actions[i];

			var weight = action.getWeightAt( this.time );

			var actionTimeScale = action.getTimeScaleAt( this.time );
			var actionDeltaTime = mixerDeltaTime * actionTimeScale;

			var actionResults = action.update( actionDeltaTime );

			if ( action.weight <= 0 || ! action.enabled ) continue;

			for ( var j = 0; j < actionResults.length; j ++ ) {

				var name = action.clip.tracks[j].name;

				action.propertyBindings[ j ].accumulate( actionResults[j], weight );

			}

		}

		// apply to nodes
		for ( var propertyBindingKey in this.propertyBindingMap ) {

			this.propertyBindingMap[ propertyBindingKey ].apply();

		}

		return this;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

// File:src/animation/AnimationUtils.js

/**
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

	getEqualsFunc: function( exemplarValue ) {

		if ( exemplarValue.equals ) {
			return function equals_object( a, b ) {
				return a.equals( b );
			}
		}

		return function equals_primitive( a, b ) {
			return ( a === b );
		};

	},

	clone: function( exemplarValue ) {

		var typeName = typeof exemplarValue;
		if ( typeName === "object" ) {
			if ( exemplarValue.clone ) {
				return exemplarValue.clone();
			}
			console.error( "can not figure out how to copy exemplarValue", exemplarValue );
		}

		return exemplarValue;

	},

	lerp: function( a, b, alpha, interTrack ) {

		var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );

		return lerpFunc( a, b, alpha );

	},

	lerp_object: function( a, b, alpha ) {
		return a.lerp( b, alpha );
	},

	slerp_object: function( a, b, alpha ) {
		return a.slerp( b, alpha );
	},

	lerp_number: function( a, b, alpha ) {
		return a * ( 1 - alpha ) + b * alpha;
	},

	lerp_boolean: function( a, b, alpha ) {
		return ( alpha < 0.5 ) ? a : b;
	},

	lerp_boolean_immediate: function( a, b, alpha ) {
		return a;
	},

	lerp_string: function( a, b, alpha ) {
		return ( alpha < 0.5 ) ? a : b;
	},

	lerp_string_immediate: function( a, b, alpha ) {
 		return a;
 	},

	// NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
	getLerpFunc: function( exemplarValue, interTrack ) {

		if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );

		var typeName = typeof exemplarValue;

		switch( typeName ) {

			case "object":
				if ( exemplarValue.lerp ) {
					return THREE.AnimationUtils.lerp_object;
				}

				if ( exemplarValue.slerp ) {
					return THREE.AnimationUtils.slerp_object;
				}
				break;

			case "number":
				return THREE.AnimationUtils.lerp_number;

			case "boolean":
				if ( interTrack ) {
					return THREE.AnimationUtils.lerp_boolean;
				} else {
					return THREE.AnimationUtils.lerp_boolean_immediate;
				}

			case "string":
				if ( interTrack ) {
					return THREE.AnimationUtils.lerp_string;
				} else {
					return THREE.AnimationUtils.lerp_string_immediate;
				}

		}

	}

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A Track that returns a keyframe interpolated value, currently linearly interpolated
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.KeyframeTrack = function ( name, keys ) {

	if ( name === undefined ) throw new Error( "track name is undefined" );
	if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );

	this.name = name;
	this.keys = keys;	// time in seconds, value as value

	// the index of the last result, used as a starting point for local search.
	this.lastIndex = 0;

	this.validate();
	this.optimize();

};

THREE.KeyframeTrack.prototype = {

	constructor: THREE.KeyframeTrack,

	getAt: function( time ) {


		// this can not go higher than this.keys.length.
		while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
			this.lastIndex ++;
		};

		// this can not go lower than 0.
		while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
			this.lastIndex --;
		}

		if ( this.lastIndex >= this.keys.length ) {

			this.setResult( this.keys[ this.keys.length - 1 ].value );

			return this.result;

		}

		if ( this.lastIndex === 0 ) {

			this.setResult( this.keys[ 0 ].value );

			return this.result;

		}

		var prevKey = this.keys[ this.lastIndex - 1 ];
		this.setResult( prevKey.value );

		// if true, means that prev/current keys are identical, thus no interpolation required.
		if ( prevKey.constantToNext ) {

			return this.result;

		}

		// linear interpolation to start with
		var currentKey = this.keys[ this.lastIndex ];
		var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
		this.result = this.lerpValues( this.result, currentKey.value, alpha );

		return this.result;

	},

	// move all keyframes either forwards or backwards in time
	shift: function( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			for ( var i = 0; i < this.keys.length; i ++ ) {
				this.keys[i].time += timeOffset;
			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function( timeScale ) {

		if ( timeScale !== 1.0 ) {

			for ( var i = 0; i < this.keys.length; i ++ ) {
				this.keys[i].time *= timeScale;
			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
 	trim: function( startTime, endTime ) {

		var firstKeysToRemove = 0;
		for ( var i = 1; i < this.keys.length; i ++ ) {
			if ( this.keys[i] <= startTime ) {
				firstKeysToRemove ++;
			}
		}

		var lastKeysToRemove = 0;
		for ( var i = this.keys.length - 2; i > 0; i ++ ) {
			if ( this.keys[i] >= endTime ) {
				lastKeysToRemove ++;
			} else {
				break;
			}
		}

		// remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
		if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
			this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
		}

		return this;

	},

	/* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
	         Tracks with out of order keys should be considered to be invalid.  - bhouston
	sort: function() {

		this.keys.sort( THREE.KeyframeTrack.keyComparer );

		return this;

	},*/

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	// One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
	validate: function() {

		var prevKey = null;

		if ( this.keys.length === 0 ) {
			console.error( "  track is empty, no keys", this );
			return;
		}

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var currKey = this.keys[i];

			if ( ! currKey ) {
				console.error( "  key is null in track", this, i );
				return;
			}

			if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
				console.error( "  key.time is not a valid number", this, i, currKey );
				return;
			}

			if ( currKey.value === undefined || currKey.value === null) {
				console.error( "  key.value is null in track", this, i, currKey );
				return;
			}

			if ( prevKey && prevKey.time > currKey.time ) {
				console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
				return;
			}

			prevKey = currKey;

		}

		return this;

	},

	// currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
	optimize: function() {

		var newKeys = [];
		var prevKey = this.keys[0];
		newKeys.push( prevKey );

		var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );

		for ( var i = 1; i < this.keys.length - 1; i ++ ) {
			var currKey = this.keys[i];
			var nextKey = this.keys[i+1];

			// if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
			// it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
			if ( ( prevKey.time === currKey.time ) ) {

				continue;

			}

			// remove completely unnecessary keyframes that are the same as their prev and next keys
			if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {

				continue;

			}

			// determine if interpolation is required
			prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );

			newKeys.push( currKey );
			prevKey = currKey;
		}
		newKeys.push( this.keys[ this.keys.length - 1 ] );

		this.keys = newKeys;

		return this;

	}

};

THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
	return key0.time - key1.time;
};

THREE.KeyframeTrack.parse = function( json ) {

	if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );

	var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );

	return trackType.parse( json );

};

THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
	switch( typeName.toLowerCase() ) {
	 	case "vector":
	 	case "vector2":
	 	case "vector3":
	 	case "vector4":
			return THREE.VectorKeyframeTrack;

	 	case "quaternion":
			return THREE.QuaternionKeyframeTrack;

	 	case "integer":
	 	case "scalar":
	 	case "double":
	 	case "float":
	 	case "number":
			return THREE.NumberKeyframeTrack;

	 	case "bool":
	 	case "boolean":
			return THREE.BooleanKeyframeTrack;

	 	case "string":
	 		return THREE.StringKeyframeTrack;
	};

	throw new Error( "Unsupported typeName: " + typeName );
};

// File:src/animation/PropertyBinding.js

/**
 *
 * A track bound to a real value in the scene graph.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.PropertyBinding = function ( rootNode, trackName ) {

	this.rootNode = rootNode;
	this.trackName = trackName;
	this.referenceCount = 0;
	this.originalValue = null; // the value of the property before it was controlled by this binding

	var parseResults = THREE.PropertyBinding.parseTrackName( trackName );

	this.directoryName = parseResults.directoryName;
	this.nodeName = parseResults.nodeName;
	this.objectName = parseResults.objectName;
	this.objectIndex = parseResults.objectIndex;
	this.propertyName = parseResults.propertyName;
	this.propertyIndex = parseResults.propertyIndex;

	this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;

	this.cumulativeValue = null;
	this.cumulativeWeight = 0;
};

THREE.PropertyBinding.prototype = {

	constructor: THREE.PropertyBinding,

	reset: function() {

		this.cumulativeValue = null;
		this.cumulativeWeight = 0;

	},

	accumulate: function( value, weight ) {

		if ( ! this.isBound ) this.bind();

		if ( this.cumulativeWeight === 0 ) {

			if ( weight > 0 ) {

				if ( this.cumulativeValue === null ) {
					this.cumulativeValue = THREE.AnimationUtils.clone( value );
				}
				this.cumulativeWeight = weight;

			}

		} else {

			var lerpAlpha = weight / ( this.cumulativeWeight + weight );
			this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
			this.cumulativeWeight += weight;

		}

	},

	unbind: function() {

		if ( ! this.isBound ) return;

		this.setValue( this.originalValue );

		this.setValue = null;
		this.getValue = null;
		this.lerpValue = null;
		this.equalsValue = null;
		this.triggerDirty = null;
		this.isBound = false;

	},

	// bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
	bind: function() {

		if ( this.isBound ) return;

		var targetObject = this.node;

 		// ensure there is a value node
		if ( ! targetObject ) {
			console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
			return;
		}

		if ( this.objectName ) {
			// special case were we need to reach deeper into the hierarchy to get the face materials....
			if ( this.objectName === "materials" ) {
				if ( ! targetObject.material ) {
					console.error( '  can not bind to material as node does not have a material', this );
					return;
				}
				if ( ! targetObject.material.materials ) {
					console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
					return;
				}
				targetObject = targetObject.material.materials;
			} else if ( this.objectName === "bones" ) {
				if ( ! targetObject.skeleton ) {
					console.error( '  can not bind to bones as node does not have a skeleton', this );
					return;
				}
				// potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				targetObject = targetObject.skeleton.bones;

				// support resolving morphTarget names into indices.
				for ( var i = 0; i < targetObject.length; i ++ ) {
					if ( targetObject[i].name === this.objectIndex ) {
						this.objectIndex = i;
						break;
					}
				}
			} else {

				if ( targetObject[ this.objectName ] === undefined ) {
					console.error( '  can not bind to objectName of node, undefined', this );
					return;
				}
				targetObject = targetObject[ this.objectName ];
			}

			if ( this.objectIndex !== undefined ) {
				if ( targetObject[ this.objectIndex ] === undefined ) {
					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;
				}

				targetObject = targetObject[ this.objectIndex ];
			}

		}

 		// special case mappings
 		var nodeProperty = targetObject[ this.propertyName ];
		if ( ! nodeProperty ) {
			console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
			return;
		}

		// access a sub element of the property array (only primitives are supported right now)
		if ( this.propertyIndex !== undefined ) {

			if ( this.propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {
					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
				}
				if ( ! targetObject.geometry.morphTargets ) {
					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
					if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
						this.propertyIndex = i;
						break;
					}
				}
			}

			this.setValue = function setValue_propertyIndexed( value ) {
				if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
					nodeProperty[ this.propertyIndex ] = value;
					return true;
				}
				return false;
			};

			this.getValue = function getValue_propertyIndexed() {
				return nodeProperty[ this.propertyIndex ];
			};

		}
		// must use copy for Object3D.Euler/Quaternion
		else if ( nodeProperty.copy ) {

			this.setValue = function setValue_propertyObject( value ) {
				if ( ! this.equalsValue( nodeProperty, value ) ) {
					nodeProperty.copy( value );
					return true;
				}
				return false;
			}

			this.getValue = function getValue_propertyObject() {
				return nodeProperty;
			};

		}
		// otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
		else {

			this.setValue = function setValue_property( value ) {
				if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
					targetObject[ this.propertyName ] = value;
					return true;
				}
				return false;
			}

			this.getValue = function getValue_property() {
				return targetObject[ this.propertyName ];
			};

		}

		// trigger node dirty
		if ( targetObject.needsUpdate !== undefined ) { // material

			this.triggerDirty = function triggerDirty_needsUpdate() {
				this.node.needsUpdate = true;
			}

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
				targetObject.matrixWorldNeedsUpdate = true;
			}

		}

		this.originalValue = this.getValue();

		this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
		this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );

		this.isBound = true;

	},

	apply: function() {

		// for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
		if ( ! this.isBound ) this.bind();

		// early exit if there is nothing to apply.
		if ( this.cumulativeWeight > 0 ) {

			// blend with original value
			if ( this.cumulativeWeight < 1 ) {

				var remainingWeight = 1 - this.cumulativeWeight;
				var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
				this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );

			}

			var valueChanged = this.setValue( this.cumulativeValue );

			if ( valueChanged && this.triggerDirty ) {
				this.triggerDirty();
			}

			// reset accumulator
			this.cumulativeValue = null;
			this.cumulativeWeight = 0;

		}
	}

};


THREE.PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//	  .bone[Armature.DEF_cog].position
	// created and tested via https://regex101.com/#javascript

	var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
	var matches = re.exec(trackName);

	if ( ! matches ) {
		throw new Error( "cannot parse trackName at all: " + trackName );
	}

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

	var results = {
		directoryName: matches[1],
		nodeName: matches[3], 	// allowed to be null, specified root node.
		objectName: matches[5],
		objectIndex: matches[7],
		propertyName: matches[9],
		propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
	};

	if ( results.propertyName === null || results.propertyName.length === 0 ) {
		throw new Error( "can not parse propertyName from trackName: " + trackName );
	}

	return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

	function searchSkeleton( skeleton ) {

		for ( var i = 0; i < skeleton.bones.length; i ++ ) {

			var bone = skeleton.bones[i];

			if ( bone.name === nodeName ) {

				return bone;

			}
		}

		return null;

	}

	function searchNodeSubtree( children ) {

		for ( var i = 0; i < children.length; i ++ ) {

			var childNode = children[i];

			if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

				return childNode;

			}

			var result = searchNodeSubtree( childNode.children );

			if ( result ) return result;

		}

		return null;

	}

	//

	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if ( root.skeleton ) {

		var bone = searchSkeleton( root.skeleton );

		if ( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if ( root.children ) {

		var subTreeNode = searchNodeSubtree( root.children );

		if ( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;
}

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track that interpolates Vectors
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.VectorKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value.clone();

};

THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;

THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {

	this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0.lerp( value1, alpha );

};

THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return value0.equals( value1 );

};

THREE.VectorKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value.clone()
		} );
	}

	return new THREE.VectorKeyframeTrack( this.name, clonedKeys );

};

THREE.VectorKeyframeTrack.parse = function( json ) {

	var elementCount = json.keys[0].value.length;
	var valueType = THREE[ 'Vector' + elementCount ];

	var keys = [];

	for ( var i = 0; i < json.keys.length; i ++ ) {
		var jsonKey = json.keys[i];
		keys.push( {
			value: new valueType().fromArray( jsonKey.value ),
			time: jsonKey.time
		} );
	}

	return new THREE.VectorKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track that interpolates Quaternion
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.QuaternionKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value.clone();

};

THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;

THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {

	this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0.slerp( value1, alpha );

};

THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return value0.equals( value1 );

};

THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {

	for ( var i = 0; i < this.keys.length; i ++ ) {

		this.keys[i].value.multiply( quat );

	}

	return this;

};

THREE.QuaternionKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value.clone()
		} );
	}

	return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );

};

THREE.QuaternionKeyframeTrack.parse = function( json ) {

	var keys = [];

	for ( var i = 0; i < json.keys.length; i ++ ) {
		var jsonKey = json.keys[i];
		keys.push( {
			value: new THREE.Quaternion().fromArray( jsonKey.value ),
			time: jsonKey.time
		} );
	}

	return new THREE.QuaternionKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.StringKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;

THREE.StringKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.StringKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.StringKeyframeTrack( this.name, clonedKeys );

};

THREE.StringKeyframeTrack.parse = function( json ) {

	return new THREE.StringKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track that interpolates Boolean
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.BooleanKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;

THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.BooleanKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );

};

THREE.BooleanKeyframeTrack.parse = function( json ) {

	return new THREE.BooleanKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track that interpolates Numbers
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.NumberKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;

THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0 * ( 1 - alpha ) + value1 * alpha;

};

THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.NumberKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.NumberKeyframeTrack( this.name, clonedKeys );

};

THREE.NumberKeyframeTrack.parse = function( json ) {

	return new THREE.NumberKeyframeTrack( json.name, json.keys );

};

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {

	THREE.Camera.prototype.copy.call( this, source );

	this.left = source.left;
	this.right = source.right;
	this.top = source.top;
	this.bottom = source.bottom;
	this.near = source.near;
	this.far = source.far;

	this.zoom = source.zoom;

	return this;

};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.left = this.left;
	data.object.right = this.right;
	data.object.top = this.top;
	data.object.bottom = this.bottom;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {

	THREE.Camera.prototype.copy.call( this, source );

	this.fov = source.fov;
	this.aspect = source.aspect;
	this.near = source.near;
	this.far = source.far;

	this.zoom = source.zoom;

	return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.fov = this.fov;
	data.object.aspect = this.aspect;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';

	this.color = new THREE.Color( color );

	this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

Object.defineProperties( THREE.Light.prototype, {
	onlyShadow: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
		}
	},
	shadowCameraFov: {
		set: function ( value ) {
			this.shadow.camera.fov = value;
		}
	},
	shadowCameraLeft: {
		set: function ( value ) {
			this.shadow.camera.left = value;
		}
	},
	shadowCameraRight: {
		set: function ( value ) {
			this.shadow.camera.right = value;
		}
	},
	shadowCameraTop: {
		set: function ( value ) {
			this.shadow.camera.top = value;
		}
	},
	shadowCameraBottom: {
		set: function ( value ) {
			this.shadow.camera.bottom = value;
		}
	},
	shadowCameraNear: {
		set: function ( value ) {
			this.shadow.camera.near = value;
		}
	},
	shadowCameraFar: {
		set: function ( value ) {
			this.shadow.camera.far = value;
		}
	},
	shadowCameraVisible: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
		}
	},
	shadowBias: {
		set: function ( value ) {
			this.shadow.bias = value;
		}
	},
	shadowDarkness: {
		set: function ( value ) {
			this.shadow.darkness = value;
		}
	},
	shadowMapWidth: {
		set: function ( value ) {
			this.shadow.mapSize.width = value;
		}
	},
	shadowMapHeight: {
		set: function ( value ) {
			this.shadow.mapSize.height = value;
		}
	}
} );

THREE.Light.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

THREE.Light.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.color = this.color.getHex();
	if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

	if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
	if ( this.distance !== undefined ) data.object.distance = this.distance;
	if ( this.angle !== undefined ) data.object.angle = this.angle;
	if ( this.decay !== undefined ) data.object.decay = this.decay;
	if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

	return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.darkness = 1;

	this.mapSize = new THREE.Vector2( 512, 512 );

	this.map = null;
	this.matrix = null;

};

THREE.LightShadow.prototype = {

	constructor: THREE.LightShadow,

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.darkness = source.darkness;

		this.mapSize.copy( source.mapSize );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.groundColor.copy( source.groundColor );
	this.intensity = source.intensity;

	return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.distance = source.distance;
	this.decay = source.decay;

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.distance = source.distance;
	this.angle = source.angle;
	this.exponent = source.exponent;
	this.decay = source.decay;

	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var color, textureLoader, materialLoader;

		return function ( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new THREE.Color();
			if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = THREE.Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = THREE.Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: THREE.Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {
					case 'DbgColor':
						json.color = value;
						break;
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						// These were never supported
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = THREE[ value ];
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = THREE.BackSide;
						break;
					case 'doubleSided':
						json.side = THREE.DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'opacity':
					case 'transparent':
					case 'depthTest':
					case 'depthWrite':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = THREE.VertexColors;
						if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
						break;
					default:
						console.error( 'Loader.createMaterial: Unsupported', name, value );
						break;
				}

			}

			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader  = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

				}, 0 );

			}

			return cached;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			var response = event.target.response;

			THREE.Cache.add( url, response );

			if ( onLoad ) onLoad( response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		request.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;
		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

		request.send( null );

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

			} else {

				scope.manager.itemEnd( url );

			}

			return cached;

		}

		var image = document.createElement( 'img' );

		image.addEventListener( 'load', function ( event ) {

			THREE.Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		image.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

	constructor: THREE.JSONLoader,

	// Deprecated

	get statusDomElement () {

		if ( this._statusDomElement === undefined ) {

			this._statusDomElement = document.createElement( 'div' );

		}

		console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
		return this._statusDomElement;

	},

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				if ( metadata.type === 'object' ) {

					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
					return;

				}

				if ( metadata.type === 'scene' ) {

					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
					return;

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];
			if ( json.animation !== undefined ) {
				animations.push( json.animation );
			}
			if ( json.animations !== undefined ) {
				if ( json.animations.length ) {
					animations = animations.concat( json.animations );
				} else {
					animations.push( json.animations );
				}
			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var index = json.data.index;

		if ( index !== undefined ) {

			var typedArray = new self[ index.type ]( index.array );
			geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.textures = {};

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	getTexture: function ( name ) {

		var textures = this.textures;

		if ( textures[ name ] === undefined ) {

			console.warn( 'THREE.MaterialLoader: Undefined texture', name );

		}

		return textures[ name ];

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];
		material.uuid = json.uuid;

		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

		// for PointsMaterial
		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = this.getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = this.getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
		if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

		if ( json.envMap !== undefined ) {

			material.envMap = this.getTexture( json.envMap );
			material.combine = THREE.MultiplyOperation;

		}

		if ( json.reflectivity ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		// MeshFaceMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures  = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new THREE[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleBufferGeometry':

						geometry = new THREE.CircleBufferGeometry(
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereBufferGeometry':

						geometry = new THREE.SphereBufferGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':

						geometry = new THREE.DodecahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'OctahedronGeometry':

						geometry = new THREE.OctahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TetrahedronGeometry':

						geometry = new THREE.TetrahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':

						geometry = new THREE.RingGeometry(
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = THREE.AnimationClip.parse( json[i] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new THREE.LoadingManager( onLoad );

			var loader = new THREE.ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return THREE[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new THREE.Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;
				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
				if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
				if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
				if ( Array.isArray( data.wrap ) ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ] );
					texture.wrapT = parseConstant( data.wrap[ 1 ] );

				}

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LOD':

					object = new THREE.LOD();

					break;

				case 'Line':

					object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'PointCloud':
				case 'Points':

					object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new THREE.Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new THREE.Texture();

		var loader = new THREE.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.CubeTextureLoader.prototype = {

	constructor: THREE.CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new THREE.CubeTexture( [] );

		var loader = new THREE.ImageLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

	constructor: THREE.BinaryTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.DataTexture();

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = THREE.LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setResponseType( 'arraybuffer' );

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = THREE.LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue instanceof THREE.Color ) {

				currentValue.set( newValue );

			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
		if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
		if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;

		if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap instanceof THREE.Texture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap instanceof THREE.Texture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

		}
		if ( this.displacementMap instanceof THREE.Texture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.envMap instanceof THREE.Texture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
		if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
		if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
		if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;
		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.side = source.side;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blending = source.blending;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.overdraw = source.overdraw;

		this.visible = source.visible;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	// Deprecated

	get wrapAround () {

		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

	},

	set wrapAround ( boolean ) {

		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

	},

	get wrapRGB () {

		console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
		return new THREE.Color();

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.emissive = new THREE.Color( 0x000000 );

	this.map = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.emissive.copy( source.emissive );

	this.map = source.map;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.emissive.copy( source.emissive );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.metal = source.metal;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissiveMap = source.emissiveMap;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = materials instanceof Array ? materials : [];

	this.visible = true;

};

THREE.MultiMaterial.prototype = {

	constructor: THREE.MultiMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function ( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.derivatives = false; // set to use derivatives

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

	this.attributes = source.attributes;
	this.defines = source.defines;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.fog = source.fog;

	this.lights = source.lights;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.derivatives = source.derivatives;

	return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = THREE.Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.attributes = this.attributes;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	this.fog = source.fog;

	return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.sourceFile = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this.version = 0;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	set needsUpdate ( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElement( 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = THREE.Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== THREE.UVMapping )  return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case THREE.RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case THREE.RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;
	this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

	THREE.Texture.prototype.copy.call( this, source );

	this.images = source.images;

	return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

	this.flipY = false;
	this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function raycast( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.Points.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;
		var position = new THREE.Vector3();

		function testPoint( point, index ) {

			var rayPointDistanceSq = ray.distanceSqToPoint( point );

			if ( rayPointDistanceSq < localThresholdSq ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					distanceToRay: Math.sqrt( rayPointDistanceSq ),
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, il = indices.length; i < il; i ++ ) {

					var a = indices[ i ];

					position.fromArray( positions, a * 3 );

					testPoint( position, a );

				}

			} else {

				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

					position.fromArray( positions, i * 3 );

					testPoint( position, i );

				}

			}

		} else {

			var vertices = geometry.vertices;

			for ( var i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.Points.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// Backwards compatibility

THREE.PointCloud = function ( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new THREE.LineSegments( geometry, material );

	}

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function raycast( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var vStart = new THREE.Vector3();
		var vEnd = new THREE.Vector3();
		var interSegment = new THREE.Vector3();
		var interRay = new THREE.Vector3();
		var step = this instanceof THREE.LineSegments ? 2 : 1;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;

			if ( index !== null ) {

				var indices = index.array;
				var positions = attributes.position.array;

				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

					var a = indices[ i ];
					var b = indices[ i + 1 ];

					vStart.fromArray( positions, a * 3 );
					vEnd.fromArray( positions, b * 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				var distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

	THREE.Line.call( this, geometry, material );

	this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var tempA = new THREE.Vector3();
	var tempB = new THREE.Vector3();
	var tempC = new THREE.Vector3();

	var uvA = new THREE.Vector2();
	var uvB = new THREE.Vector2();
	var uvC = new THREE.Vector2();

	var barycoord = new THREE.Vector3();

	var intersectionPoint = new THREE.Vector3();
	var intersectionPointWorld = new THREE.Vector3();

	function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

		THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

		uv1.multiplyScalar( barycoord.x );
		uv2.multiplyScalar( barycoord.y );
		uv3.multiplyScalar( barycoord.z );

		uv1.add( uv2 ).add( uv3 );

		return uv1.clone();

	}

	function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){

		var intersect;
		var material = object.material;

		if ( material.side === THREE.BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

		}

		if ( intersect === null ) return null;

		intersectionPointWorld.copy( point );
		intersectionPointWorld.applyMatrix4( object.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

		vA.fromArray( positions, a * 3 );
		vB.fromArray( positions, b * 3 );
		vC.fromArray( positions, c * 3 );

		var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

		if ( intersection ) {

			if ( uvs ) {

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

			}

			intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
			intersection.faceIndex = a;

		}

		return intersection;

	}

	return function raycast( raycaster, intersects ) {

		var geometry = this.geometry;
		var material = this.material;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		var matrixWorld = this.matrixWorld;

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;

		// Check boundingBox before continuing

		inverseMatrix.getInverse( matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;

		}

		var uvs, intersection;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var a, b, c;
			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.uv !== undefined ){

				uvs = attributes.uv.array;

			}

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length; i < l; i += 3 ) {

					a = indices[ i ];
					b = indices[ i + 1 ];
					c = indices[ i + 2 ];

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
						intersects.push( intersection );

					}

				}

			} else {


				for ( var i = 0, l = positions.length; i < l; i += 9 ) {

					a = i / 3;
					b = a + 1;
					c = a + 2;

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.index = a; // triangle number in positions buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var fvA, fvB, fvC;
			var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
			var materials = isFaceMaterial === true ? material.materials : null;

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

				var face = faces[ f ];
				var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				fvA = vertices[ face.a ];
				fvB = vertices[ face.b ];
				fvC = vertices[ face.c ];

				if ( faceMaterial.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
						vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
						vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

					}

					vA.add( fvA );
					vB.add( fvB );
					vC.add( fvC );

					fvA = vA;
					fvB = vB;
					fvC = vC;

				}

				intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

				if ( intersection ) {

					if ( uvs ) {

						var uvs_f = uvs[ f ];
						uvA.copy( uvs_f[ 0 ] );
						uvB.copy( uvs_f[ 1 ] );
						uvC.copy( uvs_f[ 2 ] );

						intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

	THREE.Object3D.call( this );

	this.type = 'Bone';

	this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.skin = source.skin;

	return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();

	return function update() {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

} )();

THREE.Skeleton.prototype.clone = function () {

	return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );

		this.skeleton.calculateInverses();

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function() {

	return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		},
		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}
	} );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	var levels = this.levels;

	for ( var l = 0; l < levels.length; l ++ ) {

		if ( distance < levels[ l ].distance ) {

			break;

		}

	}

	levels.splice( l, 0, { distance: distance, object: object } );

	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	var levels = this.levels;

	for ( var i = 1, l = levels.length; i < l; i ++ ) {

		if ( distance < levels[ i ].distance ) {

			break;

		}

	}

	return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function update( camera ) {

		var levels = this.levels;

		if ( levels.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			levels[ 0 ].object.visible = true;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source, false );

	var levels = source.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		this.addLevel( level.object.clone(), level.distance );

	}

	return this;

};

THREE.LOD.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.levels = [];

	var levels = this.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		data.object.levels.push( {
			object: level.object.uuid,
			distance: level.distance
		} );

	}

	return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function Sprite( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
		var guessSizeSq = this.scale.x * this.scale.y;

		if ( distanceSq > guessSizeSq ) {

			return;

		}

		intersects.push( {

			distance: Math.sqrt( distanceSq ),
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function () {

	return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture,	// THREE.Texture
		size: size, 		// size in pixels (-1 = use texture.width)
		distance: distance, 	// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
		scale: 1, 		// scale
		rotation: 0, 		// rotation
		opacity: opacity,	// opacity
		color: color,		// color
		blending: blending	// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for ( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};

THREE.LensFlare.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.positionScreen.copy( source.positionScreen );
	this.customUpdateCallback = source.customUpdateCallback;

	for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

		this.lensFlares.push( source.lensFlares[ i ] );

	}

	return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl

THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl

THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix3 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 }

	},

	aomap: {

		"aoMap" : { type: "t", value: null },
		"aoMapIntensity" : { type: "f", value: 1 },

	},

	lightmap: {

		"lightMap" : { type: "t", value: null },
		"lightMapIntensity" : { type: "f", value: 1 },

	},

	emissivemap: {

		"emissiveMap" : { type: "t", value: null },

	},

	bumpmap: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

	},

	displacementmap: {

		"displacementMap" : { type: "t", value: null },
		"displacementScale" : { type: "f", value: 1 },
		"displacementBias" : { type: "f", value: 0 }

	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },
		"pointLightDecay" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] },
		"spotLightDecay" : { type: "fv1", value: [] }

	},

	points: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "aomap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "aomap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "aomap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
			"uniform float opacity;",

			"uniform vec3 ambientLightColor;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = ambientLightColor;",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

			"		if ( gl_FrontFacing )",
			"			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
			"		else",
			"			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",

			"	#else",

			"		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",

			"	#endif",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "aomap" ],
			THREE.UniformsLib[ "lightmap" ],
			THREE.UniformsLib[ "emissivemap" ],
			THREE.UniformsLib[ "bumpmap" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "displacementmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",

			"#ifndef FLAT_SHADED",

			"	varying vec3 vNormal;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

			"	vNormal = normalize( transformedNormal );",

			"#endif",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "displacementmap_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = - mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "aomap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = ambientLightColor;",
			"	vec3 totalEmissiveLight = emissive;",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "normal_phong_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "hemilight_fragment" ],
				THREE.ShaderChunk[ "aomap_fragment" ],
				THREE.ShaderChunk[ "emissivemap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				"totalDiffuseLight *= shadowMask;",
				"totalSpecularLight *= shadowMask;",

				"#ifdef METAL",

				"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",

				"#else",

				"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",

				"#endif",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'points': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "points" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( psColor, opacity );",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb * shadowMask;",

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],

			"	outgoingLight = diffuseColor.rgb;", // simple shader

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join( "\n" )

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vWorldPosition = transformDirection( position, modelMatrix );",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'equirect': {

		uniforms: { "tEquirect": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vWorldPosition = transformDirection( position, modelMatrix );",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform sampler2D tEquirect;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
				"vec3 direction = normalize( vWorldPosition );",
				"vec2 sampleUV;",
				"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
				"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
				"gl_FragColor = texture2D( tEquirect, sampleUV );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join( "\n" )

	},


	'distanceRGBA': {

		uniforms: {

			"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

		},

		vertexShader: [

			"varying vec4 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],

				"vWorldPosition = worldPosition;",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 lightPos;",
			"varying vec4 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],

			"vec4 pack1K ( float depth ) {",

			"   depth /= 1000.0;",
			"   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
  			"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
   			"	vec4 res = fract( depth * bitSh );",
   			"	res -= res.xxyz * bitMsk;",
   			"	return res; ",

			"}",

			"float unpack1K ( vec4 color ) {",

			"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"	return dot( color, bitSh ) * 1000.0;",

			"}",

			"void main () {",

			"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

			"}"

		].join( "\n" )

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_width = _canvas.width,
	_height = _canvas.height,

	pixelRatio = 1,

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );


	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// internal properties

	var _this = this,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryProgram = '',
	_currentCamera = null,

	_usedTextureUnits = 0,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: [], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	},

	// info

	_infoMemory = {

		geometries: 0,
		textures: 0

	},

	_infoRender = {

		calls: 0,
		vertices: 0,
		faces: 0,
		points: 0

	};

	this.info = {

		render: _infoRender,
		memory: _infoMemory,
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		THREE.BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

	var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new THREE.WebGLProperties();
	var objects = new THREE.WebGLObjects( _gl, properties, this.info );
	var programCache = new THREE.WebGLPrograms( this, capabilities );

	this.info.programs = programCache.programs;

	var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	function glClearColor( r, g, b, a ) {

		if ( _premultipliedAlpha === true ) {

			r *= a; g *= a; b *= a;

		}

		_gl.clearColor( r, g, b, a );

	}

	function setDefaultGLState() {

		state.init();

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.state = state;

	// shadow map

	var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function getMaxAnisotropy() {

			if ( value !== undefined ) return value;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				value = 0;

			}

			return value;

		}

	} )();

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value !== undefined ) pixelRatio = value;

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * pixelRatio;
		_viewportY = y * pixelRatio;

		_viewportWidth = width * pixelRatio;
		_viewportHeight = height * pixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.getViewport = function ( dimensions ) {

		dimensions.x = _viewportX / pixelRatio;
		dimensions.y = _viewportY / pixelRatio;

		dimensions.z = _viewportWidth / pixelRatio;
		dimensions.w = _viewportHeight / pixelRatio;

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * pixelRatio,
			y * pixelRatio,
			width * pixelRatio,
			height * pixelRatio
		);

	};

	this.enableScissorTest = function ( boolean ) {

		state.setScissorTest( boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	};

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( numericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			var uniforms = program.getUniforms();

			if ( uniforms.morphTargetInfluences !== null ) {

				_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

			}

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataStart = 0;
		var dataCount = Infinity;

		if ( index !== null ) {

			dataCount = index.count

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start;
		var rangeCount = geometry.drawRange.count;

		var groupStart = group !== null ? group.start : 0;
		var groupCount = group !== null ? group.count : Infinity;

		var drawStart = Math.max( dataStart, rangeStart, groupStart );
		var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		//

		if ( object instanceof THREE.Mesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * pixelRatio );
				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry );

			} else {

				renderer.render( drawStart, drawCount );

			}

		} else if ( object instanceof THREE.Line ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * pixelRatio );

			if ( object instanceof THREE.LineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

			renderer.render( drawStart, drawCount );

		} else if ( object instanceof THREE.Points ) {

			renderer.setMode( _gl.POINTS );
			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry instanceof THREE.InstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;
					var buffer = objects.getAttributeBuffer( geometryAttribute );

					if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data instanceof THREE.InstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

					} else {

						if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	function painterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene, camera );

		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		shadowMap.render( scene );

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
			renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( THREE.NoBlending );
			renderObjects( opaqueObjects, camera, lights, fog );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
			if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				 updateRenderTargetMipmap( renderTarget );

			}

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof THREE.ImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object instanceof THREE.ImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, lights, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

			}

		}

	}

	function initMaterial( material, lights, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters( material, lights, fog, object );
		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = THREE.ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		materialProperties.uniformsList = [];

		var uniformLocations = materialProperties.program.getUniforms();

		for ( var u in materialProperties.__webglShader.uniforms ) {

			var location = uniformLocations[ u ];

			if ( location ) {

				materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

			}

		}

	}

	function setMaterial( material ) {

		setMaterialFaces( material );

		if ( material.transparent === true ) {

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

		} else {

			state.setBlending( THREE.NoBlending );

		}

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setMaterialFaces( material ) {

		material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
		state.setFlipSided( material.side === THREE.BackSide );

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( material.needsUpdate || ! materialProperties.program ) {

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === - 1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( capabilities.logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== undefined ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== undefined ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== undefined ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== undefined ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights, camera );
					_lightsNeedUpdate = false;

				}

				if ( refreshLights ) {

					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );

				} else {

					markUniformsLightsNeedsUpdate( m_uniforms, false );

				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointsMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights, camera );

			}

			// load common uniforms

			loadUniformsGeneric( materialProperties.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== undefined ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value = material.emissive;

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;
		uniforms.pointLightDecay.value = lights.point.decays;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;
		uniforms.spotLightDecay.value = lights.spot.decays;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLightColor.needsUpdate = value;
		uniforms.directionalLightDirection.needsUpdate = value;

		uniforms.pointLightColor.needsUpdate = value;
		uniforms.pointLightPosition.needsUpdate = value;
		uniforms.pointLightDistance.needsUpdate = value;
		uniforms.pointLightDecay.needsUpdate = value;

		uniforms.spotLightColor.needsUpdate = value;
		uniforms.spotLightPosition.needsUpdate = value;
		uniforms.spotLightDistance.needsUpdate = value;
		uniforms.spotLightDirection.needsUpdate = value;
		uniforms.spotLightAngleCos.needsUpdate = value;
		uniforms.spotLightExponent.needsUpdate = value;
		uniforms.spotLightDecay.needsUpdate = value;

		uniforms.hemisphereLightSkyColor.needsUpdate = value;
		uniforms.hemisphereLightGroundColor.needsUpdate = value;
		uniforms.hemisphereLightDirection.needsUpdate = value;

	}

	function refreshUniformsShadow ( uniforms, lights, camera ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( light.castShadow === true ) {

					if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {

						var shadow = light.shadow;

						if ( light instanceof THREE.PointLight ) {

							// for point lights we set the shadow matrix to be a translation-only matrix
							// equal to inverse of the light's position
							_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
							shadow.matrix.identity().setPosition( _vector3 );

							// for point lights we set the sign of the shadowDarkness uniform to be negative
							uniforms.shadowDarkness.value[ j ] = - shadow.darkness;

						} else {

							uniforms.shadowDarkness.value[ j ] = shadow.darkness;

						}

						uniforms.shadowMatrix.value[ j ] = shadow.matrix;
						uniforms.shadowMap.value[ j ] = shadow.map;
						uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
						uniforms.shadowBias.value[ j ] = shadow.bias;

						j ++;

					}

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

						uniform._array[ i2 + 0 ] = value[ i ].x;
						uniform._array[ i2 + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

						uniform._array[ i3 + 0 ] = value[ i ].x;
						uniform._array[ i3 + 1 ] = value[ i ].y;
						uniform._array[ i3 + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

						uniform._array[ i4 + 0 ] = value[ i ].x;
						uniform._array[ i4 + 1 ] = value[ i ].y;
						uniform._array[ i4 + 2 ] = value[ i ].z;
						uniform._array[ i4 + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

						// CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture.texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTarget ) {

						_this.setTexture( texture.texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d or cube)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
							 ( texture.image instanceof Array && texture.image.length === 6 ) ) {

							// CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTarget ) {

							_this.setTexture( texture.texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture.texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset + 0 ] = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights, camera ) {

		var l, ll, light,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,
		distance,

		zlights = _lights,

		viewMatrix = camera.matrixWorldInverse,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,
		pointDecays = zlights.point.decays,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,
		spotDecays = zlights.spot.decays,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				r += color.r;
				g += color.g;
				b += color.b;

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.transformDirection( viewMatrix );

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset + 0 ] = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				setColorLinear( dirColors, dirOffset, color, intensity );

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				setColorLinear( pointColors, pointOffset, color, intensity );

				_vector3.setFromMatrixPosition( light.matrixWorld );
				_vector3.applyMatrix4( viewMatrix );

				pointPositions[ pointOffset + 0 ] = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				// distance is 0 if decay is 0, because there is no attenuation at all.
				pointDistances[ pointLength ] = distance;
				pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				setColorLinear( spotColors, spotOffset, color, intensity );

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.copy( _direction ).applyMatrix4( viewMatrix );

				spotPositions[ spotOffset + 0 ] = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.transformDirection( viewMatrix );

				spotDirections[ spotOffset + 0 ] = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;
				spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.transformDirection( viewMatrix );

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset + 0 ] = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
				setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			state.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			state.enable( _gl.CULL_FACE );

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

			texture.image = makePowerOfTwo( texture.image );

		}

		var image = texture.image,
		isImagePowerOfTwo = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	this.setTexture = function ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
				return;

			}

			if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
				return;

			}

			uploadTexture( textureProperties, texture, slot );

			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
		if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

		return false;

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElement( 'canvas' );
			canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
			canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
				glFormat = paramThreeToGL( renderTarget.texture.format ),
				glType = paramThreeToGL( renderTarget.texture.type );

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];
				renderTargetProperties.__webglRenderbuffer = [];

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
					state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

				}

				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;

				if ( texture.format !== THREE.RGBAFormat
					&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( texture.type !== THREE.UnsignedByteType
					&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
					&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
					&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	function updateRenderTargetMipmap( renderTarget ) {

		var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
		var texture = properties.get( renderTarget.texture ).__webglTexture;

		state.bindTexture( target, texture );
		_gl.generateMipmap( target );
		state.bindTexture( target, null );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		extension = extensions.get( 'OES_texture_half_float' );

		if ( extension !== null ) {

			if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

		}

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// DEPRECATED

	this.supportsFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return extensions.get( 'OES_texture_float' );

	};

	this.supportsHalfFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return extensions.get( 'OES_texture_half_float' );

	};

	this.supportsStandardDerivatives = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return extensions.get( 'EXT_blend_minmax' );

	};

	this.supportsVertexTextures = function () {

		return capabilities.vertexTextures;

	};

	this.supportsInstancedArrays = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return extensions.get( 'ANGLE_instanced_arrays' );

	};

	//

	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

	Object.defineProperties( this, {
		shadowMapEnabled: {
			get: function () {

				return shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				return shadowMap.cullFace;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				shadowMap.cullFace = value;

			}
		},
		shadowMapDebug: {
			get: function () {

				return shadowMap.debug;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
				shadowMap.debug = value;

			}
		}
	} );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.uuid = THREE.Math.generateUUID();

	this.width = width;
	this.height = height;

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

	this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	get wrapS() {

		console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

		return this.texture.wrapS;

	},

	set wrapS( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

		this.texture.wrapS = value;

	},

	get wrapT() {

		console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

		return this.texture.wrapT;

	},

	set wrapT( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

		this.texture.wrapT = value;

	},

	get magFilter() {

		console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

		return this.texture.magFilter;

	},

	set magFilter( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

		this.texture.magFilter = value;

	},

	get minFilter() {

		console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

		return this.texture.minFilter;

	},

	set minFilter( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

		this.texture.minFilter = value;

	},

	get anisotropy() {

		console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

		return this.texture.anisotropy;

	},

	set anisotropy( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

		this.texture.anisotropy = value;

	},

	get offset() {

		console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

		return this.texture.offset;

	},

	set offset( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

		this.texture.offset = value;

	},

	get repeat() {

		console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

		return this.texture.repeat;

	},

	set repeat( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

		this.texture.repeat = value;

	},

	get format() {

		console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

		return this.texture.format;

	},

	set format( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

		this.texture.format = value;

	},

	get type() {

		console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

		return this.texture.type;

	},

	set type( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

		this.texture.type = value;

	},

	get generateMipmaps() {

		console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

		return this.texture.generateMipmaps;

	},

	set generateMipmaps( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

		this.texture.generateMipmaps = value;

	},

	//

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.shareDepthFrom = source.shareDepthFrom;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		_gl.drawArrays( mode, start, count );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		if ( position instanceof THREE.InterleavedBufferAttribute ) {

			extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

		} else {

			extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

		}

	}

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = _gl.UNSIGNED_INT;
			size = 4;

		} else {

			type = _gl.UNSIGNED_SHORT;
			size = 2;

		}

	}

	function render( start, count ) {

		_gl.drawElements( mode, count, type, start * size );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var index = geometry.index;

		extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

	}

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		if ( extension === null ) {

			console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	this.getMaxPrecision = getMaxPrecision;

	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	this.vertexTextures = this.maxVertexTextures > 0;
	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

	var _maxPrecision = getMaxPrecision( this.precision );

	if ( _maxPrecision !== this.precision ) {

		console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
		this.precision = _maxPrecision;

	}

	if ( this.logarithmicDepthBuffer ) {

		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

	}

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, properties, info ) {

	var geometries = {};

	function get( object ) {

		var geometry = object.geometry;

		if ( geometries[ geometry.id ] !== undefined ) {

			return geometries[ geometry.id ];

		}

		geometry.addEventListener( 'dispose', onGeometryDispose );

		var buffergeometry;

		if ( geometry instanceof THREE.BufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry instanceof THREE.Geometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		info.memory.geometries ++;

		return buffergeometry;

	}

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		var property = properties.get( geometry );
		if ( property.wireframe ) deleteAttribute( property.wireframe );

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, properties, info ) {

	var geometries = new THREE.WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry instanceof THREE.Geometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		attributeProperties.version = data.version;

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;
		var position = attributes.position;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var edges = {};
			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				if ( checkEdge( edges, a, b ) ) indices.push( a, b );
				if ( checkEdge( edges, b, c ) ) indices.push( b, c );
				if ( checkEdge( edges, c, a ) ) indices.push( c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
		var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	function checkEdge( edges, a, b ) {

		if ( a > b ) {

			var tmp = a;
			a = b;
			b = tmp;

		}

		var list = edges[ a ];

		if ( list === undefined ) {

			edges[ a ] = [ b ];
			return true;

		} else if ( list.indexOf( b ) === -1 ) {

			list.push( b );
			return true;

		}

		return false;

	}

	this.getAttributeBuffer = getAttributeBuffer;
	this.getWireframeAttribute = getWireframeAttribute;

	this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchUniformLocations( gl, program, identifiers ) {

		var uniforms = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveUniform( program, i );
			var name = info.name;
			var location = gl.getUniformLocation( program, name );

			// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

			var suffixPos = name.lastIndexOf( '[0]' );
			if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

				uniforms[ name.substr( 0, suffixPos ) ] = location;

			}

			uniforms[ name ] = location;

		}

		return uniforms;

	}

	function fetchAttributeLocations( gl, program, identifiers ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	return function WebGLProgram( renderer, code, material, parameters ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case THREE.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case THREE.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case THREE.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case THREE.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefixVertex = '';
			prefixFragment = '';

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				renderer.gammaInput ? '#define GAMMA_INPUT' : '',
				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				'#define MAX_BONES ' + parameters.maxBones,

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				renderer.gammaInput ? '#define GAMMA_INPUT' : '',
				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.metal ? '#define METAL' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program );
		var vertexLog = gl.getShaderInfoLog( glVertexShader );
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

		var runnable = true;
		var haveDiagnostics = true;

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function() {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = fetchUniformLocations( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function() {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function() {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
		"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
		"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
		"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
		"flipSided"
	];


	function allocateBones ( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;
		var pointLightShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
			if ( light instanceof THREE.PointLight ) {

				maxShadows ++;
				pointLightShadows ++;

			}

		}

		return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };

	}

	this.getParameters = function ( material, lights, fog, object ) {

		var shaderID = shaderIDs[ material.type ];
		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var allocatedShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			flatShading: material.shading === THREE.FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: allocatedShadows.maxShadows,
			pointLightShadows: allocatedShadows.pointLightShadows,
			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
			shadowMapType: renderer.shadowMap.type,
			shadowMapDebug: renderer.shadowMap.debug,

			alphaTest: material.alphaTest,
			metal: material.metal,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var chunks = [];

		if ( parameters.shaderID ) {

			chunks.push( parameters.shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			var parameterName = parameterNames[ i ];
			chunks.push( parameterName );
			chunks.push( parameters[ parameterName ] );

		}

		return chunks.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

THREE.WebGLProperties = function () {

	var properties = {};

	this.get = function ( object ) {

		var uuid = object.uuid;
		var map = properties[ uuid ];

		if ( map === undefined ) {

			map = {};
			properties[ uuid ] = map;

		}

		return map;

	};

	this.delete = function ( object ) {

		delete properties[ object.uuid ];

	};

	this.clear = function () {

		properties = {};

	};

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	return function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_lookTarget = new THREE.Vector3(),
	_lightPositionWorld = new THREE.Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants );

	var cubeDirections = [
		new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
		new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
	];

	var _vector4 = new THREE.Vector4();

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );

		depthMaterial._shadowPass = true;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new THREE.ShaderMaterial( {
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );

		distanceMaterial._shadowPass = true;

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = THREE.PCFShadowMap;
	this.cullFace = THREE.CullFaceFront;

	this.render = function ( scene ) {

		var faceCount, isPointLight;

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		// Set GL state for depth map.
		_gl.clearColor( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );
		_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
		_state.setDepthTest( true );

		// save the existing viewport so it can be restored later
		_renderer.getViewport( _vector4 );

		// render depth map

		for ( var i = 0, il = _lights.length; i < il; i ++ ) {

			var light = _lights[ i ];

			if ( light.castShadow === true ) {

				var shadow = light.shadow;
				var shadowCamera = shadow.camera;
				var shadowMapSize = shadow.mapSize;

				if ( light instanceof THREE.PointLight ) {

					faceCount = 6;
					isPointLight = true;

					var vpWidth = shadowMapSize.x / 4.0;
					var vpHeight = shadowMapSize.y / 2.0;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				} else {

					faceCount = 1;
					isPointLight = false;

				}

				if ( shadow.map === null ) {

					var shadowFilter = THREE.LinearFilter;

					if ( scope.type === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
					shadow.matrix = new THREE.Matrix4();

					//

					if ( light instanceof THREE.SpotLight ) {

						shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

					}

					shadowCamera.updateProjectionMatrix();

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						var vpDimensions = cube2DViewPorts[ face ];
						_renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );

					} else {

						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );

					}

					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					_renderList.length = 0;

					projectObject( scene, shadowCamera );

					// render shadow map
					// render regular objects

					for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

						var object = _renderList[ j ];
						var geometry = _objects.update( object );
						var material = object.material;

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

								var group = groups[ k ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );

								}

							}

						} else {

							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );

						}

					}

				}

				// We must call _renderer.resetGLState() at the end of each iteration of
				// the light loop in order to force material updates for each light.
				_renderer.resetGLState();

			}

		}

		_renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );
		_state.enable( _gl.BLEND );

		if ( scope.cullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var newMaterial = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = geometry.morphTargets !== undefined &&
					geometry.morphTargets.length > 0 && material.morphTargets;

			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			newMaterial = materialVariants[ variantIndex ];

		} else {

			newMaterial = customMaterial;

		}

		newMaterial.visible = material.visible;
		newMaterial.wireframe = material.wireframe;
		newMaterial.wireframeLinewidth = material.wireframeLinewidth;

		if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

			newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return newMaterial;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

	var _this = this;

	var newAttributes = new Uint8Array( 16 );
	var enabledAttributes = new Uint8Array( 16 );
	var attributeDivisors = new Uint8Array( 16 );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;

	var currentDepthFunc = null;
	var currentDepthWrite = null;

	var currentColorWrite = null;

	var currentFlipSided = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var currentTextureSlot = undefined;
	var currentBoundTextures = {};

	this.init = function () {

		gl.clearColor( 0, 0, 0, 1 );
		gl.clearDepth( 1 );
		gl.clearStencil( 0 );

		this.enable( gl.DEPTH_TEST );
		gl.depthFunc( gl.LEQUAL );

		gl.frontFace( gl.CCW );
		gl.cullFace( gl.BACK );
		this.enable( gl.CULL_FACE );

		this.enable( gl.BLEND );
		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

	};

	this.initAttributes = function () {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	};

	this.enableAttribute = function ( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	};

	this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	};

	this.disableUnusedAttributes = function () {

		for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	};

	this.enable = function ( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	};

	this.disable = function ( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	};

	this.getCompressedTextureFormats = function () {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

		if ( blending !== currentBlending ) {

			if ( blending === THREE.NoBlending ) {

				this.disable( gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				this.enable( gl.BLEND );

			} else {

				this.enable( gl.BLEND );
				gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
				gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

			}

			currentBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	};

	this.setDepthFunc = function ( depthFunc ) {

		if ( currentDepthFunc !== depthFunc ) {

			if ( depthFunc ) {

				switch ( depthFunc ) {

					case THREE.NeverDepth:

						gl.depthFunc( gl.NEVER );
						break;

					case THREE.AlwaysDepth:

						gl.depthFunc( gl.ALWAYS );
						break;

					case THREE.LessDepth:

						gl.depthFunc( gl.LESS );
						break;

					case THREE.LessEqualDepth:

						gl.depthFunc( gl.LEQUAL );
						break;

					case THREE.EqualDepth:

						gl.depthFunc( gl.EQUAL );
						break;

					case THREE.GreaterEqualDepth:

						gl.depthFunc( gl.GEQUAL );
						break;

					case THREE.GreaterDepth:

						gl.depthFunc( gl.GREATER );
						break;

					case THREE.NotEqualDepth:

						gl.depthFunc( gl.NOTEQUAL );
						break;

					default:

						gl.depthFunc( gl.LEQUAL );

				}

			} else {

				gl.depthFunc( gl.LEQUAL );

			}

			currentDepthFunc = depthFunc;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( currentDepthWrite !== depthWrite ) {

			gl.depthMask( depthWrite );
			currentDepthWrite = depthWrite;

		}

	};

	this.setColorWrite = function ( colorWrite ) {

		if ( currentColorWrite !== colorWrite ) {

			gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
			currentColorWrite = colorWrite;

		}

	};

	this.setFlipSided = function ( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	};

	this.setLineWidth = function ( width ) {

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			currentLineWidth = width;

		}

	};

	this.setPolygonOffset = function ( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

		if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

			gl.polygonOffset( factor, units );

			currentPolygonOffsetFactor = factor;
			currentPolygonOffsetUnits = units;

		}

	};

	this.setScissorTest = function ( scissorTest ) {

		if ( scissorTest ) {

			this.enable( gl.SCISSOR_TEST );

		} else {

			this.disable( gl.SCISSOR_TEST );

		}

	};

	// texture

	this.activeTexture = function ( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	this.bindTexture = function ( webglType, webglTexture ) {

		if ( currentTextureSlot === undefined ) {

			_this.activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	};

	this.compressedTexImage2D = function () {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	this.texImage2D = function () {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	//

	this.reset = function () {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentBlending = null;

		currentDepthWrite = null;
		currentColorWrite = null;

		currentFlipSided = null;

	};

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if ( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if ( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if ( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if ( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if ( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if ( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new THREE.Vector3();
	var spriteRotation = new THREE.Quaternion();
	var spriteScale = new THREE.Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

};

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new THREE.TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new THREE.CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.Shape: Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.ShapeUtils.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2: ( function () {

		function b2p0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function b2p1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function b2p2( t, p ) {

			return t * t * p;

		}

		return function ( t, p0, p1, p2 ) {

			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

		};

	} )(),

	// Cubic Bezier Functions

	b3: ( function () {

		function b3p0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function b3p1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function b3p2( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		}

		function b3p3( t, p ) {

			return t * t * t * p;

		}

		return function ( t, p0, p1, p2, p3 ) {

			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

		};

	} )()

};

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();
	this.source.onended = this.onEnded.bind( this );

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

	this.autoplay = false;

	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;

			if ( scope.autoplay ) scope.play();

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.play = function () {

	if ( this.isPlaying === true ) {

		console.warn( 'THREE.Audio: Audio is already playing.' );
		return;

	}

	var source = this.context.createBufferSource();

	source.buffer = this.source.buffer;
	source.loop = this.source.loop;
	source.onended = this.source.onended;
	source.start( 0, this.startTime );
	source.playbackRate.value = this.playbackRate;

	this.isPlaying = true;

	this.source = source;

	this.connect();

};

THREE.Audio.prototype.pause = function () {

	this.source.stop();
	this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

	this.source.stop();
	this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

	if ( this.filter !== undefined ) {

		this.source.connect( this.filter );
		this.filter.connect( this.panner );

	} else {

		this.source.connect( this.panner );

	}

};

THREE.Audio.prototype.disconnect = function () {

	if ( this.filter !== undefined ) {

		this.source.disconnect( this.filter );
		this.filter.disconnect( this.panner );

	} else {

		this.source.disconnect( this.panner );

	}

};

THREE.Audio.prototype.setFilter = function ( value ) {

	if ( this.isPlaying === true ) {

		this.disconnect();
		this.filter = value;
		this.connect();

	} else {

		this.filter = value;

	}

};

THREE.Audio.prototype.getFilter = function () {

	return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

	this.playbackRate = value;

	if ( this.isPlaying === true ) {

		this.source.playbackRate.value = this.playbackRate;

	}

};

THREE.Audio.prototype.getPlaybackRate = function () {

	return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

	this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

	return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function () {

	return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function () {

	return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function ( value ) {

	this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

	return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function updateMatrixWorld( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();

	return function updateMatrixWorld( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

	constructor: THREE.Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	}

}

THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

/*
THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};
*/

THREE.CurvePath.prototype.closePath = function() {

	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[ 0 ].getPoint( 0 );
	var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

	if ( ! startPoint.equals( endPoint ) ) {

		this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

	}

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			var diff = curveLengths[ i ] - d;
			var curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};
*/

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

		return this.cacheLengths;

	}

	// Get length of sub-curve
	// Push sums into cached array

	var lengths = [], sums = 0;

	for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0, l = points.length; i < l; i ++ ) {

		var point = points[ i ];
		geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

	}

	return geometry;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call( this );

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var i = 1, l = vectors.length; i < l; i ++ ) {

		this.lineTo( vectors[ i ].x, vectors[ i ].y );

	}

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve(
		new THREE.Vector2( x0, y0 ),
		new THREE.Vector2( aCPx, aCPy ),
		new THREE.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve(
		new THREE.Vector2( x0, y0 ),
		new THREE.Vector2( aCP1x, aCP1y ),
		new THREE.Vector2( aCP2x, aCP2y ),
		new THREE.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc( aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var args = [
		aX, aY,
		xRadius, yRadius,
		aStartAngle, aEndAngle,
		aClockwise,
		aRotation || 0 // aRotation is optional.
	];

	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	this.curves.push( curve );

	var lastPoint = curve.getPoint( 1 );
	args.push( lastPoint.x );
	args.push( lastPoint.y );

	this.actions.push( { action: 'ellipse', args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if ( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	divisions = divisions || 12;

	var b2 = THREE.ShapeUtils.b2;
	var b3 = THREE.ShapeUtils.b3;

	var points = [];

	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, tx, ty;

	for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

		var item = this.actions[ i ];

		var action = item.action;
		var args = item.args;

		switch ( action ) {

		case 'moveTo':

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'lineTo':

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'quadraticCurveTo':

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b2( t, cpx0, cpx1, cpx );
				ty = b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case 'bezierCurveTo':

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b3( t, cpx0, cpx1, cpx2, cpx );
				ty = b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case 'splineThru':

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( var j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) );

			}

			break;

		case 'arc':

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		case 'ellipse':

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ],
				aRotation = args[ 7 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			var cos, sin;
			if ( aRotation !== 0 ) {

				cos = Math.cos( aRotation );
				sin = Math.sin( aRotation );

			}

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				if ( aRotation !== 0 ) {

					var x = tx, y = ty;

					// Rotate the point about the center of the ellipse.
					tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
					ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

				}

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1 ];
	if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
			 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
		points.splice( points.length - 1, 1 );
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var subPaths = [], lastPath = new THREE.Path();

		for ( var i = 0, l = inActions.length; i < l; i ++ ) {

			var item = inActions[ i ];

			var args = item.args;
			var action = item.action;

			if ( action === 'moveTo' ) {

				if ( lastPath.actions.length !== 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length !== 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;

	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );

		}

		//console.log("shape", shapes);

		return shapes;

	}

	function isPointInsidePolygon( inPt, inPolygon ) {

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs( edgeDy ) > Number.EPSILON ) {

				// not parallel
				if ( edgeDy < 0 ) {

					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y === edgeLowPt.y ) {

					if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!

				} else {

					var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
					if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt

				}

			} else {

				// parallel or collinear
				if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
				// edge lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;

			}

		}

		return	inside;

	}

	var isClockWise = THREE.ShapeUtils.isClockWise;

	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length === 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length === 1 ) {

		tmpPath = subPaths[ 0 ];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);

	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[ mainIdx ] = undefined;
	newShapeHoles[ mainIdx ] = [];

	for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

			newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[ mainIdx ].s.actions = tmpPath.actions;
			newShapes[ mainIdx ].s.curves = tmpPath.curves;

			if ( holesFirst )	mainIdx ++;
			newShapeHoles[ mainIdx ] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {

		var ambiguous = false;
		var toChange = [];

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			betterShapeHoles[ sIdx ] = [];

		}

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			var sho = newShapeHoles[ sIdx ];

			for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

				var ho = sho[ hIdx ];
				var hole_unassigned = true;

				for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

					if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

						if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {

							hole_unassigned = false;
							betterShapeHoles[ s2Idx ].push( ho );

						} else {

							ambiguous = true;

						}

					}

				}
				if ( hole_unassigned ) {

					betterShapeHoles[ sIdx ].push( ho );

				}

			}

		}
		// console.log("ambiguous: ", ambiguous);
		if ( toChange.length > 0 ) {

			// console.log("to change: ", toChange);
			if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

		}

	}

	var tmpHoles;

	for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

		tmpShape = newShapes[ i ].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[ i ];

		for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

			tmpShape.holes.push( tmpHoles[ j ].h );

		}

	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );

	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	return new THREE.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	return new THREE.ShapeGeometry( this, options );

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var holesPts = [];

	for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getPoints( divisions );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	return this.extractAllPoints( divisions );

};

THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var b2 = THREE.ShapeUtils.b2;

	return new THREE.Vector2(
		b2( t, this.v0.x, this.v1.x, this.v2.x ),
		b2( t, this.v0.y, this.v1.y, this.v2.y )
	);

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

	return new THREE.Vector2(
		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
	).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var b3 = THREE.ShapeUtils.b3;

	return new THREE.Vector2(
		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	);

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

	return new THREE.Vector2(
		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	var interpolate = THREE.CurveUtils.interpolate;

	return new THREE.Vector2(
		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
	);

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

	this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}

	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x, ty = y;

		// Rotate the point about the center of the ellipse.
		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

	}

	return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var b2 = THREE.ShapeUtils.b2;

		return new THREE.Vector3(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y ),
			b2( t, this.v0.z, this.v1.z, this.v2.z )
		);

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var b3 = THREE.ShapeUtils.b3;

		return new THREE.Vector3(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
		);

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

	var
		tmp = new THREE.Vector3(),
		px = new CubicPoly(),
		py = new CubicPoly(),
		pz = new CubicPoly();

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

	}

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

		this.c0 = x0;
		this.c1 = t0;
		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

	};

	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

		// compute tangents when parameterized in [t1,t2]
		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

		// rescale tangents for parametrization in [0,1]
		t1 *= dt1;
		t2 *= dt1;

		// initCubicPoly
		this.init( x1, x2, t1, t2 );

	};

	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

	};

	CubicPoly.prototype.calc = function( t ) {

		var t2 = t * t;
		var t3 = t2 * t;
		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

	};

	// Subclass Three.js curve
	return THREE.Curve.create(

		function ( p /* array of Vector3 */ ) {

			this.points = p || [];

		},

		function ( t ) {

			var points = this.points,
				point, intPoint, weight, l;

			l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			point = ( l - 1 ) * t;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3;

			if ( intPoint === 0 ) {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			} else {

				p0 = points[ intPoint - 1 ];

			}

			p1 = points[ intPoint ];
			p2 = points[ intPoint + 1 ];

			if ( intPoint + 2 < l ) {

				p3 = points[ intPoint + 2 ]

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			var v = new THREE.Vector3(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return v;

		}

	);

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.BoxGeometry(
		parameters.width,
		parameters.height,
		parameters.depth,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.depthSegments
	);

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CircleGeometry(
		parameters.radius,
		parameters.segments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var vertices = segments + 2;

	var positions = new Float32Array( vertices * 3 );
	var normals = new Float32Array( vertices * 3 );
	var uvs = new Float32Array( vertices * 2 );

	// center data is already zero, but need to set a few extras
	normals[ 2 ] = 1.0;
	uvs[ 0 ] = 0.5;
	uvs[ 1 ] = 0.5;

	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

		var segment = thetaStart + s / segments * thetaLength;

		positions[ i ] = radius * Math.cos( segment );
		positions[ i + 1 ] = radius * Math.sin( segment );

		normals[ i + 2 ] = 1; // normal z

		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

	}

	var indices = [];

	for ( var i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CircleBufferGeometry(
		parameters.radius,
		parameters.segments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ heightSegments ][ x + 1 ];
			var v2 = vertices[ heightSegments ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
			var uv2 = uvs[ heightSegments ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CylinderGeometry(
		parameters.radiusTop,
		parameters.radiusBottom,
		parameters.height,
		parameters.radialSegments,
		parameters.heightSegments,
		parameters.openEnded,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

	THREE.BufferGeometry.call( this );

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	var geometry2;

	if ( geometry instanceof THREE.BufferGeometry ) {

		geometry2 = new THREE.Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = [];

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

			var vertex = vertices[ h.vert1 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

			vertex = vertices[ h.vert2 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

		}

	}

	this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new THREE.Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
		//bs = bevelSize * t; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];

		}

	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.ShapeUtils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	// Vertices

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PlaneGeometry(
		parameters.width,
		parameters.height,
		parameters.widthSegments,
		parameters.heightSegments
	);

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2 ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PlaneBufferGeometry(
		parameters.width,
		parameters.height,
		parameters.widthSegments,
		parameters.heightSegments
	);

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) {

		// concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) {

			// number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) {

		// concentric circles inside ring

		var thetaSegment = i * ( thetaSegments + 1 );

		for ( o = 0; o < thetaSegments ; o ++ ) {

			// number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.RingGeometry(
		parameters.innerRadius,
		parameters.outerRadius,
		parameters.thetaSegments,
		parameters.phiSegments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.SphereGeometry(
		parameters.radius,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.phiStart,
		parameters.phiLength,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

	var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	var index = 0, vertices = [], normal = new THREE.Vector3();

	for ( var y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];

		var v = y / heightSegments;

		for ( var x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;

			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var py = radius * Math.cos( thetaStart + v * thetaLength );
			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			normal.set( px, py, pz ).normalize();

			positions.setXYZ( index, px, py, pz );
			normals.setXYZ( index, normal.x, normal.y, normal.z );
			uvs.setXY( index, u, 1 - v );

			verticesRow.push( index );

			index ++;

		}

		vertices.push( verticesRow );

	}

	var indices = [];

	for ( var y = 0; y < heightSegments; y ++ ) {

		for ( var x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

		}

	}

	this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
	this.addAttribute( 'position', positions );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.SphereBufferGeometry(
		parameters.radius,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.phiStart,
		parameters.phiLength,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TorusGeometry(
		parameters.radius,
		parameters.tube,
		parameters.radialSegments,
		parameters.tubularSegments,
		parameters.arc
	);

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;

	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TorusKnotGeometry(
		parameters.radius,
		parameters.tube,
		parameters.radialSegments,
		parameters.tubularSegments,
		parameters.p,
		parameters.q,
		parameters.heightScale
	);

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed,
		taper: taper
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	taper = taper || THREE.TubeGeometry.NoTaper;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		u, v, r,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// construct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		r = radius * taper( u );

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = r * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}

	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
			jp = ( j + 1 ) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.prototype.clone = function() {

	return new this.constructor( this.parameters.path,
		this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
		this.parameters.closed, this.parameters.taper
	);

};

THREE.TubeGeometry.NoTaper = function ( u ) {

	return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

	return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	normal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		smallest,

		tx, ty, tz,
		i, u;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {

			smallest = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= smallest ) {

			smallest = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= smallest ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i - 1 ].clone();

		binormals[ i ] = binormals[ i - 1 ].clone();

		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

		if ( vec.length() > Number.EPSILON ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, x1, x2 );
		var min = Math.min( x0, x1, x2 );

		if ( max > 0.9 && min < 0.1 ) {

			// 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3, materialIndex ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow( 2, detail );
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		var materialIndex = face.materialIndex;

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k ],
						v[ i ][ k ],
						materialIndex
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k + 1 ],
						v[ i + 1 ][ k ],
						materialIndex
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PolyhedronGeometry(
		parameters.vertices,
		parameters.indices,
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		 1, - 1, - 1,     1, - 1,  1,
		 1,  1, - 1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.DodecahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.IcosahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.OctahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TetrahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, j, p;
	var u, v;

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}

	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = ( i + 1 ) * sliceCount + j + 1;
			d = ( i + 1 ) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

	THREE.BufferGeometry.call( this );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	if ( geometry instanceof THREE.Geometry ) {

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j ] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( geometry instanceof THREE.BufferGeometry ) {

		if ( geometry.index !== null ) {

			// Indexed BufferGeometry

			var indices = geometry.index.array;
			var vertices = geometry.attributes.position;
			var drawcalls = geometry.drawcalls;
			var numEdges = 0;

			if ( drawcalls.length === 0 ) {

				geometry.addGroup( 0, indices.length );

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var drawcall = drawcalls[ o ];

				var start = drawcall.start;
				var count = drawcall.count;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices[ i + j ];
						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = edges[ 2 * i + j ];

					coords[ index + 0 ] = vertices.getX( index2 );
					coords[ index + 1 ] = vertices.getY( index2 );
					coords[ index + 2 ] = vertices.getZ( index2 );

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else {

			// non-indexed BufferGeometry

			var vertices = geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.translate( 0, - 0.5, 0 );

	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );

		if ( headLength < length ) {
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
		}

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( headLength < length ){
		this.line.scale.set( 1, length - headLength, 1 );
		this.line.updateMatrix();
	}

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	if ( this.line !== undefined ) this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

	var box = new THREE.Box3();

	return function ( object ) {

		box.setFromObject( object );

		if ( box.empty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.LineSegments.call( this, geometry, material );

	this.camera = camera;
	this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	}

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.rotateX( - Math.PI / 2 );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	geometry.dynamic = true;

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.translate( 0, - 0.5, 0 );
	geometry.rotateX( - Math.PI / 2 );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry instanceof THREE.BufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

	THREE.Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};


// Export the THREE object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

},{}],2:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],3:[function(require,module,exports){
(function (global){
"use strict";

var Bootstrap = require( "./core/Bootstrap" );

global.window.onload = function() {

	// run engine
	var bootstrap = new Bootstrap();
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./core/Bootstrap":18}],4:[function(require,module,exports){
/**
 * @file Prototype for defining script-based actions.
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates an action.
 * 
 * @constructor
 * 
 * @param {function} actionCallback - The action callback.
 * @param {string} label - The label of the action.
 */
function Action( actionCallback, label ) {

	Object.defineProperties( this, {
		label : {
			value : label || "",
			configurable : false,
			enumerable : true,
			writable : false
		},
		isActive : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_actionCallback : {
			value : actionCallback,
			configurable : false,
			enumerable : false,
			writable : false
		},
	} );
}

/**
 * This method executes the assigned callback function.
 */
Action.prototype.run = function() {

	if ( typeof this._actionCallback === "function" )
	{
		this._actionCallback();
	}
	else
	{
		throw "ERROR: Action: Assigned callback not type of 'function'.";
	}
};

module.exports = Action;
},{}],5:[function(require,module,exports){
/**
 * @file Interface for entire action-handling. This prototype is used in stages
 * to access action-based logic and to create action-entities.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );
var Action = require( "./Action" );
var ActionObject = require( "./ActionObject" );
var ActionTrigger = require( "./ActionTrigger" );
var BSPTree = require( "./BSPTree" );
var userInterfaceManager = require( "../ui/UserInterfaceManager" );
var logger = require( "../core/Logger" );
var timing = require( "../core/Timing" );

var self;

/**
 * Creates the action manager.
 * 
 * @constructor
 */
function ActionManager() {

	Object.defineProperties( this, {
		// if you have many objects in your stage, you can use this flag turn on
		// space partitioning with a BSP Tree. right now, raytracing would be
		// executed faster with this. collision detection with a BSP Tree
		// is not yet implemented
		useSpacePartitioning : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this array holds references to all action objects. objects in this
		// array are part of the internal collision detection
		_actionObjects : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this array holds references to action objects that are part of the
		// interaction system. ray-tracing operations will regard only objects
		// in this special array
		_interactiveObjects : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this array holds references to all triggers
		_triggers : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this will be used for ray-tracing operations
		_raycaster : {
			value : new THREE.Raycaster(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a BSP Tree for spatial space partitioning
		_bspTree : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		COLLISIONTYPES : {
			value : {
				AABB : 0,
				OBB : 1
			},
			configurable : false,
			enumerable : false,
			writable : false
		},
		RAYCASTPRECISION : {
			value : {
				AABB : 0,
				OBB : 1,
				FACE : 2
			},
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
	
	// create BSP-Tree
	this._bspTree = new BSPTree( this._actionObjects, this._interactiveObjects );

	// subscriptions
	eventManager.subscribe( TOPIC.ACTION.INTERACTION, this._onInteraction );

	self = this;
}

/**
 * Updates the action manager and all action objects.
 * 
 * @param {Player} player - The player object.
 */
ActionManager.prototype.update = ( function() {

	var position, direction;

	return function( player ) {

		var index;

		if ( position === undefined )
		{
			position = new THREE.Vector3();
			direction = new THREE.Vector3();
		}

		// retrieve data from player entity
		player.getHeadPosition( position );
		player.getDirection( direction );

		// update action objects
		for ( index = 0; index < this._actionObjects.length; index++ )
		{
			this._actionObjects[ index ].update();
		}

		// update triggers
		for ( index = 0; index < this._triggers.length; index++ )
		{
			this._triggers[ index ].update( player.position );
		}

		// check interaction objects
		this._checkInteraction( position, direction );

	};

}() );

/**
 * Generates the internal BSP-Tree with data from the current stage.
 * 
 * @param {World} world - The world object.
 */
ActionManager.prototype.generateBSPTree = function( world ) {

	timing.mark( "BSP_START" );
	
	this._bspTree.generate( world );
	
	timing.mark( "BSP_END" );
	
	timing.measure( "BSP-Tree Generation", "BSP_START", "BSP_END" );
	
	timing.print( "BSP-Tree Generation" );
};

/**
 * Creates a new action object and stores it to the respective internal array. A
 * static object is part of the collision detection. Interactions with the
 * object are initially not possible.
 * 
 * @param {THREE.Mesh} mesh - The mesh object.
 * @param {number} collisionType - The type of collision detection.
 * 
 * @returns {ActionObject} The new action object.
 */
ActionManager.prototype.createActionObject = function( mesh, collisionType ) {

	var object = new ActionObject( mesh, collisionType );
	this._actionObjects.push( object );
	return object;
};

/**
 * Creates a new interactive object and stores it to the respective internal
 * arrays. An interactive object is part of the collision detection and
 * ray-tracing system.
 * 
 * @param {THREE.Mesh} mesh - The mesh object.
 * @param {number} collisionType - The type of collision detection.
 * @param {number} raycastPrecision - The precision of the raycast operation.
 * @param {string} label - The label of the action.
 * @param {function} actionCallback - The action callback.
 * 
 * @returns {ActionObject} The new interactive object.
 */
ActionManager.prototype.createInteractiveObject = function( mesh, collisionType, raycastPrecision, label, actionCallback ) {

	var object = new ActionObject( mesh, collisionType, raycastPrecision, new Action( actionCallback, label ) );

	// the object will be stored in two separate data structures
	this._actionObjects.push( object );
	this._interactiveObjects.push( object );

	return object;
};

/**
 * Creates a new trigger and stores it to the respective internal array.
 * 
 * @param {string} label - The label of the trigger.
 * @param {THREE.Vector3} position - The position of the trigger.
 * @param {number} radius - The radius of the trigger.
 * @param {boolean} isOnetime - Should the trigger run it's action just one
 * time?
 * @param {function} actionCallback - The action callback.
 * 
 * @returns {ActionTrigger} The new action trigger.
 */
ActionManager.prototype.createTrigger = function( label, position, radius, isOnetime, actionCallback ) {

	var trigger = new ActionTrigger( position, radius, isOnetime, new Action( actionCallback, label ) );
	this._triggers.push( trigger );
	return trigger;
};

/**
 * Removes a single action object from the internal array.
 * 
 * @param {ActionObject} actionObject - The action object to be removed.
 */
ActionManager.prototype.removeActionObject = function( actionObject ) {

	var index = this._actionObjects.indexOf( actionObject );
	this._actionObjects.splice( index, 1 );
};

/**
 * Removes a single interactive object from the internal array.
 * 
 * @param {ActionObject} interactiveObject - The interactive object to be
 * removed.
 */
ActionManager.prototype.removeInteraction = function( interactiveObject ) {

	// we need to remove the object from both arrays
	var index = this._interactiveObjects.indexOf( interactiveObject );
	this._interactiveObjects.splice( index, 1 );

	// also remove it from the action object array
	this.removeActionObject( interactiveObject );
};

/**
 * Removes a single trigger from the internal array.
 * 
 * @param {ActionTrigger} trigger - The trigger to be removed.
 */
ActionManager.prototype.removeTrigger = function( trigger ) {

	var index = this._triggers.indexOf( trigger );
	this._triggers.splice( index, 1 );
};

/**
 * Removes all action objects from the internal array.
 */
ActionManager.prototype.removeActionObjects = function() {

	this._actionObjects.length = 0;
	this._interactiveObjects.length = 0;
};

/**
 * Removes all triggers from the internal array.
 */
ActionManager.prototype.removeTriggers = function() {

	this._triggers.length = 0;
};

/**
 * Calculates the closest intersection with an interactive object.
 * 
 * @param {THREE.Vector3} position - The position of the player.
 * @param {THREE.Vector3} direction - The direction the player is looking at.
 */
ActionManager.prototype._calculateClosestIntersection = ( function() {

	var objectsToTest = [];

	return function( position, direction ) {

		var interactiveObject, intersects, index;

		// prepare raycaster
		this._raycaster.set( position, direction );
		this._raycaster.far = 20;

		// if space partitioning is activated, use a BSP Tree to decrease the
		// amount of objects to test
		if ( this.useSpacePartitioning === true )
		{
			// reset the array
			objectsToTest.length = 0;

			// check the BSP Tree
			this._bspTree.intersectRay( this._raycaster.ray, objectsToTest );

			// do the actual intersection test
			intersects = this._raycaster.intersectObjects( objectsToTest );
		}
		else
		{
			// do the intersection test without BSP Tree
			intersects = this._raycaster.intersectObjects( this._interactiveObjects );
		}

		// now check the results
		if ( intersects.length > 0 )
		{
			// the objects are already sorted by distance, so we are starting with the closest
			for ( index = 0; index < intersects.length; index++ )
			{
				interactiveObject = intersects[ index ].object;

				// the action property must always set
				if ( interactiveObject.action !== undefined )
				{
					// return the object if it has an active action. if not,
					// continue with the next object
					if ( interactiveObject.action.isActive === true )
					{
						return interactiveObject;
					}
				}
				else
				{
					throw "ERROR: ActionManager: No action defined for interactive object.";
				}

			}
		}
	};

}() );

/**
 * This method checks if the user interface should indicate, that the player can
 * interact with an object.
 * 
 * @param {THREE.Vector3} position - The position of the player.
 * @param {THREE.Vector3} direction - The direction the player is looking at.
 */
ActionManager.prototype._checkInteraction = function( position, direction ) {

	// calculate the intersection with the closest visible and active
	// interactive object
	var interactiveObject = this._calculateClosestIntersection( position, direction );

	// show the interaction label if there is an intersection
	if ( interactiveObject !== undefined )
	{
		userInterfaceManager.showInteractionLabel( interactiveObject.action.label );
	}
	else
	{
		userInterfaceManager.hideInteractionLabel();
	}

};

/**
 * This method is used to handle the interaction command of the player.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
ActionManager.prototype._onInteraction = function( message, data ) {

	// calculate the intersection with the closest visible and active
	// interactive object
	var interactiveObject = self._calculateClosestIntersection( data.position, data.direction );

	if ( interactiveObject !== undefined )
	{
		// execute the assigned action
		interactiveObject.action.run();

		logger.log( "INFO: ActionManager: Interaction with interactive object. Action executed." );

	}
};

module.exports = new ActionManager();
},{"../core/Logger":21,"../core/Timing":30,"../messaging/EventManager":69,"../messaging/Topic":71,"../ui/UserInterfaceManager":118,"./Action":4,"./ActionObject":6,"./ActionTrigger":7,"./BSPTree":8,"three":1}],6:[function(require,module,exports){
/**
 * @file This prototype enables ordinary 3D-Objects to be interactive. Any
 * action object is part of the collision-detection logic and ready for
 * interacting with the player.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );
var OBB = require( "../etc/OBB" );

/**
 * Creates an action object.
 * 
 * @constructor
 * 
 * @param {THREE.Mesh} mesh - The mesh object.
 * @param {number} collisionType - The type of collision detection.
 * @param {number} raycastPrecision - The precision of the raycast operation.
 * @param {Action} action - The action, that should be executed.
 */
function ActionObject( mesh, collisionType, raycastPrecision, action ) {

	Object.defineProperties( this, {
		mesh : {
			value : mesh,
			configurable : false,
			enumerable : true,
			writable : true
		},
		collisionType : {
			value : collisionType,
			configurable : false,
			enumerable : true,
			writable : true
		},
		raycastPrecision : {
			value : raycastPrecision,
			configurable : false,
			enumerable : true,
			writable : true
		},
		action : {
			value : action,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// if the action object never changes its position or orientation, you
		// can set this value to false to prevent the update of bounding volumes
		autoUpdate : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// bounding volumes
		boundingSphere : {
			value : new THREE.Sphere(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		aabb : {
			value : new THREE.Box3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		obb : {
			value : new OBB(),
			configurable : false,
			enumerable : true,
			writable : true
		}

	} );

	// compute default bounding volumes
	this.mesh.geometry.computeBoundingBox();
	this.mesh.geometry.computeBoundingSphere();
	
	// update the action object at least once
	this.update();
}

/**
 * This method will update the bounding volumes of the action object.
 */
ActionObject.prototype.update = function() {

	if ( this.autoUpdate === true )
	{
		// update bounding sphere
		this.boundingSphere.copy( this.mesh.geometry.boundingSphere );
		this.boundingSphere.applyMatrix4( this.mesh.matrixWorld );

		// update other bounding volumes if necessary
		if ( this.collisionType === ActionObject.COLLISIONTYPES.AABB || this.raycastPrecision === ActionObject.RAYCASTPRECISION.AABB )
		{
			this.aabb.copy( this.mesh.geometry.boundingBox );
			this.aabb.applyMatrix4( this.mesh.matrixWorld );
		}

		if ( this.collisionType === ActionObject.COLLISIONTYPES.OBB || this.raycastPrecision === ActionObject.RAYCASTPRECISION.OBB )
		{
			this.obb.setFromObject( this.mesh );
		}

	}
};

/**
 * This method detects an intersection between the raycaster and the relevant
 * object. According to raycast precision, different algorithm are used to
 * detect an intersection.
 * 
 * @param {THREE.Raycaster} raycaster - A raycaster instance.
 * @param {object} intersects - An array with intersection points.
 */
ActionObject.prototype.raycast = function( raycaster, intersects ) {

	var intersectsRay = [], intersectionPoint, index, distance;

	// check raycast precision
	switch ( this.raycastPrecision )
	{

		case ActionObject.RAYCASTPRECISION.AABB:
		{
			intersectionPoint = raycaster.ray.intersectBox( this.aabb );

			break;
		}

		case ActionObject.RAYCASTPRECISION.OBB:
		{
			intersectionPoint = this.obb.intersectRay( raycaster.ray );

			break;
		}

		case ActionObject.RAYCASTPRECISION.FACE:
		{
			// call default raycast method of the mesh object
			this.mesh.raycast( raycaster, intersectsRay );

			for ( index = 0; index < intersectsRay.length; index++ )
			{
				// set the action object as result object
				intersectsRay[ index ].object = this;

				// push to result array
				intersects.push( intersectsRay[ index ] );
			}
			
			// reset array for next call
			intersectsRay.length = 0;

			break;
		}

		default:
		{
			throw "ERROR: ActionObject: No valid raycast precision applied to object.";
		}

	}

	// if a single intersectionPoint is found, we need to calculate
	// additional data and push the point into the intersects array
	if ( intersectionPoint !== undefined && intersectionPoint !== null )
	{
		// get the distance to the intersection point
		distance = raycaster.ray.origin.distanceTo( intersectionPoint );

		if ( distance >= raycaster.near && distance <= raycaster.far )
		{
			// store the result in special data structure, see
			// THREE.Mesh.raycast
			intersects.push( {
				distance : distance,
				point : intersectionPoint,
				face : null,
				faceIndex : null,
				object : this
			} );
		}
	}
};

/**
 * This method detects an intersection between the given bounding box and the
 * bounding volume of the action object.
 * 
 * @param {THREE.Box3} boundingBox - The boundingBox of the controls.
 * 
 * @returns {boolean} Intersects the object with the given bounding box?
 */
ActionObject.prototype.isIntersection = function( boundingBox ) {

	var isIntersection = false;

	// check type of collision test
	switch ( this.collisionType )
	{

		case ActionObject.COLLISIONTYPES.AABB:
		{
			isIntersection = this.aabb.isIntersectionBox( boundingBox );

			break;
		}

		case ActionObject.COLLISIONTYPES.OBB:
		{
			isIntersection = this.obb.isIntersectionAABB( boundingBox );

			break;
		}

		default:
		{
			throw "ERROR: ActionObject: No valid collision type applied to object.";
		}
	}

	return isIntersection;

};

ActionObject.COLLISIONTYPES = {
	AABB : 0,
	OBB : 1
};

ActionObject.RAYCASTPRECISION = {
	AABB : 0,
	OBB : 1,
	FACE : 2
};

module.exports = ActionObject;
},{"../etc/OBB":36,"three":1}],7:[function(require,module,exports){
/**
 * @file The ActionTrigger is a static trigger for actions.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var logger = require( "../core/Logger" );
var system = require( "../core/System" );

/**
 * The constructor creates an internal mesh, which represents the trigger in
 * 3D-space. A player activates a trigger by entering in the corresponding
 * circle geometry.
 * 
 * @constructor
 * 
 * @param {THREE.Vector3} position - The position of the trigger.
 * @param {number} radius - The radius of the trigger.
 * @param {boolean} isOnetime - Should the trigger run it's action just one time?
 * @param {Action} action - The action, that should be executed.
 */
function ActionTrigger( position, radius, isOnetime, action ) {

	Object.defineProperties( this, {
		boundingSphere : {
			value : new THREE.Sphere( position, radius ),
			configurable : false,
			enumerable : true,
			writable : false
		},
		action : {
			value : action,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates, if the entity is inside the trigger
		isEntityInside : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates, if the trigger is executed just one time
		isOnetime: {
			value : isOnetime|| false,
			configurable : false,
			enumerable : true,
			writable : true
		},
	} );
	
	// in dev mode provide a mesh to visualize the trigger
	if( system.isDevModeActive === true ){
		
		var geometry = new THREE.SphereBufferGeometry( radius, 10, 10 );
		var material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );
		
		this.object3D = new THREE.Mesh( geometry, material);
		this.object3D.position.copy( position );
	}
}

/**
 * The update method checks if the trigger should execute it's action.
 * 
 * @param {THREE.Vector3} position - The position of the game entity.
 */
ActionTrigger.prototype.update = ( function() {

	var closestPoint;

	return function( position ) {

		if ( closestPoint === undefined )
		{
			closestPoint = new THREE.Vector3();
		}

		// the action property must always be set
		if ( this.action !== undefined )
		{
			// only process if the action is active
			if ( this.action.isActive === true )
			{
				// only process if the given position is inside the trigger
				if ( this.boundingSphere.containsPoint( position ) )
				{
					// if the position is not already inside the trigger,
					// run the corresponding action
					if ( this.isEntityInside === false )
					{
						// run the action
						this.action.run();

						// the entity is now inside the trigger
						this.isEntityInside = true;

						// if the "isOnetime" flag is set, deactivate the
						// trigger action
						if ( this.isOnetime === true )
						{
							this.action.isActive = false;
						}

						logger.log( "INFO: ActionTrigger: Interaction with trigger. Action executed." );
					}
				}
				else
				{
					// the position is not inside the trigger, so it's
					// ready to run it's action again
					this.isEntityInside = false;
				}
			}
		}
		else
		{
			throw "ERROR: ActionTrigger: No action defined for trigger.";
		}

	};

}() );

/**
 * Returns the position of the trigger.
 * 
 * @returns {THREE.Vector3} The position of the trigger.
 */
ActionTrigger.prototype.getPosition = function(){
	
	return this.boundingSphere.center;
};

/**
 * Sets the position of the trigger. 
 * 
 * @param {THREE.Vector3} position - The position to set.
 */
ActionTrigger.prototype.setPosition = function( position ){
	
	this.boundingSphere.center.copy( position );
};

/**
 * Returns the radius of the trigger. 
 * 
 * @returns {number} The radius of the trigger.
 */
ActionTrigger.prototype.getRadius = function(){
	
	return this.boundingSphere.radius;
};

/**
 * Sets the radius of the trigger. 
 * 
 * @param {number} radius - The radius to set.
 */
ActionTrigger.prototype.setRadius = function( radius ){
	
	this.boundingSphere.radius.copy( radius );
};

module.exports = ActionTrigger;
},{"../core/Logger":21,"../core/System":27,"three":1}],8:[function(require,module,exports){
/**
 * @file This prototpye can be used to generate an axis-aligned BSP Tree for
 * fast ray-tracing or collision detection.
 * 
 * see: Real-Time Rendering, Third Edition, Akenine-Möller/Haines/Hoffman
 * Chapter 14.1.2, BSP Trees
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var system = require( "../core/System" );

/**
 * Creates an axis-aligned BSP Tree.
 * 
 * @constructor
 * 
 * @param {object} actionObjects - A reference to an array with all
 * action objects.
 * @param {object} interactiveObjects - A reference to an array with all
 * interactive objects.
 */
function BSPTree( actionObjects, interactiveObjects ) {

	Object.defineProperties( this, {
		_root : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_actionObjects : {
			value : actionObjects,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_interactiveObjects : {
			value : interactiveObjects,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_currentAxis : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_AXIS_COUNT : {
			value : 3,
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
}

/**
 * This method controls the generation of the BSP Tree.
 * 
 * @param {World} world - The world object.
 */
BSPTree.prototype.generate = function( world ) {
	
	var nextNode;
	
	// create a stack (LIFO), in JavaScript done via a plain array
	var stack = [];

	// first, create the root node of the BSP-Tree
	this._buildRootNode();
	
	// push it onto the stack
	stack.push( this._root );
	
	// while there are nodes in the stack keep subdividing
	while ( stack.length > 0 )
	{
		// grab the next node and remove it from the stack
		nextNode = stack.pop();
		
		// subdivide the node 
		this._subdivide( nextNode );

		// then, check if the subdivision has created children
		if( nextNode.hasChildren() === true ){
			
			// if so, push them onto the stack
			stack.push( nextNode.leftChild );
			stack.push( nextNode.rightChild );
		}
		
		// if the engine runs in dev mode, visualize the AABB of each node
		if( system.isDevModeActive === true ){
			
			this._addHelper( nextNode, world );
		}
		
	}  // next node
};

/**
 * Executes a recursive, simple Ray/AABB intersection test to determine objects
 * for the exact ray intersection test by the action manager.
 * 
 * @param {THREE.Ray} ray - The ray for the test.
 * @param {object} intersects - An array with action objects for further testing.
 */
BSPTree.prototype.intersectRay = ( function() {
	
	var stack = [];
	
	return function( ray, intersects ){
				
		var nextNode, index;
		
		// reset stack
		stack.length = 0;
		
		// push the root node onto the stack
		stack.push( this._root );

		// while there are nodes in the stack keep testing
		while ( stack.length > 0 )
		{
			// grab the next node and remove it from the stack
			nextNode = stack.pop();

			// execute intersection test
			if ( ray.isIntersectionBox( nextNode.aabb ) === true )
			{
				// push all entities to the result array
				for ( index = 0; index < nextNode.entities.length; index++ )
				{
					intersects.push( nextNode.entities[ index ].object );
				}

				// if the node has children, push them onto the stack
				if ( nextNode.hasChildren() === true )
				{
					stack.push( nextNode.leftChild );
					stack.push( nextNode.rightChild );
				}
			}

		} // next node

		return intersects;
	};

}() );

/**
 * Builds the root node of the BSP Tree. The root node encloses all relevant 3D
 * objects in the stage.
 */
BSPTree.prototype._buildRootNode = function() {

	var entity, entities, i, j;

	// create the root node
	this._root = new Node();

	// retrieve all 3D entities
	entities = this._retrieveEntities();

	// we iterate over all entities to calculate the root element's AABB
	for ( i = 0; i < entities.length; i++ )
	{
		entity = entities[ i ];

		// we need to process each vertex of the entities
		for ( j = 0; j < entity.verticesWorldSpace.length; j++ )
		{
			// this method call ensures that the AABB encloses all vertices of
			// the given entities
			this._root.aabb.expandByPoint( entity.verticesWorldSpace[ j ] );

		} // next vertex

		// we assign all entities to the root element
		this._root.entities.push( entity );

	} // next entity

};

/**
 * This method is used to get all relevant 3D entities of the stage. Besides, it
 * provides vertex data of the geometry in world space. This is necessary for
 * AABB calculations.
 */
BSPTree.prototype._retrieveEntities = function() {

	var entities = [], interactiveObject, verticesModelSpace, verticesWorldSpace, vertex, i, j;

	for ( i = 0; i < this._interactiveObjects.length; i++ )
	{
		// retrieve object
		interactiveObject = this._interactiveObjects[ i ];

		// ensure model matrix is up to date
		interactiveObject.mesh.updateMatrix();
		interactiveObject.mesh.updateMatrixWorld();

		verticesWorldSpace = [];
		verticesModelSpace = interactiveObject.mesh.geometry.vertices;

		// iterate over all vertices and transform them to world space
		for ( j = 0; j < verticesModelSpace.length; j++ )
		{
			vertex = verticesModelSpace[ j ].clone();

			verticesWorldSpace.push( vertex.applyMatrix4( interactiveObject.mesh.matrixWorld ) );

		} // next vertex

		// save the data in the internal entity array
		entities.push( {
			object : interactiveObject,
			verticesWorldSpace : verticesWorldSpace,
			processed : false
		} );

	} // next object

	return entities;

};

/**
 * This will create new nodes from a given node. In this BSP implementation the
 * algorithm will split the node in the center of a particular axis. If this
 * process does not provide good results, the splitting is repeated with the
 * other two axis. If no axis provides a result, no child node will be created
 * and the entities will remain in the current node
 * 
 * @param {Node} node - The node to subdivide.
 */
BSPTree.prototype._subdivide = function( node ) {

	// we only create sub-nodes if there is more than one entity
	if ( node.entities.length > 1 )
	{
		node.splitStep++;

		// create the child nodes
		this._createChildNodes( node );

		// try to distribute all entities to the child nodes
		this._distributeEntities( node );

		// check the results of the splitting
		if ( node.hasValidChildren() === false )
		{
			// if there is no valid result, try the splitting again with an
			// other axis. we can do this two times, because we have overall
			// three axis
			if ( node.splitStep < this._AXIS_COUNT )
			{
				this._subdivide( node );
			}

			// if no splitting axis works, keep the 3D entities on the current node
			// and delete the sub-nodes
			else
			{
				node.leftChild = null;
				node.rightChild = null;
			}
		}
		else
		{
			node.removeInvalidEntities();
		}
	}

	// this property is no longer required, so it's deleted here to free memory
	delete node.splitStep;
};

/**
 * Creates child nodes for a given node. The method divides the AABB of the
 * given node into two even AABBs for the child nodes.
 * 
 * @param {Node} node - The parent node.
 */
BSPTree.prototype._createChildNodes = function( node ) {

	var minValue, maxValue, midpoint;

	// create new nodes
	node.leftChild = new Node();
	node.rightChild = new Node();

	// copy the parent's AABB to the new childs
	node.leftChild.aabb.copy( node.aabb );
	node.rightChild.aabb.copy( node.aabb );

	// get minimum and maximum value of the splitting axis
	minValue = node.aabb.min.getComponent( this._currentAxis );
	maxValue = node.aabb.max.getComponent( this._currentAxis );

	// calculate midpoint of the splitting axis. this is the position, where the
	// AABB is divided into two new AABBs
	midpoint = ( maxValue - minValue ) * 0.5;

	// now adjust the new AABBs so they have exactly the half size of the parent
	node.leftChild.aabb.max.setComponent( this._currentAxis, minValue + midpoint );
	node.rightChild.aabb.min.setComponent( this._currentAxis, maxValue - midpoint );

	// ensure we split the next AABB towards an other axis
	this._nextAxis();
};

/**
 * This method tries to distribute the entities of a given node to its children.
 * An entity will only assign to a child node, if it's fully contained of the
 * corresponding AABB.
 * 
 * @param {Node} node - The parent node.
 */
BSPTree.prototype._distributeEntities = function( node ) {

	var index, entity;

	// iterate over all entities to distribute them to child nodes
	for ( index = 0; index < node.entities.length; index++ )
	{
		entity = node.entities[ index ];

		// test to see if the entity can sorted to the left child. that will
		// only be the case IF all vertices are bounded by the node
		if ( node.leftChild.containsEntity( entity ) === true )
		{
			node.leftChild.addEntity( entity );
		}

		// test to see if the entity can sorted to the right child. that will
		// only be the case IF all vertices are bounded by the node
		if ( node.rightChild.containsEntity( entity ) === true )
		{
			node.rightChild.addEntity( entity );
		}

	} // next object

};

/**
 * Sets the "currentAxis" property to the next axis.
 */
BSPTree.prototype._nextAxis = function() {

	if ( ++this._currentAxis > ( this._AXIS_COUNT - 1 ) )
	{
		this._currentAxis = 0;
	}
};

/**
 * Adds a helper to the 3D world to visualize the AABB of a node.
 * 
 * @param {Node} node - The node that gets the helper.
 * @param {World} world - The world object.
 */
BSPTree.prototype._addHelper = ( function() {

	var geometry, material;

	return function( node, world ) {

		var helper;

		if ( geometry === undefined )
		{
			geometry = new THREE.BoxGeometry( 1, 1, 1 );
			material = new THREE.MeshBasicMaterial( {
				color : 0xffffff,
				wireframe : true
			} );
		}

		// create the mesh
		helper = new THREE.Mesh( geometry, material );

		// retrieve position and scaling from the bounding box
		node.aabb.size( helper.scale );
		node.aabb.center( helper.position );

		// add it to the world
		world.addObject3D( helper );
	};

}() );

module.exports = BSPTree;

/**
 * Creates a node for a BSP Tree.
 * 
 * @constructor
 */
function Node() {

	Object.defineProperties( this, {
		aabb : {
			value : new THREE.Box3(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		entities : {
			value : [],
			configurable : false,
			enumerable : true,
			writable : false
		},
		leftChild : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		rightChild : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		splitStep : {
			value : 0,
			configurable : true,
			enumerable : true,
			writable : true
		}
	} );

}

/**
 * Checks, if the node has valid children. This depends primarily on the
 * distribution of 3D entities between parent and children.
 */
Node.prototype.hasValidChildren = function() {

	var max = this.entities.length, min = 0;

	if ( ( this.leftChild.entities.length < max && this.rightChild.entities.length < max ) && ( this.leftChild.entities.length > min && this.rightChild.entities.length > min ) )
	{
		return true;
	}

	return false;
};

/**
 * Checks, if the node children.
 */
Node.prototype.hasChildren = function() {

	if ( this.rightChild !== null && this.leftChild !== null )
	{
		return true;
	}

	return false;
};

/**
 * Adds an entity to the internal array.
 * 
 * @param {object} entity - The entity to add.
 */
Node.prototype.addEntity = function( entity ) {

	this.entities.push( entity );
};

/**
 * Removes an entity of the internal array.
 * 
 * @param {object} entity - The entity to remove.
 */
Node.prototype.removeEntity = function( entity ) {

	var index = this.entities.indexOf( entity );
	this.entities.splice( index, 1 );
};

/**
 * Checks, if the node contains a given entity.
 * 
 * @param {object} entity - The entity to check.
 */
Node.prototype.containsEntity = function( entity ) {

	var index, vertex;

	// we need to check if all vertices in world space are inside the
	// corresponding AABB
	for ( index = 0; index < entity.verticesWorldSpace.length; index++ )
	{
		vertex = entity.verticesWorldSpace[ index ];

		if ( this.aabb.containsPoint( vertex ) === false )
		{
			return false;
		}

	} // next vertex

	return true;
};

/**
 * Removes invalid entities from the internal array.
 */
Node.prototype.removeInvalidEntities = function() {

	var index;

	// if entities were transfered to child nodes, they will be removed from the
	// parent's internal array
	for ( index = 0; index < this.leftChild.entities.length; index++ )
	{
		this.removeEntity( this.leftChild.entities[ index ] );
	}

	for ( index = 0; index < this.rightChild.entities.length; index++ )
	{
		this.removeEntity( this.rightChild.entities[ index ] );
	}

};
},{"../core/System":27,"three":1}],9:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for defining an animation for a single property.
 * 
 * @author Human Interactive
 */

"use strict";

var logger = require( "../core/Logger" );

/**
 * Creates an animation.
 * 
 * @constructor
 * 
 * @param {object} options - The parameter for the animation.
 */
function Animation( options ) {

	Object.defineProperties( this, {
		
		// the animation only works with object properties
		object : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the animated property
		property : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the duration of the animation
		duration : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the start value of the animation
		start : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the end value of the animation
		end : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this will delay the animation by the given time
		delayTime : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// if set to true, it specifies that the animation will start over
		// again, every time it is finished. the start and end values will be
		// switched to create a seamless "yoyo" animation
		loop : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the easing function
		easing : {
			value : undefined,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// executed when the animation is started ( the play method is called ).
		// in looped animations, it is called just once
		onStartCallback : {
			value : undefined,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// executed when the animation is updated
		onUpdateCallback : {
			value : undefined,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// executed when the animation is completed
		onCompleteCallback : {
			value : undefined,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// executed when the animation is stopped
		onStopCallback : {
			value : undefined,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates if the animation is active
		isPlaying : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// internal timestamp value
		_startTime : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// set options
	for ( var property in options )
	{
		if ( this.hasOwnProperty( property ) === true )
		{
			this[ property ] = options[ property ];
		}
		else
		{
			logger.warn( "WARN: Animation: Object created with wrong options. Property '%s' is not a member of Animation.", property );
		}
	}
}

/**
 * Updates the animation.
 * 
 * @param {number} time - The update time.
 * 
 * @returns {boolean} Is the animation finished?
 */
Animation.prototype.update = function( time ) {

	var index, elapsed, value, temp;
	var isFinished = false;

	// if the startTime is greater than the current time,
	// we will skip the update. this is important for delayed
	// start time.
	if ( time < this._startTime )
	{
		return isFinished;
	}

	// calculate elapsed time. the final value of "elapsed"
	// will always be inside the range of [0, 1].
	elapsed = ( time - this._startTime ) / this.duration;
	elapsed = elapsed > 1 ? 1 : elapsed;

	// execute easing function
	if ( typeof this.easing === "function" )
	{
		value = this.easing( elapsed );
	}
	else
	{
		throw "ERROR: Animation: No easing function assigned.";
	}

	// check, if the object has the specified property
	if ( this.object.hasOwnProperty( this.property ) === true )
	{
		// calculate and assign new value
		this.object[ this.property ] = this.start + ( this.end - this.start ) * value;
	}

	// execute callback
	if ( typeof this.onUpdateCallback === "function" )
	{
		this.onUpdateCallback();
	}

	// check finish
	if ( elapsed === 1 )
	{
		// check if the animation should be played in an endless loop
		if ( this.loop === true )
		{
			// switch start and end values
			temp = this.start;
			this.start = this.end;
			this.end = temp;

			// set new start time
			this._startTime = time + this.delayTime;
		}
		else
		{
			// execute callback
			if ( typeof this.onCompleteCallback === "function" )
			{
				this.onCompleteCallback();
			}

			isFinished = true;
		}
	}

	return isFinished;

};

/**
 * Plays the animation.
 * 
 * @param {number} time - The starting time.
 */
Animation.prototype.play = function( time ) {

	this.isPlaying = true;

	this._startTime = time !== undefined ? time : global.performance.now();
	this._startTime += this.delayTime;

	// execute callback
	if ( typeof this.onStartCallback === "function" )
	{
		this.onStartCallback();
	}
};

/**
 * Stops the animation.
 */
Animation.prototype.stop = function() {

	if ( this.isPlaying === true )
	{
		this.isPlaying = false;
	}

	// execute callback
	if ( typeof this.onStopCallback === "function" )
	{
		this.onStopCallback();
	}
};

module.exports = Animation;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/Logger":21}],10:[function(require,module,exports){
(function (global){
/**
 * @file Interface for entire animation-handling. This prototype is used in
 * stages to access animation-based logic and to create animation-entities.
 * 
 * @author Human Interactive
 */
"use strict";

var Animation = require( "../animation/Animation" );
var SpriteAnimation = require( "../animation/SpriteAnimation" );

/**
 * Creates the animation manager.
 * 
 * @constructor
 */
function AnimationManager() {

	Object.defineProperties( this, {
		_animations : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		_sprites : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
}

/**
 * Creates an animation, which animates a single property of an object.
 * 
 * @param {object} options - The options for the animation.
 * 
 * @returns {Animation} The new animation.
 */
AnimationManager.prototype.createBasicAnimation = function( options ) {

	var animation = new Animation( options );
	this.addAnimation( animation );
	return animation;
};

/**
 * Creates a sprite animation.
 * 
 * @param {number} rows - Number of images in y-direction.
 * @param {number} columns - Number of images in x-direction.
 * @param {number} numberOfImages - Total number of images in the sprite.
 * @param {THREE.Texture} texture - Contains the sprite image. The dimension of
 * the texture should be a power of two, but it's not necessary.
 * @param {number} imagesPerSecond - How many images should be displayed per
 * second.
 * 
 * @returns {SpriteAnimation} The new sprite animation.
 */
AnimationManager.prototype.createSpriteAnimation = function( rows, columns, numberOfImages, texture, imagesPerSecond ) {

	var sprite = new SpriteAnimation( rows, columns, numberOfImages, texture, imagesPerSecond );
	this.addSpriteAnimation( sprite );

	return sprite;
};

/**
 * Update method for animations. Called in render-loop.
 * 
 * @param {number} delta - The time delta value.
 */
AnimationManager.prototype.update = function( delta ) {

	this._updateAnimations();

	this._updateSprites( delta );
};

/**
 * Updates the standard animations.
 */
AnimationManager.prototype._updateAnimations = function() {

	var animation, index, time;

	// use the same time value for all animations
	time = global.performance.now();

	// iterate over all animations
	for ( index = 0; index < this._animations.length; index++ )
	{
		// buffer current animation
		animation = this._animations[ index ];

		// only update the animation if it actually runs
		if ( animation.isPlaying === true )
		{
			// update the animation and check status
			if ( animation.update( time ) === true )
			{
				// remove automatically the animation after ending
				this.removeAnimation( animation );
			}
		}
	}
};

/**
 * Updates the sprite objects.
 * 
 * @param {number} delta - The time delta value.
 */
AnimationManager.prototype._updateSprites = function( delta ) {

	for ( var index = 0; index < this._sprites.length; index++ )
	{
		this._sprites[ index ].update( delta );
	}

};

/**
 * Adds a single animation object to the internal array.
 * 
 * @param {Animation} animation - The animation object to be added.
 */
AnimationManager.prototype.addAnimation = function( animation ) {

	this._animations.push( animation );
};

/**
 * Adds a single sprite object to the internal array.
 * 
 * @param {SpriteAnimation} sprite - The sprite object to be added.
 */
AnimationManager.prototype.addSpriteAnimation = function( sprite ) {

	this._sprites.push( sprite );
};

/**
 * Removes a single animation object from the internal array.
 * 
 * @param {Animation} animation - The animation object to be removed.
 */
AnimationManager.prototype.removeAnimation = function( animation ) {

	var index = this._animations.indexOf( animation );
	this._animations.splice( index, 1 );
};

/**
 * Removes a single sprite object from the internal array.
 * 
 * @param {SpriteAnimation} sprite - The sprite object to be removed.
 */
AnimationManager.prototype.removeAnimation = function( sprite ) {

	var index = this._sprites.indexOf( sprite );
	this._sprites.splice( index, 1 );
};

/**
 * Removes all animations from the internal array.
 */
AnimationManager.prototype.removeAnimations = function() {

	this._animations.length = 0;
};

/**
 * Removes all sprites from the internal array.
 */
AnimationManager.prototype.removeSprites = function() {

	this._sprites.length = 0;
};

module.exports = new AnimationManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../animation/Animation":9,"../animation/SpriteAnimation":12}],11:[function(require,module,exports){
/**
 * @file This file contains easing functions for animations.
 * 
 * see https://github.com/tweenjs/tween.js/blob/master/src/Tween.js
 * 
 * @author Human Interactive
 */

"use strict";

var Easing = {

	Linear : {

		None : function( k ) {

			return k;

		}

	},

	Quadratic : {

		In : function( k ) {

			return k * k;

		},

		Out : function( k ) {

			return k * ( 2 - k );

		},

		InOut : function( k ) {

			if ( ( k *= 2 ) < 1 )
			{
				return 0.5 * k * k;
			}
			return -0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic : {

		In : function( k ) {

			return k * k * k;

		},

		Out : function( k ) {

			return --k * k * k + 1;

		},

		InOut : function( k ) {

			if ( ( k *= 2 ) < 1 )
			{
				return 0.5 * k * k * k;
			}
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic : {

		In : function( k ) {

			return k * k * k * k;

		},

		Out : function( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut : function( k ) {

			if ( ( k *= 2 ) < 1 )
			{
				return 0.5 * k * k * k * k;
			}
			return -0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic : {

		In : function( k ) {

			return k * k * k * k * k;

		},

		Out : function( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut : function( k ) {

			if ( ( k *= 2 ) < 1 )
			{
				return 0.5 * k * k * k * k * k;
			}
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal : {

		In : function( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out : function( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut : function( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential : {

		In : function( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out : function( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, -10 * k );

		},

		InOut : function( k ) {

			if ( k === 0 )
			{
				return 0;
			}
			if ( k === 1 )
			{
				return 1;
			}
			if ( ( k *= 2 ) < 1 )
			{
				return 0.5 * Math.pow( 1024, k - 1 );
			}
			return 0.5 * ( -Math.pow( 2, -10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular : {

		In : function( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out : function( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut : function( k ) {

			if ( ( k *= 2 ) < 1 )
			{
				return -0.5 * ( Math.sqrt( 1 - k * k ) - 1 );
			}
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2 ) * k ) + 1 );

		}

	},

	Elastic : {

		In : function( k ) {

			var s, a = 0.1, p = 0.4;

			if ( k === 0 )
			{
				return 0;
			}
			if ( k === 1 )
			{
				return 1;
			}
			if ( !a || a < 1 )
			{
				a = 1;
				s = p / 4;
			}
			else
			{
				s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			}
			return -( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out : function( k ) {

			var s, a = 0.1, p = 0.4;

			if ( k === 0 )
			{
				return 0;
			}
			if ( k === 1 )
			{
				return 1;
			}
			if ( !a || a < 1 )
			{
				a = 1;
				s = p / 4;
			}
			else
			{
				s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			}
			return ( a * Math.pow( 2, -10 * k ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut : function( k ) {

			var s, a = 0.1, p = 0.4;

			if ( k === 0 )
			{
				return 0;
			}
			if ( k === 1 )
			{
				return 1;
			}
			if ( !a || a < 1 )
			{
				a = 1;
				s = p / 4;
			}
			else
			{
				s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			}

			if ( ( k *= 2 ) < 1 )
			{
				return -0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			}
			else
			{
				return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;
			}

		}

	},

	Back : {

		In : function( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out : function( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut : function( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 )
			{
				return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			}
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce : {

		In : function( k ) {

			return 1 - Easing.Bounce.Out( 1 - k );

		},

		Out : function( k ) {

			if ( k < ( 1 / 2.75 ) )
			{

				return 7.5625 * k * k;

			}
			else if ( k < ( 2 / 2.75 ) )
			{

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			}
			else if ( k < ( 2.5 / 2.75 ) )
			{

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			}
			else
			{

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut : function( k ) {

			if ( k < 0.5 )
			{
				return Easing.Bounce.In( k * 2 ) * 0.5;
			}
			return Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}
};

module.exports = Easing;
},{}],12:[function(require,module,exports){
/**
 * @file Prototype for defining an animation based on sprites.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates a sprite animation.
 * 
 * @constructor
 * 
 * @param {number} rows - Number of images in y-direction.
 * @param {number} columns - Number of images in x-direction.
 * @param {number} numberOfImages - Total number of images in the sprite.
 * @param {THREE.Texture} texture - Contains the sprite image. The dimension of
 * the texture should be a power of two, but it's not necessary.
 * @param {number} imagesPerSecond - How many images should be displayed per
 * second.
 */
function SpriteAnimation( rows, columns, numberOfImages, texture, imagesPerSecond ) {

	Object.defineProperties( this, {
		rows : {
			value : rows,
			configurable : false,
			enumerable : true,
			writable : false
		},
		columns : {
			value : columns,
			configurable : false,
			enumerable : true,
			writable : false
		},
		numberOfImages : {
			value : numberOfImages,
			configurable : false,
			enumerable : true,
			writable : false
		},
		texture : {
			value : texture,
			configurable : false,
			enumerable : true,
			writable : false
		},
		imagesPerSecond : {
			value : imagesPerSecond,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_currentImage : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_elapsedTime : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// this will zoom into the texture, so you see exactly one image of the
	// sprite
	this.texture.repeat.set( 1 / this.columns, 1 / this.rows );
}

/**
 * Updates the sprite animation.
 * 
 * @param {number} delta - The update time.
 */
SpriteAnimation.prototype.update = function( delta ) {

	var currentColumn, currentRow;

	// calculate the elapsed time
	this._elapsedTime += delta * this.imagesPerSecond;

	// derive the index of the current image
	this._currentImage = Math.floor( this._elapsedTime );

	// if the index is greater than the total number of images,
	// reset the the counter to zero.
	if ( this._currentImage >= this.numberOfImages )
	{
		this._currentImage = 0;
		this._elapsedTime = 0;
	}

	// calculate the index of the current column
	currentColumn = this._currentImage % this.columns;

	// calculate texture offset in x-direction
	this.texture.offset.x = currentColumn / this.columns;

	// calculate the index of the current row
	currentRow = Math.floor( this._currentImage / this.columns );

	// calculate texture offset in y-direction.
	// because the first picture in sprites is usually in the upper left,
	// you need to start from 1 instead from zero.
	this.texture.offset.y = 1 - ( currentRow / this.rows + 1 / this.rows );

};

module.exports = SpriteAnimation;
},{"three":1}],13:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for loading and decoding audio-files. The resulting buffers
 * are the basis for dynamic audio objects.
 * 
 * @author Human Interactive
 */
"use strict";

var system = require( "../core/System" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

/**
 * Creates an audiobuffer-list.
 * 
 * @constructor
 * 
 * @param {object} context - The central Web Audio context.
 * @param {object} audioList - An array with name of audiofiles.
 * @param {function} onLoadCallback - This callback is executed when all
 * audiofiles are loaded.
 */
function AudioBufferList( context, audioList, onLoadCallback ) {

	Object.defineProperties( this, {
		context : {
			value : context,
			configurable : false,
			enumerable : true,
			writable : false
		},
		audioList : {
			value : audioList,
			configurable : false,
			enumerable : true,
			writable : false
		},
		bufferList : {
			value : [],
			configurable : false,
			enumerable : true,
			writable : true
		},
		_onload : {
			value : onLoadCallback,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_loadCount : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
}

/**
 * This method iterates over the audio-array and loads each entry via a separate
 * method.
 */
AudioBufferList.prototype.load = function() {

	for ( var i = 0; i < this.audioList.length; i++ )
	{
		this.loadBuffer( this.audioList[ i ], i );
	}
};

/**
 * This method loads a single audio-file and decodes it to a buffer object. When
 * all audiofiles form the corresponding array are loaded, a custom callback
 * function will be executed.
 * 
 * @param {string} file - The name of the audio file.
 * @param {number} index - The array-index of the audio file.
 */
AudioBufferList.prototype.loadBuffer = function( file, index ) {

	var self = this;

	// build url
	var url = system.cdn + "/assets/audio/dynamic/" + file + ".mp3";

	// add nocache, if necessary
	if ( system.isDevModeActive === true )
	{
		url = url + "?" + new Date().getTime();
	}

	// create XMLHttpRequest object
	var xhr = new global.XMLHttpRequest();

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === xhr.DONE )
		{
			if ( xhr.status === 200 )
			{
				// decode audio data
				self.context.decodeAudioData( xhr.response, function( buffer ) {

					if ( !buffer )
					{
						throw "ERROR: AudioBufferList: Unable to decode audio file: " + url;
					}
					// add buffer to bufferlist
					self.bufferList[ index ] = buffer;

					// publish message to inform about status
					eventManager.publish( TOPIC.STAGE.LOADING.COMPLETE.AUDIO, {
						url : url
					} );

					// increase internal counter and compare to length of
					// the audio list
					if ( ++self._loadCount === self.audioList.length )
					{
						self._onload( self.bufferList );
					}
				}, function() {

					throw "ERROR: AudioBufferList: Unable to decode audio file " + url;
				} );

			}
			else
			{
				throw "ERROR: AudioBufferList: Could not load '" + url + "' (Status: " + xhr.status + ").";
			}
		}
	};

	// send request
	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";
	xhr.withCredentials = true;
	xhr.send();

	// publish message to inform about status
	eventManager.publish( TOPIC.STAGE.LOADING.START.AUDIO, {
		url : url
	} );
};

module.exports = AudioBufferList;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/System":27,"../messaging/EventManager":69,"../messaging/Topic":71}],14:[function(require,module,exports){
(function (global){
/**
 * @file This prototype holds the central Web Audio context and manages the
 * requirements for spatial sound effects.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates an audioListener. The constructor creates the central WebAudio
 * context of the application, a compressor and a gain-node for adjusting the
 * master volume.
 * 
 * node sequence: master gain -> compressor -> destination
 * 
 * @constructor
 * @augments THREE.Object3D
 * 
 */
function AudioListener() {

	THREE.Object3D.call( this );

	// central Web Audio context
	global.window.AudioContext = global.window.AudioContext || global.window.webkitAudioContext;

	Object.defineProperties( this, {
		type : {
			value : "AudioListener",
			configurable : false,
			enumerable : true,
			writable : false
		},
		context : {
			value : new global.window.AudioContext(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		compressor : {
			value : {},
			configurable : false,
			enumerable : true,
			writable : true
		},
		gain : {
			value : {},
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	// dynamics compression
	this.compressor = this.context.createDynamicsCompressor();
	this.compressor.connect( this.context.destination );

	// master gain
	this.gain = this.context.createGain();
	this.gain.connect( this.compressor );
}

AudioListener.prototype = Object.create( THREE.Object3D.prototype );
AudioListener.prototype.constructor = AudioListener;

/**
 * This method updates the position of the audioListener in 3D-space. Only then,
 * spatial sound effects can be emitted correctly.
 * 
 * @param {boolean} force - Flag for calculation the world matrix.
 */
AudioListener.prototype.updateMatrixWorld = ( function() {

	var position, quaternion, scale, orientation;

	return function( force ) {

		if ( position === undefined )
		{
			position = new THREE.Vector3();
			quaternion = new THREE.Quaternion();
			scale = new THREE.Vector3();
			orientation = new THREE.Vector3();
		}

		// call the parent method
		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorld.decompose( position, quaternion, scale );

		// calculate the orientation of the audio listener
		orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );

		// set position and orientation to the WebAudio context
		this.context.listener.setPosition( position.x, position.y, position.z );
		this.context.listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );
	};

} )();

module.exports = AudioListener;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"three":1}],15:[function(require,module,exports){
(function (global){
/**
 * @file Interface for entire audio handling. This prototype is used in stages
 * to access audio-based logic and to create audio entities.
 * 
 * @author Human Interactive
 */

"use strict";

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );
var AudioListener = require( "./AudioListener" );
var DynamicAudio = require( "./DynamicAudio" );
var AudioBufferList = require( "./AudioBufferList" );
var camera = require( "../core/Camera" );
var logger = require( "../core/Logger" );

/**
 * Creates the audio manager.
 * 
 * @constructor
 * 
 */
function AudioManager() {

	Object.defineProperties( this, {
		_listener : {
			value : new AudioListener(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		_backgroundMusicGain : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_backgroundMusic : {
			value : new global.Audio(),
			configurable : false,
			enumerable : false,
			writable : true
		},
		_dynamicAudios : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );

	// gain node for background music, used for fadeIn/ fadeOut
	this._backgroundMusicGain = this._listener.context.createGain();
	this._backgroundMusicGain.connect( this._listener.gain );

	// connect background music to web audio pipeline
	var source = this._listener.context.createMediaElementSource( this._backgroundMusic );
	source.connect( this._backgroundMusicGain );

	// set error handling for background music
	this._backgroundMusic.onerror = this._onErrorBackgroundMusic;

	// add listener to camera
	camera.add( this._listener );
}

/**
 * Creates a dynamic audio object and stores it to the respective internal
 * array.
 * 
 * @param {string} id - The ID of the dynamic audio.
 * @param {object} buffer - The buffered audio file.
 * @param {boolean} loop - Should the audio played in a loop?
 * @param {boolean} stageIndependent - Should the audio independent of the
 * stage?
 * 
 * @returns {DynamicAudio} The new dynamic audio.
 */
AudioManager.prototype.createDynamicSound = function( id, buffer, loop, stageIndependent ) {

	var audio = new DynamicAudio( id, this._listener, buffer, loop, stageIndependent );
	this._dynamicAudios.push( audio );
	return audio;
};

/**
 * Creates an audio buffer list.
 * 
 * @param {object} audioList - An array with name of audio files.
 * @param {function} callback - This callback is executed when all audio files
 * are loaded.
 * 
 * @returns {AudioBufferList} The new audio buffer list.
 */
AudioManager.prototype.createAudioBufferList = function( audioList, callback ) {

	return new AudioBufferList( this._listener.context, audioList, callback );
};

/**
 * Removes dynamic audio objects from the internal array.
 * 
 * @param {boolean} isClear - Should all dynamic audios deleted or only stage
 * dependent audios?
 */
AudioManager.prototype.removeDynamicAudios = function( isClear ) {

	if ( isClear === true )
	{
		this._dynamicAudios.length = 0;
	}
	else
	{
		for ( var i = this._dynamicAudios.length - 1; i >= 0; i-- )
		{
			if ( this._dynamicAudios[ i ].stageIndependent === false )
			{
				this._dynamicAudios.splice( i, 1 );
			}
		}
	}
};

/**
 * Gets a dynamic audio of the internal array.
 * 
 * @param {string} id - The id of the dynamic audio.
 * 
 * @returns {DynamicAudio} The dynamic audio.
 */
AudioManager.prototype.getDynamicAudio = function( id ) {

	var dynamicAudio = null;

	for ( var i = 0; i < this._dynamicAudios.length; i++ )
	{
		if ( this._dynamicAudios[ i ].audioId === id )
		{
			dynamicAudio = this._dynamicAudios[ i ];
			break;
		}
	}

	if ( dynamicAudio === null )
	{
		throw "ERROR: AudioManager: Dynamic Audio with ID " + id + " not existing.";
	}
	else
	{
		return dynamicAudio;
	}
};

/**
 * Sets the background music.
 * 
 * @param {string} file - The actual audio file. Only MP3s are valid.
 * @param {number} volume - The volume of the audio.
 * @param {boolean} loop - Should the audio played in a loop?
 */
AudioManager.prototype.setBackgroundMusic = function( file, volume, loop ) {

	var url = "/assets/audio/static/" + file + ".mp3";

	this._backgroundMusic.src = url;
	this._backgroundMusic.volume = volume || 1;
	this._backgroundMusic.loop = loop || true;

	this._backgroundMusic.oncanplay = function( event ) {

		// publish message to inform about status
		eventManager.publish( TOPIC.STAGE.LOADING.COMPLETE.MUSIC, {
			url : url
		} );

		// execute this handler just one time
		event.target.oncanplay = null;
	};

	logger.log( "INFO: AudioManager: Set new background music. URL: %s", url );

	// publish message to inform about status
	eventManager.publish( TOPIC.STAGE.LOADING.START.MUSIC, {
		url : url
	} );
};

/**
 * Plays the background music.
 * 
 * @param {boolean} isFadeIn - Should the audio fade in?
 * @param {number} duration - The duration of the fade in.
 */
AudioManager.prototype.playBackgroundMusic = function( isFadeIn, duration ) {

	// start playing
	this._backgroundMusic.play();

	// adjust gain node of background music
	if ( isFadeIn === true )
	{
		// fade in
		this._backgroundMusicGain.gain.linearRampToValueAtTime( 0, this._backgroundMusic.currentTime );
		this._backgroundMusicGain.gain.linearRampToValueAtTime( 1, this._backgroundMusic.currentTime + duration || 2 );
	}
	else
	{
		this._backgroundMusicGain.gain.value = 1;
	}

	// logging
	logger.log( "INFO: AudioManager: Start playing background music." );
};

/**
 * Pauses the background music.
 * 
 * @param {boolean} isFadeOut - Should the audio fade out?
 * @param {number} duration - The duration of the fade out.
 * @param {function} onPausedCallback - Executed, when the audio is paused.
 */
AudioManager.prototype.pauseBackgroundMusic = function( isFadeOut, duration, onPausedCallback ) {

	// save context
	var self = this;

	if ( isFadeOut === true )
	{
		// fade out
		this._backgroundMusicGain.gain.linearRampToValueAtTime( 1, this._backgroundMusic.currentTime );
		this._backgroundMusicGain.gain.linearRampToValueAtTime( 0, this._backgroundMusic.currentTime + duration || 2 );

		// pause music with delay, at the end of the animation
		setTimeout( function() {

			self._backgroundMusic.pause();

			// execute callback
			if ( typeof onPausedCallback === "function" )
			{
				onPausedCallback.call( self );
			}

		}, ( duration || 2 ) * 1000 );
	}
	else
	{

		// immediately pause music
		this._backgroundMusic.pause();
		this._backgroundMusicGain.gain.value = 0;

		// execute callback
		if ( typeof onPausedCallback === "function" )
		{
			onPausedCallback.call( this );
		}
	}

	// logging
	logger.log( "INFO: AudioManager: Pause playing background music." );
};

/**
 * Stops the background music.
 * 
 * @param {boolean} isFadeOut - Should the audio fade out?
 * @param {number} duration - The duration of the fade out.
 * @param {function} onStoppedCallback - Executed, when the audio is stopped.
 */
AudioManager.prototype.stopBackgroundMusic = function( isFadeOut, duration, onStoppedCallback ) {

	this.pauseBackgroundMusic( isFadeOut, duration, function() {

		// reset currentTime
		this._backgroundMusic.currentTime = 0.0;

		// execute callback
		if ( typeof onStoppedCallback === "function" )
		{
			onStoppedCallback.call( this );
		}
	} );

	// logging
	logger.log( "INFO: AudioManager: Stop playing background music." );
};

/**
 * Is the background music played?
 * 
 * @returns {boolean}
 */
AudioManager.prototype.isBackgroundMusicPlayed = function() {

	return this._backgroundMusic.paused;
};

/**
 * Is the background music played in a loop?
 * 
 * @return {boolean} - The loop-flag.
 */
AudioManager.prototype.isBackgroundMusicLoop = function() {

	return this._backgroundMusic.loop;
};

/**
 * Sets the loop property of the background music.
 * 
 * @param {boolean} loop - The loop-flag to set.
 */
AudioManager.prototype.setBackgroundMusicLoop = function( loop ) {

	this._backgroundMusic.loop = loop;
};

/**
 * Gets the volume property of the background music.
 * 
 * @return {number} volume - The volume.
 */
AudioManager.prototype.getBackgroundMusicVolume = function() {

	return this._backgroundMusic.volume;
};

/**
 * Sets the volume property of the background music.
 * 
 * @param {number} volume - The volume to set.
 */
AudioManager.prototype.setBackgroundMusicVolume = function( volume ) {

	this._backgroundMusic.volume = volume;
};

/**
 * This method handles error-situations when playing the background music. It
 * triggers a special topic, which can processed of e.g. the
 * UserInterfaceManager.
 */
AudioManager.prototype._onErrorBackgroundMusic = function() {

	logger.error( "ERROR: AudioManager: Media resource could not be processed." );
	eventManager.publish( TOPIC.APPLICATION.ERROR.MUSIC, "Media resource could not be processed" );
};

module.exports = new AudioManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/Camera":19,"../core/Logger":21,"../messaging/EventManager":69,"../messaging/Topic":71,"./AudioBufferList":13,"./AudioListener":14,"./DynamicAudio":16}],16:[function(require,module,exports){
/**
 * @file Prototype for creating dynamic, full-buffered audio objects.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );
/**
 * Creates a dynamic audio object.
 * 
 * node sequence: source -> panner -> gain
 * 
 * @constructor
 * @augments THREE.Object3D
 * 
 * @param {string} id - The ID of the dynamic audio.
 * @param {AudioListener} listener - The listener object.
 * @param {object} buffer - The buffered audio file.
 * @param {boolean} loop - Should the audio played in a loop?
 * @param {boolean} stageIndependent - Should the audio independent of the
 * stage?
 * 
 */
function DynamicAudio( id, listener, buffer, loop, stageIndependent ) {

	THREE.Object3D.call( this );

	Object.defineProperties( this, {
		type : {
			value : "DynamicAudio",
			configurable : false,
			enumerable : true,
			writable : false
		},
		audioId : {
			value : id,
			configurable : false,
			enumerable : true,
			writable : false
		},
		buffer : {
			value : buffer,
			configurable : false,
			enumerable : true,
			writable : true
		},
		loop : {
			value : loop || false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		stageIndependent : {
			value : stageIndependent || false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_context : {
			value : listener.context,
			configurable : false,
			enumerable : true,
			writable : false
		},
		_gain : {
			value : listener.context.createGain(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		_panner : {
			value : listener.context.createPanner(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		_source : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_pitchVariation : {
			value : undefined,
			configurable : false,
			enumerable : false,
			writable : true
		},
	} );

	// audio-node for volume
	this._gain.connect( listener.gain );

	// audio-node for spatial effects
	this._panner.distanceModel = "linear";
	this._panner.panningModel = "HRTF";
	this._panner.connect( this._gain );
}

DynamicAudio.prototype = Object.create( THREE.Object3D.prototype );
DynamicAudio.prototype.constructor = DynamicAudio;

/**
 * Plays an audio file once. You always have to create a new AudioBufferSource
 * when playing the file more than one time.
 * 
 * @param {number} time - The time offset, where the audio file should start
 * playing.
 */
DynamicAudio.prototype.play = function( time ) {

	// disconnect source node, if necessary
	if ( this._source !== null )
	{
		this._source.disconnect();
	}

	// build new source node because sources can just played once
	// see https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode
	this._source = this._context.createBufferSource();

	this._source.buffer = this.buffer;
	this._source.loop = this.loop;
	this._source.connect( this._panner );

	// regard pitch variation
	if ( typeof this._pitchVariation === "function" )
	{
		this._source.playbackRate.value = this._pitchVariation();
	}

	// play sound
	this._source.start( time || 0 );
};

/**
 * Stops an audio file.
 * 
 * @param {number} time - The time offset, where the audio file should stop
 * playing.
 */
DynamicAudio.prototype.stop = function( time ) {

	this._source.stop( time || 0 );
};

/**
 * Gets the volume of the audio file.
 * 
 * @return {number} The volume.
 */
DynamicAudio.prototype.getVolume = function() {

	return this._gain.gain.value;
};

/**
 * Sets the volume of the audio file.
 * 
 * @param {number} volume - The volume to set.
 */
DynamicAudio.prototype.setVolume = function( volume ) {

	this._gain.gain.value = volume;
};

/**
 * Gets the refDistance.
 * 
 * @return {number} Reference distance for reducing volume as the audio source
 * moves further from the listener.
 */
DynamicAudio.prototype.getRefDistance = function() {

	return this._panner.refDistance;
};

/**
 * Sets the refDistance.
 * 
 * @param {number} refDistance - Reference distance for reducing volume as the
 * audio source moves further from the listener.
 */
DynamicAudio.prototype.setRefDistance = function( refDistance ) {

	this._panner.refDistance = refDistance;
};

/**
 * Gets the rolloffFactor.
 * 
 * @return {number} How quickly the volume is reduced as the source moves away
 * from the listener.
 */
DynamicAudio.prototype.getRolloffFactor = function() {

	return this._panner.rolloffFactor;
};

/**
 * Sets the rolloffFactor.
 * 
 * @param {number} rolloffFactor - How quickly the volume is reduced as the
 * source moves away from the listener.
 */
DynamicAudio.prototype.setRolloffFactor = function( rolloffFactor ) {

	this._panner.rolloffFactor = rolloffFactor;
};

/**
 * Gets the maxDistance.
 * 
 * @return {number} Maximum distance between the audio source and the listener,
 * after which the volume is not reduced any further.
 */
DynamicAudio.prototype.getMaxDistance = function() {

	return this._panner.maxDistance;
};

/**
 * Sets the maxDistance.
 * 
 * @param {number} maxDistance - Maximum distance between the audio source and
 * the listener, after which the volume is not reduced any further.
 */
DynamicAudio.prototype.setMaxDistance = function( maxDistance ) {

	this._panner.maxDistance = maxDistance;
};

/**
 * Special method to add specific spatial effects to a dynamic audio.
 * 
 * @param {number} coneInnerAngle - Describing the angle, in degrees, of a cone
 * inside of which there will be no volume reduction.
 * @param {number} coneOuterAngle - Describing the angle, in degrees, of a cone
 * outside of which the volume will be reduced by a constant value, defined by
 * the coneOuterGain attribute.
 * @param {number} coneOuterGain - Describing the amount of volume reduction
 * outside the cone defined by the coneOuterAngle attribute. Its default value
 * is 0, meaning that no sound can be heard.
 */
DynamicAudio.prototype.addDirection = function( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

	this._panner.coneInnerAngle = coneInnerAngle;
	this._panner.coneOuterAngle = coneOuterAngle;
	this._panner.coneOuterGain = coneOuterGain;
};

/**
 * Adds a custom function, that calculates pitch variations.
 * 
 * @param {function} pitchVariation - Function for calculation pitch variations.
 */
DynamicAudio.prototype.addPitchVariation = function( pitchVariation ) {

	this._pitchVariation = pitchVariation;
};

/**
 * This method updates the position of the dynamicAudio in 3D-space. Only then,
 * spatial sound effects can be emitted correctly.
 * 
 * @param {boolean} force - Flag for calculation the world matrix.
 */
DynamicAudio.prototype.updateMatrixWorld = ( function() {

	var position;

	return function( force ) {

		if ( position === undefined )
		{
			position = new THREE.Vector3();
		}

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this._panner.setPosition( position.x, position.y, position.z );
	};

} )();

module.exports = DynamicAudio;
},{"three":1}],17:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for first person controls. The logic uses HTML5 Pointer Lock
 * API to capture mouse-movements. The camera is stored within an additional 3D-object
 * (head) to effectively handle orientation stuff and camera motions.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var camera = require( "../core/Camera" );
var logger = require( "../core/Logger" );
var audioManager = require( "../audio/AudioManager" );
var userInterfaceManager = require( "../ui/UserInterfaceManager" );
var settingsManager = require( "../etc/SettingsManager" );
var Easing = require( "../animation/Easing" );
var utils = require( "../etc/Utils" );

var self;

/**
 * Creates the first person controls.
 * 
 * @constructor
 */
function FirstPersonControls( player ) {

	// a reference to the player object
	Object.defineProperties( this, {
		_player : {
			value : player,
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );

	// movement properties
	Object.defineProperties( this, {
		_isMoveForward : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isMoveBackward : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isMoveLeft : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isMoveRight : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_move : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_strafe : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_moveSpeed : {
			value : FirstPersonControls.DEFAULT.SPEED.MOVE,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_strafeSpeed : {
			value : FirstPersonControls.DEFAULT.SPEED.STRAFE,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// used for animations
	Object.defineProperties( this, {
		_animationStartTime : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_animationHeight : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_animationMove : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_animationStrafe : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_animationDeflection : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_animationFrequency : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// used for head motion calculation
	Object.defineProperties( this, {
		_deflection : {
			value : FirstPersonControls.DEFAULT.CAMERA.DEFLECTION,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_frequency : {
			value : FirstPersonControls.DEFAULT.CAMERA.FREQUENCY,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_phase : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_lastFrequency : {
			value : FirstPersonControls.DEFAULT.CAMERA.FREQUENCY,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_motionFactor : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_motionCurveUp : {
			value : true,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_motionLastValue : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
	} );

	// flags
	Object.defineProperties( this, {
		// indicates, if the player is crouching
		_isCrouch : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// indicates, if the player is running
		_isRun : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// indicates, if the mouse pointer is captured
		isCaptured : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates, if an ui element is active
		isUiElementActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates, if the controls are locked
		isLocked : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
	} );
	
	this._init();
}

/**
 * Updates the controls.
 * 
 * @param {number} delta - Elapsed time between two frames.
 * @param {THREE.Vector3} displacement -The displacement vector.
 */
FirstPersonControls.prototype.update = function( delta, displacement ) {

	// calculate displacement caused by movement of the player
	this._calculateMovement( delta, displacement );
	
	// animation control movements
	this._animate();
};

/**
 * Sets the direction of the controls.
 * 
 * @param {THREE.Vector3} direction -  The direction to set.
 */
FirstPersonControls.prototype.setDirection = ( function() {

	var xAxis, yAxis, zAxis, rotationMatrix, euler;

	return function( direction ) {

		if ( xAxis === undefined )
		{
			xAxis = new THREE.Vector3(); // right
			yAxis = new THREE.Vector3(); // up
			zAxis = new THREE.Vector3(); // front

			rotationMatrix = new THREE.Matrix4();
			euler = new THREE.Euler( 0, 0, 0, "YXZ" );
		}

		// the front vector always points to the direction vector
		zAxis.copy( direction ).normalize();

		// avoid zero-length axis
		if ( zAxis.lengthSq() === 0 )
		{
			zAxis.z = 1;
		}

		// compute right vector
		xAxis.crossVectors( this._player.object3D.up, zAxis );

		// avoid zero-length axis
		if ( xAxis.lengthSq() === 0 )
		{
			zAxis.x += 0.0001;
			xAxis.crossVectors( this._player.object3D.up, zAxis ).normalize();
		}

		// compute up vector
		yAxis.crossVectors( zAxis, xAxis );

		// setup a rotation matrix of the basis
		rotationMatrix.makeBasis( xAxis, yAxis, zAxis );

		// create euler angles from rotation
		euler.setFromRotationMatrix( rotationMatrix );

		// apply rotation to control objects
		this._player.rotation.y = euler.y;
		this._player.head.rotation.x = euler.x;
	};

}() );

/**
 * Returns the direction of the controls.
 * 
 * @param {THREE.Vector3} optionalTarget - The optional target vector.
 * 
 * @returns {THREE.Vector3} The direction vector.
 */
FirstPersonControls.prototype.getDirection = ( function() {

	var rotation;

	return function( optionalTarget ) {
		
		var result = optionalTarget || new THREE.Vector3();

		if ( rotation === undefined )
		{
			rotation = new THREE.Euler( 0, 0, 0, "YXZ" );
		}
		
		// calculate direction
		rotation.set( this._player.head.rotation.x, this._player.rotation.y, 0 );
		result.set( 0, 0, 1 ).applyEuler( rotation );
		return result;
	};

}() );

/**
 * This method calculates the motions of the camera.
 * 
 * @param {number} delta - Elapsed time between two frames.
 * @param {THREE.Vector3} displacement - This vector contains the player's
 * displacement of the current frame.
 */
FirstPersonControls.prototype.calculateCameraMotion = ( function() {

	var audioStep1, audioStep2;

	return function( delta, displacement ) {

		var motion;

		// load audios if necessary
		if ( audioStep1 === undefined || audioStep2 === undefined )
		{
			audioStep1 = audioManager.getDynamicAudio( "controls.step1" );
			audioStep2 = audioManager.getDynamicAudio( "controls.step2" );
		}

		if ( this._move !== 0 || this._strafe !== 0 )
		{
			// get motion factor from displacement
			this._motionFactor += delta * displacement.length();

			// calculate frequency for sine curve
			this._calculateFrequency();

			// calculate actual motion
			motion = Math.sin( this._motionFactor * this._frequency + this._phase );

			// play audio steps
			if ( motion < this._motionLastValue && this._motionCurveUp === true )
			{
				this._motionCurveUp = false;
				audioStep1.play();
			}
			else if ( motion > this._motionLastValue && this._motionCurveUp === false )
			{
				this._motionCurveUp = true;
				audioStep2.play();
			}

			// set values to camera
			camera.position.y = Math.abs( motion ) * this._deflection;
			camera.position.x = motion * this._deflection;

			// store current motion for next calculation
			this._motionLastValue = motion;

		}
		else
		{
			// if player is not moving, reset camera
			this.resetCamera();
		}

	};

}() );

/**
 * This method resets the camera to its native position. The reset is done with
 * a simple linear transition.
 */
FirstPersonControls.prototype.resetCamera = function() {

	// only translate if necessary
	if ( camera.position.x !== 0 || camera.position.y !== 0 )
	{
		// reset y value
		camera.position.y -= FirstPersonControls.DEFAULT.CAMERA.RESETFACTOR;
		camera.position.y = Math.max( camera.position.y, 0 );

		// reset x value
		if ( camera.position.x < 0 )
		{
			camera.position.x += FirstPersonControls.DEFAULT.CAMERA.RESETFACTOR;
			camera.position.x = Math.min( camera.position.x, 0 );
		}
		else if ( camera.position.x > 0 )
		{
			camera.position.x -= FirstPersonControls.DEFAULT.CAMERA.RESETFACTOR;
			camera.position.x = Math.max( camera.position.x, 0 );
		}

		// initialize motion values
		this._motionFactor = 0;
		this._motionCurveUp = true;
		this._motionLastValue = 0;
		this._phase = 0;
	}
};

/**
 * Initializes the controls
 */
FirstPersonControls.prototype._init = function() {
	
	self = this;
	
	// set default height of the head
	this._setHeight( FirstPersonControls.DEFAULT.HEIGHT );
	
	// build relationship
	this._player.head.add( camera ); // camera -> head
	
	// the camera should look to positive z-axis by default
	camera.rotation.set( 0, Math.PI, 0 );

	// subscriptions
	eventManager.subscribe( TOPIC.CONTROLS.CAPTURE, this._onCapture );
	eventManager.subscribe( TOPIC.CONTROLS.LOCK, this._onLock );

	// events
	global.document.addEventListener( "lockPointer", this._onCapturePointer );
	global.document.addEventListener( "releasePointer", this._onReleasePointer );

	global.document.addEventListener( "mousemove", this._onMouseMove );
	global.document.addEventListener( "keydown", this._onKeyDown );
	global.document.addEventListener( "keyup", this._onKeyUp );

	global.document.addEventListener( "pointerlockchange", this._onPointerlockchange );
	global.document.addEventListener( "mozpointerlockchange", this._onPointerlockchange );
	global.document.addEventListener( "webkitpointerlockchange", this._onPointerlockchange );

	global.document.addEventListener( "pointerlockerror", this._onPointerlockerror );
	global.document.addEventListener( "mozpointerlockerror", this._onPointerlockerror );
	global.document.addEventListener( "webkitpointerlockerror", this._onPointerlockerror );

	// load and assign audio buffers for steps
	audioManager.createAudioBufferList( [ "step1", "step2" ], function( bufferList ) {

		// create new audios
		var audioStep1 = audioManager.createDynamicSound( "controls.step1", bufferList[ 0 ], false, true );
		var audioStep2 = audioManager.createDynamicSound( "controls.step2", bufferList[ 1 ], false, true );

		// add variations
		audioStep1.addPitchVariation( function() {

			return 0.9 + Math.random() * 0.4;
		} );
		audioStep2.addPitchVariation( function() {

			return 0.9 + Math.random() * 0.4;
		} );

		// assign audios to camera
		camera.add( audioStep1 );
		camera.add( audioStep2 );

	} ).load();
};

/**
 * This method does the actual translation of the controls.
 * 
 * @param {number} delta - Elapsed time between two frames.
 * @param {THREE.Vector3} displacement -The displacement vector.
 */
FirstPersonControls.prototype._calculateMovement = ( function() {

	var velocity;

	return function( delta, displacement ) {

		if ( velocity === undefined )
		{
			velocity = new THREE.Vector3();
		}

		// ensure displacement is set to zero
		displacement.set( 0, 0, 0 );

		// convert booleans to one number to determine the movement direction
		this._move = Number( this._isMoveForward ) - Number( this._isMoveBackward );
		this._strafe = Number( this._isMoveLeft ) - Number( this._isMoveRight );

		// calculate velocity
		velocity.z = this._calculateMoveVelocity( delta );
		velocity.x = this._calculateStrafeVelocity( delta );

		// assign move and strafe values to displacement vector
		displacement.z = this._move;
		displacement.x = this._strafe;

		// normalization prevents that the player moves to fast when
		// e.g. forward and right are pressed simultaneously
		displacement.normalize().multiply( velocity );

		return displacement;
	};

}() );

/**
 * Calculates a new sine frequency for camera motion. It ensures, that the new
 * sine cuvre is in-sync to the old one.
 */
FirstPersonControls.prototype._calculateFrequency = function() {

	var current, next;

	if ( this._frequency !== this._lastFrequency )
	{
		current = ( this._motionFactor * this._lastFrequency + this._phase ) % utils.TWO_PI;
		next = ( this._motionFactor * this._frequency ) % utils.TWO_PI;

		this._phase = current - next;
		this._lastFrequency = this._frequency;
	}
	
};

/**
 * This method calculates the movement velocity in z-direction.
 * 
 * @param {number} delta - Elapsed time between two frames.
 * 
 * @returns {number} The velocity in z-direction.
 */
FirstPersonControls.prototype._calculateMoveVelocity = ( function() {

	var acceleration = 0;

	return function( delta ) {

		if ( this._move !== 0 )
		{
			acceleration += this._move * delta * FirstPersonControls.DEFAULT.SPEED.ACCELERATION.FACTOR;

			if ( Math.abs( acceleration ) > FirstPersonControls.DEFAULT.SPEED.ACCELERATION.MAX )
			{
				acceleration = FirstPersonControls.DEFAULT.SPEED.ACCELERATION.MAX * this._move;
			}

		}
		else
		{
			acceleration = 0;
		}

		return Math.abs( Math.tan( acceleration ) * this._moveSpeed );
	};

}() );

/**
 * This method calculates the movement velocity in x-direction.
 * 
 * @param {number} delta - Elapsed time between two frames.
 * 
 * @returns {number} The velocity in x-direction.
 */
FirstPersonControls.prototype._calculateStrafeVelocity = ( function() {

	var acceleration = 0;

	return function( delta ) {

		if ( this._strafe !== 0 )
		{
			acceleration += this._strafe * delta * FirstPersonControls.DEFAULT.SPEED.ACCELERATION.FACTOR;

			if ( Math.abs( acceleration ) > FirstPersonControls.DEFAULT.SPEED.ACCELERATION.MAX )
			{
				acceleration = FirstPersonControls.DEFAULT.SPEED.ACCELERATION.MAX * this._strafe;
			}
		}
		else
		{
			acceleration = 0;
		}

		return Math.abs( Math.tan( acceleration ) * this._strafeSpeed );
	};

}() );

/**
 * Sets the height of the controls.
 * 
 * @param {number} height -  The height to set.
 */
FirstPersonControls.prototype._setHeight = function( height ) {

	this._player.head.position.y = height;
};

/**
 * Gets the height of the controls.
 * 
 * @returns {number} The control's height.
 */
FirstPersonControls.prototype._getHeight = function() {

	return this._player.head.position.y;
};

/**
 * Handles the "crouch" command. Crouching decreases the height and movement
 * speed of the player. These values are changed via animations.
 */
FirstPersonControls.prototype._handleCrouch = function() {

	// toggle boolean value
	this._isCrouch = !this._isCrouch;

	// running in crouch-mode not possible
	this._isRun = false;

	// save current timestamp and values for animation
	this._animationStartTime = global.performance.now();
	this._animationHeight = this._getHeight();
	this._animationMove = this._moveSpeed;
	this._animationStrafe = this._strafeSpeed;
	this._animationDeflection = this._deflection;
	this._animationFrequency = this._frequency;
};

/**
 * Handles the "run" command. Running increases the movement speed and the
 * camera shaking of the player. These values are changed via animations.
 * 
 * @param {boolean} isRun - Should the player run?
 */
FirstPersonControls.prototype._handleRun = function( isRun ) {

	this._isRun = isRun;

	// crouching in run-mode not possible
	this._isCrouch = false;

	// save current timestamp and values for animation
	this._animationStartTime = global.performance.now();
	this._animationHeight = this._getHeight();
	this._animationMove = this._moveSpeed;
	this._animationStrafe = this._strafeSpeed;
	this._animationDeflection = this._deflection;
	this._animationFrequency = this._frequency;
};

/**
 * Executes all animation methods of the controls.
 */
FirstPersonControls.prototype._animate = function(){
	
	this._animateCrouch();
	
	this._animateRun();
};

/**
 * Animates the transition between crouch and default position.
 */
FirstPersonControls.prototype._animateCrouch = function() {

	var elapsed, factor, targetHeight, targetMove, targetStrafe, targetDeflection, targetFrequency, valueHeight, valueSpeed;

	// animate only if necessary
	if ( ( this._isCrouch === true && this._getHeight() > FirstPersonControls.CROUCH.HEIGHT ) || 
		 ( this._isCrouch === false && this._isRun === false && this._getHeight() < FirstPersonControls.DEFAULT.HEIGHT ) )
	{
		// calculate elapsed time
		elapsed = ( global.performance.now() - this._animationStartTime ) * FirstPersonControls.CROUCH.ANIMATION.DURATION;

		// calculate factor for easing formula
		factor = elapsed > 1 ? 1 : elapsed;

		// calculate easing value
		valueSpeed = Easing.Cubic.In( factor );
		valueHeight = Easing.Cubic.Out( factor );

		// determine target values
		targetHeight = this._isCrouch === true ? FirstPersonControls.CROUCH.HEIGHT : FirstPersonControls.DEFAULT.HEIGHT;
		targetMove = this._isCrouch === true ? FirstPersonControls.CROUCH.SPEED.MOVE : FirstPersonControls.DEFAULT.SPEED.MOVE;
		targetStrafe = this._isCrouch === true ? FirstPersonControls.CROUCH.SPEED.STRAFE : FirstPersonControls.DEFAULT.SPEED.STRAFE;
		targetDeflection = this._isCrouch === true ? FirstPersonControls.CROUCH.CAMERA.DEFLECTION : FirstPersonControls.DEFAULT.CAMERA.DEFLECTION;
		targetFrequency = this._isCrouch === true ? FirstPersonControls.CROUCH.CAMERA.FREQUENCY : FirstPersonControls.DEFAULT.CAMERA.FREQUENCY;

		// do transition
		this._setHeight( this._animationHeight + ( targetHeight - this._animationHeight ) * valueHeight );
		this._moveSpeed = this._animationMove + ( targetMove - this._animationMove ) * valueSpeed;
		this._strafeSpeed = this._animationStrafe + ( targetStrafe - this._animationStrafe ) * valueSpeed;
		this._deflection = this._animationDeflection + ( targetDeflection - this._animationDeflection ) * valueSpeed;
		this._frequency = this._animationFrequency + ( targetFrequency - this._animationFrequency ) * valueSpeed;
	}

};

/**
 * Animates the transition between run and default movement.
 */
FirstPersonControls.prototype._animateRun = function() {

	var elapsed, factor, targetHeight, targetMove, targetStrafe, targetDeflection, targetFrequency, valueHeight, valueSpeed;

	// animate only if necessary
	if ( ( this._isRun === true && this._moveSpeed < FirstPersonControls.RUN.SPEED.MOVE ) || 
	     ( this._isRun === false && this._isCrouch === false && this._moveSpeed > FirstPersonControls.DEFAULT.SPEED.MOVE ) )
	{
		// calculate elapsed time
		elapsed = ( global.performance.now() - this._animationStartTime ) * FirstPersonControls.RUN.ANIMATION.DURATION;

		// calculate factor for easing formula
		factor = elapsed > 1 ? 1 : elapsed;

		// calculate easing value
		valueSpeed = Easing.Cubic.In( factor );
		valueHeight = Easing.Cubic.Out( factor );

		// determine target values
		targetHeight = this._isRun === true ? FirstPersonControls.RUN.HEIGHT : FirstPersonControls.DEFAULT.HEIGHT;
		targetMove = this._isRun === true ? FirstPersonControls.RUN.SPEED.MOVE : FirstPersonControls.DEFAULT.SPEED.MOVE;
		targetStrafe = this._isRun === true ? FirstPersonControls.RUN.SPEED.STRAFE : FirstPersonControls.DEFAULT.SPEED.STRAFE;
		targetDeflection = this._isRun === true ? FirstPersonControls.RUN.CAMERA.DEFLECTION : FirstPersonControls.DEFAULT.CAMERA.DEFLECTION;
		targetFrequency = this._isRun === true ? FirstPersonControls.RUN.CAMERA.FREQUENCY : FirstPersonControls.DEFAULT.CAMERA.FREQUENCY;

		// do transition
		this._setHeight(  this._animationHeight + ( targetHeight - this._animationHeight ) * valueHeight );
		this._moveSpeed = this._animationMove + ( targetMove - this._animationMove ) * valueSpeed;
		this._strafeSpeed = this._animationStrafe + ( targetStrafe - this._animationStrafe ) * valueSpeed;
		this._deflection = this._animationDeflection + ( targetDeflection - this._animationDeflection ) * valueSpeed;
		this._frequency = this._animationFrequency + ( targetFrequency - this._animationFrequency ) * valueSpeed;

	}
};

/**
 * Resets the movement. This avoids problems with moving players, even when they
 * hit no keys. This could happen, when you switch to main menu with pressed
 * wasd keys. The actual problem is, that the "keyup" event is not fired under
 * these circumstances.
 */
FirstPersonControls.prototype._reset = function() {

	this._isMoveForward = false;
	this._isMoveBackward = false;
	this._isMoveLeft = false;
	this._isMoveRight = false;
	this._isRun = false;
};

/**
 * Handles the activation message for the controls. Sets the flag that
 * indicates if the HTML5 pointer lock is active and the mouse pointer
 * is captured.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
FirstPersonControls.prototype._onCapture = function( message, data ) {

	self.isCaptured = data.isCaptured;

	self._reset();
};

/**
 * Handles the lock message of the controls. Sets the flag that 
 * indicates if the pointer lock is active, but the controls are
 * blocked for the player.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
FirstPersonControls.prototype._onLock = function( message, data ) {

	self.isLocked = data.isLocked;

	self._reset();
};

/**
 * Captures the pointer for detecting mouse movements.
 */
FirstPersonControls.prototype._onCapturePointer = function() {

	self.isUiElementActive = false;

	var element = global.document.querySelector( "canvas" );

	// Ask the browser to lock the pointer
	element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
	element.requestPointerLock();
};

/**
 * Releases the locked pointer. This method is always called by UI-Elements to
 * release the pointer. It is not called, when the Player goes via Esc to the
 * Main Menu.
 */
FirstPersonControls.prototype._onReleasePointer = function() {

	self.isUiElementActive = true;

	// Ask the browser to release the pointer
	global.document.exitPointerLock = global.document.exitPointerLock || global.document.mozExitPointerLock || global.document.webkitExitPointerLock;
	global.document.exitPointerLock();
};

/**
 * Detects the change of the pointer lock status. It is used to control the
 * menu.
 */
FirstPersonControls.prototype._onPointerlockchange = function() {

	var requestedElement = global.document.querySelector( "canvas" );

	if ( global.document.pointerLockElement === requestedElement || global.document.mozPointerLockElement === requestedElement || global.document.webkitPointerLockElement === requestedElement )
	{
		self.isCaptured = true;

		if ( self.isUiElementActive === false )
		{
			userInterfaceManager.hideMenu();
		}
		
		logger.log( "INFO: FirstPersonControls: Capture pointer and activate controls.");

	}
	else
	{
		self.isCaptured = false;

		if ( self.isUiElementActive === false )
		{
			userInterfaceManager.showMenu();
		}
		
		logger.log( "INFO: FirstPersonControls: Release pointer and deactivate controls.");
	}

	self._reset();
};

/**
 * Any error situation should be marked with an exception.
 */
FirstPersonControls.prototype._onPointerlockerror = function() {

	throw "ERROR: FirstPersonControls: Pointer Lock Error.";
};

/**
 * Detects any mouse movements, when pointer lock is active. Then it calculates
 * the rotation of player and head object.
 * 
 * @param {object} event - Default event object.
 */
FirstPersonControls.prototype._onMouseMove = function( event ) {

	var movementX, movementY;

	if ( self.isCaptured === true && self.isLocked === false )
	{
		// capture mouse movement
		movementX = event.movementX || event.mozMovementX || 0;
		movementY = event.movementY || event.mozMovementY || 0;

		// manipulate rotation of player and head
		self._player.rotation.y -= movementX * ( settingsManager.getMouseSensitivity() * 0.0001 );
		self._player.head.rotation.x += movementY * ( settingsManager.getMouseSensitivity() * 0.0001 );

		// prevent "loop" of x-axis
		self._player.head.rotation.x = Math.max( - utils.HALF_PI, Math.min( utils.HALF_PI, self._player.head.rotation.x ) );
	}

};

/**
 * Executes, when a key is pressed down.
 * 
 * @param {object} event - Default event object.
 */
FirstPersonControls.prototype._onKeyDown = ( function() {

	var position, direction;

	return function( event ) {

		if ( position === undefined )
		{
			position = new THREE.Vector3();
			direction = new THREE.Vector3();
		}

		if ( self.isCaptured === true && self.isLocked === false )
		{
			switch ( event.keyCode )
			{
				// w
				case 87:

					self._isMoveForward = true;

					break;

				// a
				case 65:

					self._isMoveLeft = true;

					break;

				// s
				case 83:

					self._isMoveBackward = true;

					break;

				// d
				case 68:

					self._isMoveRight = true;

					break;

				// c
				case 67:

					self._handleCrouch();

					break;

				// shift
				case 16:

					self._handleRun( true );

					break;

				// e
				case 69:
					
					// retrieve data
					self._player.head.getWorldPosition( position );
					self.getDirection( direction );

					// publish message with player data
					eventManager.publish( TOPIC.ACTION.INTERACTION, {
						position : position,
						direction : direction
					} );

					break;
			}
		}

	};

}() );

/**
 * Executes, when a key is released.
 * 
 * @param {object} event - Default event object.
 */
FirstPersonControls.prototype._onKeyUp = function( event ) {

	if ( self.isCaptured === true && self.isLocked === false )
	{
		switch ( event.keyCode )
		{
			// w
			case 87:

				self._isMoveForward = false;

				break;

			// a
			case 65:

				self._isMoveLeft = false;

				break;

			// a
			case 83:

				self._isMoveBackward = false;

				break;

			// d
			case 68:

				self._isMoveRight = false;

				break;

			// shift
			case 16:

				if ( self._isCrouch === false )
				{
					self._handleRun( false );
				}
		}
	}
};

FirstPersonControls.DEFAULT = {
	HEIGHT : 13,
	SPEED : {
		MOVE : 0.4,
		STRAFE : 0.3,
		ACCELERATION : {
			FACTOR : 1,
			MAX : Math.PI / 4
		}
	},
	CAMERA : {
		DEFLECTION : 0.3,
		FREQUENCY : 15,
		RESETFACTOR : 0.02
	}
};

FirstPersonControls.CROUCH = {
	HEIGHT : 6,
	SPEED : {
		MOVE : 0.2,
		STRAFE : 0.15,
		ACCELERATION : {
			FACTOR : 1,
			MAX : Math.PI / 4
		}
	},
	CAMERA : {
		DEFLECTION : 0.4,
		FREQUENCY : 15,
		RESETFACTOR : 0.02
	},
	ANIMATION : {
		DURATION : 0.001
	},
};

FirstPersonControls.RUN = {
	HEIGHT : 13,
	SPEED : {
		MOVE : 0.9,
		STRAFE : 0.6,
		ACCELERATION : {
			FACTOR : 1,
			MAX : Math.PI / 4
		}
	},
	CAMERA : {
		DEFLECTION : 0.7,
		FREQUENCY : 8,
		RESETFACTOR : 0.02
	},
	ANIMATION : {
		DURATION : 0.0015
	}
};

module.exports = FirstPersonControls;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../animation/Easing":11,"../audio/AudioManager":15,"../core/Camera":19,"../core/Logger":21,"../etc/SettingsManager":42,"../etc/Utils":45,"../messaging/EventManager":69,"../messaging/Topic":71,"../ui/UserInterfaceManager":118,"three":1}],18:[function(require,module,exports){
(function (global){
/**
 * @file This prototype contains the entire logic for starting the application.
 * 
 * @author Human Interactive
 */

"use strict";

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var environment = require( "./Environment" );
var renderer = require( "./Renderer" );
var camera = require( "./Camera" );
var system = require( "./System" );
var world = require( "./World" );
var userInterfaceManager = require( "../ui/UserInterfaceManager" );
var saveGameManager = require( "../etc/SaveGameManager" );
var multiplayerManager = require( "../etc/MultiplayerManager" );
var networkManager = require( "../network/NetworkManager" );

/**
 * Creates a Bootstrap instance, which initializes the entire application.
 * 
 * @constructor
 */
function Bootstrap() {

	this._getStartupParameter();

	this._initEngine();

	this._loadStage();
}

/**
 * This method provides the startup parameter for the engine from session
 * context. The data were stored originally by index.ejs and will be deleted
 * after parsing.
 */
Bootstrap.prototype._getStartupParameter = function() {
	
	// read and parse parameter from session context
	var parameter = JSON.parse( global.sessionStorage.getItem( "parameter" ) );
	
	// remove the parameter from session context
	global.sessionStorage.removeItem( "parameter" );

	// initialize the engine with the parameter object
	system.init( parameter );
};

/**
 * Initializes the core components of the engine.
 */
Bootstrap.prototype._initEngine = function() {

	var message;

	// check capabilities of the runtime environment/ browser
	if ( environment.isCompatible() === true )
	{
		// if the browser supports a touch-based user interface, show info
		// message
		if ( environment.isTouchDevice() === true )
		{
			message = "Please note: This demo works only with keyboard and mouse.";
			global.alert( message );
		}

		// initialize basic components
		renderer.init();
		camera.init();
		world.init();
		userInterfaceManager.init();

		// initialize network and multiplayer manager only if necessary
		if ( system.isMultiplayerActive === true )
		{
			networkManager.init();
			multiplayerManager.init();
		}
	}
	else
	{
		message = "ERROR: Bootstrap: The browser does not support all required APIs. Missing APIs: " + environment.unsupportedAPIs;
		global.alert( message );
		throw message;
	}
};

/**
 * Loads the stage. The respective stage is determined by the save game data. If
 * no save game is available, the engine uses the first stage.
 */
Bootstrap.prototype._loadStage = function() {

	var stageId = null;
	var saveGame = saveGameManager.load();

	if ( saveGame === null )
	{
		stageId = "001";
		saveGameManager.save( stageId );
	}
	else
	{
		stageId = saveGame.stageId;
	}

	eventManager.publish( TOPIC.APPLICATION.START, {
		stageId : stageId
	} );
};

module.exports = Bootstrap;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../etc/MultiplayerManager":35,"../etc/SaveGameManager":41,"../messaging/EventManager":69,"../messaging/Topic":71,"../network/NetworkManager":73,"../ui/UserInterfaceManager":118,"./Camera":19,"./Environment":20,"./Renderer":23,"./System":27,"./World":31}],19:[function(require,module,exports){
(function (global){
/**
 * @file This prototype contains the entire logic for camera-based
 * functionality.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var self;

/**
 * Creates a perspective camera.
 * 
 * @constructor
 * @augments THREE.PerspectiveCamera
 * 
 */
function Camera() {

	THREE.PerspectiveCamera.call( this );

	self = this;
}

Camera.prototype = Object.create( THREE.PerspectiveCamera.prototype );
Camera.prototype.constructor = Camera;

/**
 * Initializes the camera.
 * 
 * @param {number} fov - The field of view.
 * @param {number} aspect - The aspect ratio.
 * @param {number} near - The near distance.
 * @param {number} far - The far distance.
 */
Camera.prototype.init = function( fov, aspect, near, far ) {

	this.fov = fov || 45;
	this.aspect = aspect || global.window.innerWidth / global.window.innerHeight;
	this.near = near || 0.1;
	this.far = far || 1000;

	this.updateProjectionMatrix();

	// set subscriptions
	eventManager.subscribe( TOPIC.APPLICATION.RESIZE, this._onResize );
};

/**
 * Resizes the camera.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
Camera.prototype._onResize = function( message, data ) {

	// update camera dimensions
	self.aspect = global.window.innerWidth / global.window.innerHeight;
	self.updateProjectionMatrix();
};

module.exports = new Camera();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../messaging/EventManager":69,"../messaging/Topic":71,"three":1}],20:[function(require,module,exports){
(function (global){
/**
 * @file This prototype is used to ensure that all necessary browser features
 * are available.
 * 
 * @author Human Interactive
 */
"use strict";

/**
 * Creates a new environment instance.
 * 
 * @constructor
 */
function Environment() {

	Object.defineProperties( this, {
		_test : {
			value : "test",
			configurable : false,
			enumerable : false,
			writable : false
		},
		unsupportedAPIs : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
}

/**
 * This method performs tests to ensure the browser supports all APIs.
 * 
 * @returns {boolean} Does the browser support all APIs?
 */
Environment.prototype.isCompatible = function() {

	// clear message array
	this.unsupportedAPIs.length = 0;

	// perform tests
	if ( this._testWebGL() === false )
	{
		this.unsupportedAPIs.push( "WebGL" );
	}
	else if ( this._testWebSockets() === false )
	{
		this.unsupportedAPIs.push( "WebSockets" );
	}
	else if ( this._testWebWorkers === false )
	{
		this.unsupportedAPIs.push( "Web Workers" );
	}
	else if ( this._testPointerLock() === false )
	{
		this.unsupportedAPIs.push( "Pointer Lock" );
	}
	else if ( this._testLocalStorage() === false )
	{
		this.unsupportedAPIs.push( "Local Storage" );
	}
	else if ( this._testSessionStorage() === false )
	{
		this.unsupportedAPIs.push( "Session Storage" );
	}
	else if ( this._testHTML5Audio() === false )
	{
		this.unsupportedAPIs.push( "Audio Element" );
	}
	else if ( this._testWebAudio() === false )
	{
		this.unsupportedAPIs.push( "Web Audio" );
	}
	else if ( this._testWebPerformance() === false )
	{
		this.unsupportedAPIs.push( "Web Performance" );
	}

	// return result
	if ( this.unsupportedAPIs.length === 0 )
	{
		return true;
	}
	else
	{
		return false;
	}
};

/**
 * Checks, if the supports a touch-based user interface. Technically, the method
 * indicates if the browser supports the W3C Touch Events API. For various reasons,
 * the test works not always correct in all environments.
 * 
 * see: http://www.stucox.com/blog/you-cant-detect-a-touchscreen/
 * 
 * @returns {boolean} Does the browser has a touch-sensitive surface?
 */
Environment.prototype.isTouchDevice = function() {

	return !!( "ontouchstart" in global.window  );
};

/**
 * Checks, if the browser is a Firefox.
 * 
 * @returns {boolean} Is the current user-agent a Firefox?
 */
Environment.prototype.isFirefox = function() {

	return global.navigator.userAgent.toLowerCase().indexOf( "firefox" ) > -1;
};

/**
 * Tests the WebGL API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testWebGL = function() {

	try
	{
		var canvas = global.document.createElement( "canvas" );
		return !!global.window.WebGLRenderingContext && ( canvas.getContext( "webgl" ) || canvas.getContext( "experimental-webgl" ) );
	}
	catch ( e )
	{
		return false;
	}
};

/**
 * Tests the WebSockets API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testWebSockets = function() {

	return !!global.window.WebSocket;
};

/**
 * Tests the WebWorkers API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testWebWorkers = function() {

	return !!global.window.Worker;
};

/**
 * Tests the PointerLock API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testPointerLock = function() {

	var canvas = global.document.createElement( "canvas" );
	return !!canvas.requestPointerLock || !!canvas.mozRequestPointerLock || !!canvas.webkitRequestPointerLock;
};

/**
 * Tests the LocalStorage API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testLocalStorage = function() {

	try
	{
		global.localStorage.setItem( this._test, this._test );
		global.localStorage.removeItem( this._test );
		return true;
	}
	catch ( e )
	{
		return false;
	}
};

/**
 * Tests the SessionStorage API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testSessionStorage = function() {

	try
	{
		global.sessionStorage.setItem( this._test, this._test );
		global.sessionStorage.removeItem( this._test );
		return true;
	}
	catch ( e )
	{
		return false;
	}
};

/**
 * Tests the HTML5 Audio Element and MP3-Support.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testHTML5Audio = function() {

	var audio = global.document.createElement( "audio" );
	var isSupport = !!audio.canPlayType;

	if ( isSupport === true )
	{
		if ( audio.canPlayType( "audio/mpeg;" ).replace( /^no$/, "" ) !== "" )
		{
			isSupport = true;
		}
		else
		{
			isSupport = false;
		}
	}

	return isSupport;
};

/**
 * Tests the WebAudio API.
 */
Environment.prototype._testWebAudio = function() {

	return !!( global.window.AudioContext || global.window.webkitAudioContext );
};

/**
 * Tests the Web Performance API.
 * 
 * @returns {boolean} Does the browser support the API?
 */
Environment.prototype._testWebPerformance = function() {

	return !!global.window.performance;
};

module.exports = new Environment();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],21:[function(require,module,exports){
/**
 * @file This prototype provides logging functionality. It's a wrapper for the
 * browser console API.
 * 
 * @author Human Interactive
 */
"use strict";

var system = require( "./System" );

/**
 * Creates a logger instance.
 * 
 * @constructor
 */
function Logger() {

}

/**
 * Logs standard/info messages.
 */
Logger.prototype.log = function() {

	// log messages only in dev mode
	if ( system.isDevModeActive === true )
	{
		console.log.apply( console, arguments );
	}
};

/**
 * Logs warnings.
 */
Logger.prototype.warn = function() {

	console.warn.apply( console, arguments );
};

/**
 * Logs errors.
 */
Logger.prototype.error = function() {

	console.error.apply( console, arguments );
};

/**
 * Handles assertions.
 */
Logger.prototype.assert = function() {

	console.assert.apply( console, arguments );
};

/**
 * Logs information about the memory and render status to console.
 * 
 * @param {Renderer} renderer - The renderer object.
 */
Logger.prototype.logSystemInfo = function( renderer ) {

	console.group( "INFO: Logger: World Information, %s", new Date().toTimeString() );

	console.group( "Memory" );
	console.log( "%i Geometries", renderer.info.memory.geometries );
	console.log( "%i Programs", renderer.info.memory.programs );
	console.log( "%i Textures", renderer.info.memory.textures );
	console.groupEnd();

	console.group( "Render" );
	console.log( "%i Calls", renderer.info.render.calls );
	console.log( "%i Faces", renderer.info.render.faces );
	console.log( "%i Points", renderer.info.render.points );
	console.log( "%i Vertices", renderer.info.render.vertices );
	console.groupEnd();

	console.groupEnd();
};

module.exports = new Logger();
},{"./System":27}],22:[function(require,module,exports){
(function (global){
/**
 * @file Use this prototype to regulate code flow (e.g. for an update function).
 * Instantiate the prototype with the frequency you would like your code section
 * to flow (like 10 times per second) and then only allow the program flow to
 * continue if isReady() returns true.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

// the number of milliseconds the update period can vary per required
// update-step. This is here to make sure any multiple clients of this prototype
// have their updates spread evenly.
var updatePeriodVariator = 10;

/**
 * Creates a regulator instance.
 * 
 * @param {number} updatesPerSeconds - The update frequency.
 * 
 */
function Regulator( updatesPerSeconds ) {

	Object.defineProperties( this, {
		// the time period between updates
		_updatePeriod : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// the next time the regulator allows code flow
		_nextUpdateTime : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// the current timestamp
		_currentTime : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// setup initial timestamp
	this._nextUpdateTime = global.performance.now();

	// setup update period
	if ( updatesPerSeconds > 0 )
	{
		this._updatePeriod = 1000 / updatesPerSeconds;
	}
	else if ( updatesPerSeconds === 0 )
	{
		this._updatePeriod = 0;
	}
	else if ( updatesPerSeconds < 0 )
	{
		this._updatePeriod = -1;
	}
}

/**
 * Returns true if the current time exceeds the next update time.
 * 
 * @returns {boolean} Is the code allowed to flow?
 */
Regulator.prototype.isReady = function() {

	// if a regulator is instantiated with a zero frequency then it goes into
	// stealth mode (doesn't regulate)
	if ( this._updatePeriod === 0 )
	{
		return true;
	}

	// if the regulator is instantiated with a negative frequency then it will
	// never allow the code to flow
	if ( this._updatePeriod < 0 )
	{
		return false;
	}

	// retrieve timestamp
	this._currentTime = global.performance.now();

	// if the current timestamp is equal or greater than the "nextUpdateTime"
	// allow the code to flow
	if ( this._currentTime >= this._nextUpdateTime )
	{
		// calculate next update time
		this._nextUpdateTime = this._currentTime + this._updatePeriod + THREE.Math.randFloat( -updatePeriodVariator, updatePeriodVariator );

		return true;
	}

	return false;
};

module.exports = Regulator;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"three":1}],23:[function(require,module,exports){
(function (global){
/**
 * @file This prototype contains the entire logic for rendering-based
 * functionality. The renderer can add and remove post-processing effects at any
 * time.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var logger = require( "./Logger" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var EffectComposer = require( "../postprocessing/EffectComposer" );
var RenderPass = require( "../postprocessing/RenderPass" );
var ShaderPass = require( "../postprocessing/ShaderPass" );

var GrayscaleShader = require( "../shader/GrayscaleShader" );
var VignetteShader = require( "../shader/VignetteShader" );
var GaussianBlurShader = require( "../shader/GaussianBlurShader" );

var self;

/**
 * Creates a renderer.
 * 
 * @constructor
 */
function Renderer() {

	Object.defineProperties( this, {
		_renderer : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_composer : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_effectCount : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		enablePostProcessing : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	self = this;
}

/**
 * Initializes the renderer.
 */
Renderer.prototype.init = function() {

	// create WebGL renderer
	this._renderer = new THREE.WebGLRenderer( {
		antialias : true,
		alpha : true
	} );

	this._renderer.setPixelRatio( global.window.devicePixelRatio );
	this._renderer.setSize( global.window.innerWidth, global.window.innerHeight );
	this._renderer.setClearColor( 0x000000 );
	this._renderer.gammaInput = true;
	this._renderer.gammaOutput = true;
	this._renderer.shadowMap.enabled = true;

	// append renderer to DOM
	global.document.querySelector( "#canvas-container" ).appendChild( this._renderer.domElement );

	// create effect composer for post-processing
	this._composer = new EffectComposer( this._renderer );

	// set subscriptions
	eventManager.subscribe( TOPIC.APPLICATION.RESIZE, this._onResize );
};

/**
 * Renders the frame.
 * 
 * @param {Scene} scene - The scene object.
 * @param {Camera} camera - The camera object.
 * @param {THREE.WebGLRenderTarget} renderTarget - An optional render target.
 * @param {boolean} forceClear - Should the renderer clear the scene before
 * rendering?
 */
Renderer.prototype.render = function( scene, camera, renderTarget, forceClear ) {

	if ( this._effectCount > 0 && this.enablePostProcessing === true )
	{
		this._composer.render();
	}
	else
	{
		this._renderer.render( scene, camera, renderTarget, forceClear );
	}
};

/**
 * Prepares the renderer for post-processing. This method creates internally a
 * custom framebuffer (render target).
 * 
 * @param {World} world - The world object.
 * @param {Camera} camera - The camera object.
 */
Renderer.prototype.preparePostProcessing = function( world, camera ) {

	this._composer.addPass( new RenderPass( world.scene, camera ) );

	logger.log( "INFO: Renderer: Init post-processing for stage." );
};

/**
 * Adds a grayscale effect via post-processing.
 * 
 * @param {object} options - The options for the effect.
 * 
 * @returns {ShaderPass} The new effect.
 */
Renderer.prototype.addGrayscaleEffect = function( options ) {

	options = options || {};

	var effect = new ShaderPass( GrayscaleShader );
	effect.renderToScreen = options.renderToScreen;
	this._composer.addPass( effect );
	this._effectCount++;

	logger.log( "INFO: Renderer: Added grayscale effect." );

	return effect;
};

/**
 * Adds a vignette effect via post-processing.
 * 
 * @param {object} options - The options for the effect.
 * 
 * @returns {ShaderPass} The new effect.
 */
Renderer.prototype.addVignetteEffect = function( options ) {

	options = options || {};

	var effect = new ShaderPass( VignetteShader );
	effect.renderToScreen = options.renderToScreen;

	// set uniforms
	effect.uniforms.radius.value = options.radius || effect.uniforms.radius.value;
	effect.uniforms.strength.value = options.strength || effect.uniforms.strength.value;
	effect.uniforms.softness.value = options.softness || effect.uniforms.softness.value;

	this._composer.addPass( effect );
	this._effectCount++;

	logger.log( "INFO: Renderer: Added vignette effect." );

	return effect;
};

/**
 * Adds a horizontal gaussian blur effect via post-processing.
 * 
 * @param {object} options - The options for the effect.
 * 
 * @returns {ShaderPass} The new effect.
 */
Renderer.prototype.addHBlurEffect = function( options ) {

	options = options || {};

	var effect = new ShaderPass( GaussianBlurShader );
	effect.renderToScreen = options.renderToScreen;

	// set uniforms
	effect.uniforms.direction.value = new THREE.Vector2( 1, 0 ); // x-axis
	effect.uniforms.size.value = ( options.size || 1 ) / global.window.innerWidth;

	this._composer.addPass( effect );
	this._effectCount++;

	logger.log( "INFO: Renderer: Added horizonzal blur effect." );

	return effect;
};

/**
 * Adds a vertical gaussian blur effect via post-processing.
 * 
 * @param {object} options - The options for the effect.
 * 
 * @returns {ShaderPass} The new effect.
 */
Renderer.prototype.addVBlurEffect = function( options ) {

	options = options || {};

	var effect = new ShaderPass( GaussianBlurShader );
	effect.renderToScreen = options.renderToScreen;

	// set uniforms
	effect.uniforms.direction.value = new THREE.Vector2( 0, 1 ); // y-axis
	effect.uniforms.size.value = ( options.size || 1 ) / global.window.innerHeight;

	this._composer.addPass( effect );
	this._effectCount++;

	logger.log( "INFO: Renderer: Added vertical blur effect." );

	return effect;
};

/**
 * Removes a post-processing effect from the renderer.
 * 
 * @param {ShaderPass} effect - The effect to remove.
 */
Renderer.prototype.removeEffect = function( effect ) {

	this._composer.removePass( effect );
	this._effectCount--;
};

/**
 * Clears the renderer.
 */
Renderer.prototype.clear = function() {

	// stop post-processing
	this._composer.removePasses();
	this._effectCount = 0;

	// clear the internal renderer
	this._renderer.clear();
};

/**
 * Returns the WebGL rendering context. Useful for access to the plain WebGL API.
 * 
 * @returns {WebGLRenderingContext} The WebGLRenderingContext object.
 */
Renderer.prototype.getWebGLContext = function() {

	return this._renderer.context;
};

/**
 * Returns the current WebGL configuration state.
 * 
 * @returns {THREE.WebGLState} The internal WebGL state.
 */
Renderer.prototype.getWebGLState = function() {

	return this._renderer.state;
};

/**
 * Returns the maximum anisotropic filter value.
 * 
 * @returns {number} The maximum anisotropic filter value.
 */
Renderer.prototype.getMaxAnisotropy = function() {

	return this._renderer.getMaxAnisotropy();
};

/**
 * Returns the clear color of the renderer.
 * 
 * @returns {THREE.Color} The clear color.
 */
Renderer.prototype.getClearColor = function() {

	return this._renderer.getClearColor();
};

/**
 * Sets the clear color and alpha of the renderer.
 * 
 * @param {THREE.Color} color - The clear color.
 * @param {number} alpha - The clear alpha.
 */
Renderer.prototype.setClearColor = function( color, alpha ) {

	this._renderer.setClearColor( color, alpha );
};

/**
 * Returns the clear alpha value of the renderer.
 * 
 * @returns {number} The clear alpha.
 */
Renderer.prototype.getClearAlpha = function() {

	return this._renderer.getClearAlpha();
};

/**
 * Resizes the render-dimensions.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
Renderer.prototype._onResize = function( message, data ) {

	// resize renderer and effect composer
	self._renderer.setSize( global.window.innerWidth, global.window.innerHeight );
	self._composer.setSize( global.window.innerWidth, global.window.innerHeight );
};

module.exports = new Renderer();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../messaging/EventManager":69,"../messaging/Topic":71,"../postprocessing/EffectComposer":82,"../postprocessing/RenderPass":83,"../postprocessing/ShaderPass":84,"../shader/GaussianBlurShader":87,"../shader/GrayscaleShader":88,"../shader/VignetteShader":93,"./Logger":21,"three":1}],24:[function(require,module,exports){
/**
 * @file This prototype contains the entire logic for scene-based functionality.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates a scene, which holds all 3D-objects of the application.
 * 
 * @constructor
 * @augments THREE.Scene
 * 
 */
function Scene() {

	THREE.Scene.call( this );
}

Scene.prototype = Object.create( THREE.Scene.prototype );
Scene.prototype.constructor = Scene;

/**
 * Clears the scene from all objects.
 * 
 */
Scene.prototype.clear = function() {

	for ( var index = this.children.length - 1; index >= 0; index-- )
	{
		if ( this.children[ index ].type !== "Player" )
		{
			this.remove( this.children[ index ] );
		}
	}
};

module.exports = new Scene();
},{"three":1}],25:[function(require,module,exports){
(function (global){
/**
 * @file Basis prototype for all stages. It is used to provide specific stages a
 * set of managers and other common functionality.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var renderer = require( "./Renderer" );
var camera = require( "./Camera" );
var world = require( "./World" );
var system = require( "./System" );
var actionManager = require( "../action/ActionManager" );
var audioManager = require( "../audio/AudioManager" );
var animationManager = require( "../animation/AnimationManager" );
var entityManager = require( "../game/entity/EntityManager" );
var performanceManager = require( "../etc/PerformanceManager" );
var textManager = require( "../etc/TextManager" );
var saveGameManager = require( "../etc/SaveGameManager" );
var settingsManager = require( "../etc/SettingsManager" );
var userInterfaceManager = require( "../ui/UserInterfaceManager" );

/**
 * Creates a stage.
 * 
 * @constructor
 * 
 * @param {string} stageId - The ID of the stage.
 */
function StageBase( stageId ) {

	Object.defineProperties( this, {
		stageId : {
			value : stageId,
			configurable : false,
			enumerable : true,
			writable : true
		},
		renderer : {
			value : renderer,
			configurable : false,
			enumerable : true,
			writable : false
		},
		camera : {
			value : camera,
			configurable : false,
			enumerable : true,
			writable : false
		},
		world : {
			value : world,
			configurable : false,
			enumerable : true,
			writable : false
		},
		actionManager : {
			value : actionManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		animationManager : {
			value : animationManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		audioManager : {
			value : audioManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		entityManager : {
			value : entityManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		performanceManager : {
			value : performanceManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		saveGameManager : {
			value : saveGameManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		settingsManager : {
			value : settingsManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		textManager : {
			value : textManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		timeManager : {
			value : new THREE.Clock(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		userInterfaceManager : {
			value : userInterfaceManager,
			configurable : false,
			enumerable : true,
			writable : false
		},
		_delta : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_renderId : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
}

/**
 * This method is called, when the all requirements are fulfilled to setup the
 * stage. In dev-mode, additional helper objects are added.
 */
StageBase.prototype.setup = function() {

	if ( system.isDevModeActive === true )
	{
		this.world.addObject3D( new THREE.AxisHelper( 30 ) );
		this.world.addObject3D( new THREE.GridHelper( 200, 10 ) );
	}
};

/**
 * This method is called, when the stage is ready and started by the player.
 */
StageBase.prototype.start = function() {

	// publish message to release the controls
	eventManager.publish( TOPIC.CONTROLS.LOCK, {
		isLocked : false
	} );
};

/**
 * This method is called, when the stage is destroyed.
 */
StageBase.prototype.destroy = function() {

	// remove stage objects from all managers
	this.actionManager.removeActionObjects();

	this.actionManager.removeTriggers();

	this.animationManager.removeAnimations();

	this.animationManager.removeSprites();

	this.audioManager.removeDynamicAudios();

	this.entityManager.removeEntities();

	this.performanceManager.removeLODs();

	this.performanceManager.removeImpostors();

	this.textManager.removeTexts();

	// clear world
	this.world.clear();

	// clear renderer
	this.renderer.clear();

	// stop render loop
	global.cancelAnimationFrame( this._renderId );
};

/**
 * Renders the stage.
 */
StageBase.prototype._render = function() {

	// get delta time value
	this._delta = this.timeManager.getDelta();
	
	// update entity manager
	this.entityManager.update( this._delta );
	
	// update managers
	this.actionManager.update( this.world.player );
	this.animationManager.update( this._delta );
	this.performanceManager.update();
	this.userInterfaceManager.update();

	// render frame
	this.renderer.render( this.world.scene, this.camera );

	// save render ID
	this._renderId = global.requestAnimationFrame( this._render );
};

/**
 * Changes the stage.
 * 
 * @param {string} stageId - The new stageId
 * @param {boolean} isSaveGame - Should the progress be saved?
 */
StageBase.prototype._changeStage = function( stageId, isSaveGame ) {

	// publish message to lock the controls
	eventManager.publish( TOPIC.CONTROLS.LOCK, {
		isLocked : true
	} );
	
	// publish message to trigger the change
	eventManager.publish( TOPIC.STAGE.CHANGE, {
		stageId : stageId,
		isSaveGame : isSaveGame
	} );
};

// frequently used colors
StageBase.COLORS = {
	PRIMARY    : new THREE.Color( 0x6083c2 ).convertGammaToLinear(),
	SECONDARY  : new THREE.Color( 0x20252f ).convertGammaToLinear(),
	BLUE_DARK  : new THREE.Color( 0x455066 ).convertGammaToLinear(),
	BLUE_WHITE : new THREE.Color( 0xf3f4f6 ).convertGammaToLinear()
};

module.exports = StageBase;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../action/ActionManager":5,"../animation/AnimationManager":10,"../audio/AudioManager":15,"../etc/PerformanceManager":38,"../etc/SaveGameManager":41,"../etc/SettingsManager":42,"../etc/TextManager":44,"../game/entity/EntityManager":47,"../messaging/EventManager":69,"../messaging/Topic":71,"../ui/UserInterfaceManager":118,"./Camera":19,"./Renderer":23,"./System":27,"./World":31,"three":1}],26:[function(require,module,exports){
/**
 * @file Interface for entire stage-handling.
 * 
 * @author Human Interactive
 */
"use strict";

var self;

var logger = require( "./Logger" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var saveGameManager = require( "../etc/SaveGameManager" );
var userInterfaceManager = require( "../ui/UserInterfaceManager" );

// stages
var Stage_001 = require( "../stages/Stage_001" );
var Stage_002 = require( "../stages/Stage_002" );
var Stage_003 = require( "../stages/Stage_003" );
var Stage_004 = require( "../stages/Stage_004" );
var Stage_005 = require( "../stages/Stage_005" );
var Stage_006 = require( "../stages/Stage_006" );
var Stage_007 = require( "../stages/Stage_007" );
var Stage_008 = require( "../stages/Stage_008" );
var Stage_009 = require( "../stages/Stage_009" );
var Stage_010 = require( "../stages/Stage_010" );
var Stage_011 = require( "../stages/Stage_011" );
var Stage_012 = require( "../stages/Stage_012" );
var Stage_013 = require( "../stages/Stage_013" );

/**
 * Creates the stage manager.
 * 
 * @constructor
 */
function StageManager() {

	Object.defineProperties( this, {
		_stage : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_total : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_loaded : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isStageChangeActive : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isApplicationStartActive : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// subscriptions
	eventManager.subscribe( TOPIC.APPLICATION.START, this._onApplicationStart );
	eventManager.subscribe( TOPIC.STAGE.START, this._onStageStart );
	eventManager.subscribe( TOPIC.STAGE.CHANGE, this._onStageChange );
	eventManager.subscribe( TOPIC.STAGE.LOADING.START.ALL, this._onLoadStart );
	eventManager.subscribe( TOPIC.STAGE.LOADING.COMPLETE.ALL, this._onLoadComplete );

	self = this;
}

/**
 * Loads the stage with the given ID.
 * 
 * @param {string} stageId - The ID of the stage.
 */
StageManager.prototype.load = function( stageId ) {

	switch ( stageId )
	{
		case "001":

			this._stage = new Stage_001();
			break;

		case "002":

			this._stage = new Stage_002();
			break;

		case "003":

			this._stage = new Stage_003();
			break;

		case "004":

			this._stage = new Stage_004();
			break;

		case "005":

			this._stage = new Stage_005();
			break;

		case "006":

			this._stage = new Stage_006();
			break;

		case "007":

			this._stage = new Stage_007();
			break;

		case "008":

			this._stage = new Stage_008();
			break;

		case "009":

			this._stage = new Stage_009();
			break;

		case "010":

			this._stage = new Stage_010();
			break;

		case "011":

			this._stage = new Stage_011();
			break;
			
		case "012":
			
			this._stage = new Stage_012();
			break;
			
		case "013":
			
			this._stage = new Stage_013();
			break;

		default:
			throw "ERROR: StageManager: Invalid Stage-ID: " + stageId;
	}

	this._stage.setup();
	
	logger.log( "INFO: StageManager: Start loading stage with ID: %s", stageId );
};

/**
 * Clears the current stage.
 */
StageManager.prototype.clear = function() {

	if ( this._stage !== null )
	{
		this._stage.destroy();
	}
};

/**
 * This method is used load the first stage after application start.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
StageManager.prototype._onApplicationStart = function( message, data ) {

	if ( data !== undefined )
	{
		// set flag
		self._isApplicationStartActive = true;

		// load new stage
		self.load( data.stageId );
	}
	else
	{
		throw "ERROR: StageManager: Application start not possible. Missing message data.";
	}
};

/**
 * This method is used to change from one stage to an other.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
StageManager.prototype._onStageChange = function( message, data ) {

	if ( data !== undefined )
	{
		// show loading screen. execute stage change, when animation ends
		userInterfaceManager.showLoadingScreen( function() {

			// set flag
			self._isStageChangeActive = true;

			// clear stage
			self.clear();

			// load new stage
			self.load( data.stageId );

			// save game
			if ( data.isSaveGame === true )
			{
				saveGameManager.save( data.stageId );
			}
		} );

	}
	else
	{
		throw "ERROR: StageManager: Stage change not possible. Missing message data.";
	}
};

/**
 * This method is used to execute the start method of a stage. This happens when all assets
 * are loaded and the player jumps into the stage (from loading screen or menu).
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
StageManager.prototype._onStageStart = function( message, data ) {

	self._stage.start();
};

/**
 * This method is used to count the loading processes per stage.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
StageManager.prototype._onLoadStart = function( message, data ) {

	logger.log( "INFO: StageManager: Start asset loading. Message: %s. URL: %s", message, data.url );

	self._total++;
};

/**
 * This method is checks, if all assets for the current stage are loaded.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
StageManager.prototype._onLoadComplete = function( message, data ) {

	if ( self._isStageChangeActive === true || self._isApplicationStartActive === true )
	{
		logger.log( "INFO: StageManager: Asset loading complete. Message: %s. URL: %s", message, data.url );

		self._loaded++;

		// calculate progress
		var loadingProgress = Math.round( self._loaded * 100 / self._total );

		// inform system about progress
		eventManager.publish( TOPIC.STAGE.LOADING.PROGRESS, {
			loadingProgress : loadingProgress,
			isApplicationStart : self._isApplicationStartActive
		} );

		// check message count
		if ( self._loaded === self._total )
		{
			// publish message to inform the system that all assets are loaded
			// and the stage is ready to enter
			eventManager.publish( TOPIC.STAGE.READY, {
				isApplicationStart : self._isApplicationStartActive
			} );

			// reset attributes
			self._isStageChangeActive = false;
			self._isApplicationStartActive = false;
			self._loaded = 0;
			self._total = 0;

			// log event
			logger.log( "INFO: StageManager: Stage loaded and ready." );
		}
	}
};

module.exports = new StageManager();
},{"../etc/SaveGameManager":41,"../messaging/EventManager":69,"../messaging/Topic":71,"../stages/Stage_001":95,"../stages/Stage_002":96,"../stages/Stage_003":97,"../stages/Stage_004":98,"../stages/Stage_005":99,"../stages/Stage_006":100,"../stages/Stage_007":101,"../stages/Stage_008":102,"../stages/Stage_009":103,"../stages/Stage_010":104,"../stages/Stage_011":105,"../stages/Stage_012":106,"../stages/Stage_013":107,"../ui/UserInterfaceManager":118,"./Logger":21}],27:[function(require,module,exports){
/**
 * @file This prototype holds core information about the engine. The runtime
 * behavior of the application depends crucially of this prototype.
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates the system instance.
 * 
 * @constructor
 */
function System() {

	Object.defineProperties( this, {
		// the name of the application
		name : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the version of the application
		version : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the locale (i18n) of the application
		locale : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the URL to a content delivery network.
		// assets can be loaded from a different server than the application
		cdn : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates, if multiplayer components should be active
		isMultiplayerActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// indicates, if the development mode is active.
		// in production, this value should always be false to disable logging
		isDevModeActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

/**
 * Initialized the system with parameters from the back-end.
 * 
 * @param {object} parameter - Startup parameters of the system.
 */
System.prototype.init = function( parameter ) {

	if ( parameter !== undefined && parameter !== null )
	{
		this.name = parameter.name;
		this.version = parameter.version;
		this.locale = parameter.locale;
		this.cdn = parameter.cdn;

		this.isMultiplayerActive = !!parameter.isMultiplayerActive;
		this.isDevModeActive = !!parameter.isDevModeActive;
	}
	else
	{
		throw "ERROR: System: Unable to initialize system. Empty parameter object.";
	}

};

module.exports = new System();
},{}],28:[function(require,module,exports){
(function (global){
/**
 * @file This prototype represents a thread-object. It uses the HTML5-API Web
 * Workers to start scripts in separate threads.
 * 
 * @author Human Interactive
 */
"use strict";
/**
 * Creates a new Thread
 * 
 * @constructor
 * 
 * @param {string} id - The id of the thread.
 * @param {string} scriptURL - The URL of the serialized script.
 */
function Thread( id, scriptURL ) {

	Object.defineProperties( this, {
		id : {
			value : id,
			configurable : false,
			enumerable : true,
			writable : false
		},
		scriptURL : {
			value : scriptURL,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_worker : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	this._worker = new global.Worker( this.scriptURL );
}

/**
 * Posts a message to the internal web worker.
 * 
 * @param {object} message - The message.
 */
Thread.prototype.postMessage = function( message ) {

	this._worker.postMessage( message );
};

/**
 * Terminates the internal web worker.
 */
Thread.prototype.terminate = function() {

	this._worker.terminate();
};

/**
 * Adds an event listener to the message-event.
 * 
 * @param {function} listener - The event listener.
 */
Thread.prototype.onMessage = function( listener ) {

	this._worker.addEventListener( "message", listener, false );
};

/**
 * Adds an event listener to the error-event.
 * 
 * @param {function} listener - The event listener.
 */
Thread.prototype.onError = function( listener ) {

	this._worker.addEventListener( "error", listener, false );
};

module.exports = Thread;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],29:[function(require,module,exports){
(function (global){
/**
 * @file This prototype contains the entire logic for thread-based
 * functionality.
 * 
 * @author Human Interactive
 */
"use strict";

var Thread = require( "./Thread" );
/**
 * Creates the network manager.
 * 
 * @constructor
 * 
 */
function ThreadManager() {

	Object.defineProperties( this, {
		_threads : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );

	var self = this;

	// terminate all threads when refreshing/ leaving the application
	global.window.addEventListener( "beforeunload", function() {

		self.terminateAllThreads();
	} );
}

/**
 * Adds an event listener to the message-event.
 * 
 * @param {string} id - The id of the thread.
 * @param {string} scriptURL - The URL of the serialized script.
 * 
 * @returns {Thread} The new thread.
 */
ThreadManager.prototype.createThread = function( id, script ) {

	// get URL of script
	var scriptURL = this._getScriptURL( script );

	// create thread and add to internal array
	var thread = new Thread( id, scriptURL );
	this._threads.push( thread );

	return thread;
};

/**
 * Gets a thread of the internal array.
 * 
 * @param {string} id - The id of the thread.
 * 
 * @returns {Thread} The thread.
 */
ThreadManager.prototype.get = function( id ) {

	var thread = null;

	for ( var index = 0; index < this._threads.length; index++ )
	{
		if ( this._threads[ index ].id === id )
		{
			thread = this._threads[ index ];
			break;
		}
	}

	if ( thread === null )
	{
		throw "ERROR: ThreadManager: Thread with ID " + id + " not existing.";
	}
	else
	{
		return thread;
	}
};

/**
 * Terminates the thread.
 * 
 * @param {Thread} thread - The thread to terminate.
 * 
 */
ThreadManager.prototype.terminateThread = function( thread ) {

	// remove form internal array
	var index = this._threads.indexOf( thread );
	this._threads.splice( index, 1 );

	// release object URL
	global.URL.revokeObjectURL( thread.scriptURL );

	// terminate thread
	thread.terminate();
};

/**
 * Terminates all threads.
 */
ThreadManager.prototype.terminateAllThreads = function() {

	for ( var index = 0; index < this._threads.length; index++ )
	{
		// release object URL
		global.URL.revokeObjectURL( this._threads[ index ].scriptURL );

		// terminate thread
		this._threads[ index ].terminate();
	}

	// clear internal array
	this._threads.length = 0;
};

/**
 * This method prepares the script, so it can run as a separate thread. It
 * creates a BLOB and provides a object URL to generated content.
 * 
 * @param {string} script - The script for the thread.
 * 
 * @returns {string} The URL of the serialized script.
 */
ThreadManager.prototype._getScriptURL = function( script ) {

	var blob = new global.Blob( [ "(", script.toString(), ")()" ], {
		type : "application/javascript"
	} );
	var url = global.URL.createObjectURL( blob );
	return url;
};

module.exports = new ThreadManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Thread":28}],30:[function(require,module,exports){
(function (global){
/**
 * @file This prototype is a wrapper for the HTML5 User Timing API. It provides
 * a mechanism for accurate time measurement.
 * 
 * @author Human Interactive
 */

"use strict";

var system = require( "./System" );
var logger = require( "./Logger" );

/**
 * Creates a timing instance.
 * 
 * @constructor
 */
function Timing() {

}

/**
 * Stores a high resolution timestamp with the associated name.
 * 
 * @param {string} name - The name of the mark.
 */
Timing.prototype.mark = function( name ) {

	if ( system.isDevModeActive === true )
	{
		global.performance.mark( name );
	}

};

/**
 * Stores the time elapsed between two marks with the provided name.
 * 
 * @param {string} name - The name of the measurement.
 * @param {string} mark1 - The name of first mark.
 * @param {string} mark2 - The name of second mark.
 */
Timing.prototype.measure = function( name, mark1, mark2 ) {

	if ( system.isDevModeActive === true )
	{
		global.performance.measure( name, mark1, mark2 );

		// clear timestamps after measurement
		global.performance.clearMarks( mark1 );
		global.performance.clearMarks( mark2 );
	}

};

/**
 * Prints the given measurement to console.
 * 
 * @param {string} name - The name of the measurement.
 */
Timing.prototype.print = function( name ) {

	if ( system.isDevModeActive === true )
	{
		var entires = global.performance.getEntriesByName( name );

		logger.log( "INFO: Timing: Duration of %s: %f ms", entires[ 0 ].name, entires[ 0 ].duration );

		// clear measurement after logging
		global.performance.clearMeasures( name );
	}

};

module.exports = new Timing();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Logger":21,"./System":27}],31:[function(require,module,exports){
/**
 * @file This prototype contains all important environment data of a stage.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var scene = require( "./Scene" );
var actionManager = require( "../action/ActionManager" );
var entityManager = require( "../game/entity/EntityManager" );
var GameEntity = require( "../game/entity/GameEntity" );

/**
 * Creates a world object.
 * 
 * @constructor
 */
function World() {

	Object.defineProperties( this, {

		player : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true,
		},
		scene : {
			value : scene,
			configurable : false,
			enumerable : true,
			writable : false
		},
		grounds : {
			value : [],
			configurable : false,
			enumerable : true,
			writable : false
		},
		walls : {
			value : [],
			configurable : false,
			enumerable : true,
			writable : false
		},
		// this is just a reference to the action objects of the action manager
		actionObjects : {
			value : actionManager._actionObjects,
			configurable : false,
			enumerable : true,
			writable : false
		}

	} );
}

/**
 * Initializes the world.
 */
World.prototype.init = function() {

	// create player instance
	this.player = entityManager.createPlayer( this );

	// set the scope of this entity to WORLD. it won't get deleted within a
	// stage change
	this.player.scope = GameEntity.SCOPE.WORLD;

	// add player to world
	this.addObject3D( this.player.object3D );
};

/**
 * Adds a 3D object to the internal scene.
 * 
 * @param {THREE.Mesh} ground - The ground to add.
 */
World.prototype.addObject3D = function( object ) {

	this.scene.add( object );
};

/**
 * Removes a 3D object from the internal scene.
 * 
 * @param {THREE.Mesh} ground - The ground to add.
 */
World.prototype.removeObject3D = function( object ) {

	this.scene.remove( object );
};

/**
 * Removes all 3D object from the internal scene.
 */
World.prototype.removeObjects3D = function( object ) {

	this.scene.clear();
};

/**
 * Adds a ground to the internal array.
 * 
 * @param {THREE.Mesh} ground - The ground to add.
 */
World.prototype.addGround = function( ground ) {

	this.grounds.push( ground );

	// ground objects always needs to be added to the scene
	this.addObject3D( ground );
};

/**
 * Removes a ground from the internal array.
 * 
 * @param {THREE.Mesh} ground - The ground to remove.
 */
World.prototype.removeGround = function( ground ) {

	var index = this.grounds.indexOf( ground );
	this.grounds.splice( index, 1 );

	// ground objects always needs to be removed from the scene
	this.removeObject3D( ground );
};

/**
 * Removes all grounds from the internal array.
 */
World.prototype.removeGrounds = function() {

	for ( var index = this.grounds.length - 1; index >= 0; index-- )
	{
		this.removeGround( this.grounds[ index ] );
	}
};

/**
 * Adds a wall to the internal array.
 * 
 * @param {THREE.Mesh} wall - The wall to add.
 */
World.prototype.addWall = function( wall ) {

	this.walls.push( wall );

	// wall objects always needs to be added to the scene
	this.addObject3D( wall );
};

/**
 * Removes a wall from the internal array.
 * 
 * @param {THREE.Mesh} wall - The wall to remove.
 */
World.prototype.removeWall = function( wall ) {

	var index = this.walls.indexOf( wall );
	this.walls.splice( index, 1 );

	// wall objects always needs to be removed from the scene
	this.removeObject3D( wall );
};

/**
 * Removes all walls from the internal array.
 */
World.prototype.removeWalls = function() {

	for ( var index = this.walls.length - 1; index >= 0; index-- )
	{
		this.removeWall( this.walls[ index ] );
	}
};

/**
 * Calculates neighbors for a given vehicle.
 * 
 * @param {Vehicle} vehicle - The given vehicle.
 * @param {number} viewDistance - The view distance of the vehicle.
 * @param {object} neighbors - The calculated neighbors.
 */
World.prototype.calculateNeighbors = ( function() {

	var toEntity = new THREE.Vector3();

	return function( vehicle, viewDistance, neighbors ) {
		
		var index, entity;

		// reset array
		neighbors.length = 0;

		// iterate over all entities
		for ( index = 0; index < entityManager.entities.length; index++ )
		{
			entity = entityManager.entities[ index ];

			// in this case, the own vehicle AND the player will be ignored
			if ( entity !== vehicle && entity !== this.player )
			{
				// calculate displacement vector
				toEntity.subVectors( entity.position, vehicle.object3D.position );

				// if entity within range, push into neighbors array for further
				// consideration.
				if ( toEntity.lengthSq() < ( viewDistance * viewDistance ) )
				{
					neighbors.push( entity );
				}

			}
			
		}
		
	};

}() );

/**
 * Clears the world object.
 */
World.prototype.clear = function() {

	this.removeWalls();
	this.removeGrounds();
	this.removeObjects3D();
};

module.exports = new World();
},{"../action/ActionManager":5,"../game/entity/EntityManager":47,"../game/entity/GameEntity":48,"./Scene":24,"three":1}],32:[function(require,module,exports){
/**
 * @file This prototype handles all stuff for impostors. An impostor is a
 * billboard that is created on the fly by rendering a complex object from the
 * current viewpoint into an image texture, which is mapped on the billboard.
 * 
 * see: Real-Time Rendering, Third Edition, Akenine-Möller/Haines/Hoffman
 * Chapter 10.7.1, Impostors
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );
/**
 * Creates an impostor.
 * 
 * @constructor
 * 
 * @param {string} id - The id of the impostor.
 * @param {THREE.Object3D} sourceObject - The source 3D object of the impostor.
 * @param {number} resolution - The resolution of the rendered texture.
 * @param {number} angle - This value can be used to auto-generation the impostor.
 */
function Impostor( id, sourceObject, resolution, angle ) {

	Object.defineProperties( this, {
		idImpostor : {
			value : id,
			configurable : false,
			enumerable : true,
			writable : false
		},
		billboard : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		sourceObject : {
			value : sourceObject,
			configurable : false,
			enumerable : true,
			writable : false
		},
		resolution : {
			value : resolution || 128,
			configurable : false,
			enumerable : true,
			writable : true
		},
		angle : {
			value : angle || 30,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_renderTarget : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_boundingBox : {
			value : new THREE.Box3(),
			configurable : false,
			enumerable : false,
			writable : true
		},
		_boundingRectangle : {
			value : new THREE.Box2(),
			configurable : false,
			enumerable : false,
			writable : true
		},
		_depth : {
			value : Infinity,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_scene : {
			value : new THREE.Scene(),
			configurable : false,
			enumerable : false,
			writable : true
		},
		_camera : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_lastDirection : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// create render target
	this._renderTarget = new THREE.WebGLRenderTarget( this.resolution, this.resolution, {
		format : THREE.RGBAFormat,
		stencilBuffer : false
	} );

	// create the billboard
	this._createBillboard();
}

/**
 * Generates the impostor.
 * 
 * @param {Renderer} renderer - The renderer object.
 * @param {Camera} camera - The camera object.
 * @param {object} lights - The lights of the stage.
 */
Impostor.prototype.generate = function( renderer, camera, lights ) {

	// the matrices of the camera get transformed, so it's necessary to clone it
	this._camera = camera.clone();
	
	this._computeBoundingBox();

	this._computeViewMatrix();

	this._computeBoundingRectangle();

	this._computePosition();

	this._updateGeometry();

	this._computeProjectionMatrix();

	this._prepareScene( lights );

	this._render( renderer );
};

/**
 * Updates the model matrix of an impostor. The impostor is handled like a
 * viewpoint-oriented, axis-aligned billboard.
 * 
 * see: Real-Time Rendering, Third Edition, Akenine-Möller/Haines/Hoffman
 * Chapter 10.6.2, World-Oriented Billboards
 * 
 * @param {THREE.Vector3} cameraPosition - The position of the camera.
 * 
 */
Impostor.prototype.update = ( function() {

	var xAxis = new THREE.Vector3(); // right
	var yAxis = new THREE.Vector3( 0, 1, 0 ); // up
	var zAxis = new THREE.Vector3(); // front

	return function( cameraPosition ) {

		// first, compute zAxis
		zAxis.subVectors( cameraPosition, this.billboard.position );
		
		// this will ensure, that the impostor rotates correctly around the axis
		zAxis.y = 0;
		zAxis.normalize();

		// compute the last axis with the cross product
		xAxis.crossVectors( yAxis, zAxis );

		// create new model matrix from basis vectors
		this.billboard.matrix.makeBasis( xAxis, yAxis, zAxis );

		// apply the position
		this.billboard.matrix.setPosition( this.billboard.position );

		// force world matrix to update
		this.billboard.matrixWorldNeedsUpdate = true;
		
	};

}() );

/**
 * Checks, if it's necessary to generate the impostor.
 * 
 * @param {THREE.Vector3} direction - The current direction from impostor to
 * camera.
 * 
 * @returns {boolean} Is a generation necessary?
 */
Impostor.prototype.isGenerationNeeded = function( currentDirection ) {

	var angle;

	// if "lastDirection" is null, we have nothing to compare. so we just save
	// the current direction in this step
	if ( this._lastDirection === null )
	{
		this._lastDirection.copy( currentDirection );

	}
	else
	{
		// compute the angle between current and last direction
		angle = Math.acos( this._lastDirection.dot( currentDirection ) );

		// convert radians to degrees
		angle *= ( 180 / Math.PI );

		// check against property
		if ( angle > this.angle * 0.5 )
		{
			// save the direction
			this._lastDirection = currentDirection.clone();

			// return true to trigger a generation
			return true;
		}
	}

	return false;

};

/**
 * Creates the billboard of the impostor.
 */
Impostor.prototype._createBillboard = function() {

	// create billboard geometry
	var billboardGeomtry = new THREE.BufferGeometry();
	
	// create buffers
	var positionBuffer = new Float32Array( 12 );
	var uvBuffer = new Float32Array( [ 0, 0, 0, 1, 1, 0, 1, 1 ] );
	var indexBuffer = new Uint16Array( [ 0, 2, 1, 2, 3, 1 ] );

	// add buffers to geometry
	billboardGeomtry.addAttribute( "position", new THREE.BufferAttribute( positionBuffer, 3 ) );
	billboardGeomtry.addAttribute( "uv", new THREE.BufferAttribute( uvBuffer, 2 ) );
	billboardGeomtry.setIndex( new THREE.BufferAttribute( indexBuffer, 1 ) );

	// create billboard material. the alpha value avoids
	// semi-transparent black borders at the billboard
	var billboardMaterial = new THREE.MeshBasicMaterial( {
		map : this._renderTarget,
		transparent : true,
		alphaTest : 0.9
	} );

	// create billboard
	this.billboard = new THREE.Mesh( billboardGeomtry, billboardMaterial );

	// the model matrix is calculated by the impostor so disable the automatic
	// update
	this.billboard.matrixAutoUpdate = false;
};

/**
 * Computes the axis-aligned bounding box of the object.
 */
Impostor.prototype._computeBoundingBox = function() {

	this._boundingBox.setFromObject( this.sourceObject );
};

/**
 * Prepares the camera for rendering.
 */
Impostor.prototype._computeViewMatrix = function() {

	// the camera should look at the center of the AABB
	this._camera.lookAt( this._boundingBox.center() );

	// compute new matrices
	this._camera.updateMatrix();
	this._camera.updateMatrixWorld();
	this._camera.matrixWorldInverse.getInverse( this._camera.matrixWorld );
};

/**
 * Computes the bounding rectangle of the impostor. This 2D bounding box is the
 * impostor in screen-space.
 */
Impostor.prototype._computeBoundingRectangle = function() {

	var points = [ new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3() ];

	// calculate each point of the bounding box
	points[ 0 ].set( this._boundingBox.min.x, this._boundingBox.min.y, this._boundingBox.min.z );
	points[ 1 ].set( this._boundingBox.min.x, this._boundingBox.min.y, this._boundingBox.max.z );
	points[ 2 ].set( this._boundingBox.min.x, this._boundingBox.max.y, this._boundingBox.min.z );
	points[ 3 ].set( this._boundingBox.min.x, this._boundingBox.max.y, this._boundingBox.max.z );
	points[ 4 ].set( this._boundingBox.max.x, this._boundingBox.min.y, this._boundingBox.min.z );
	points[ 5 ].set( this._boundingBox.max.x, this._boundingBox.min.y, this._boundingBox.max.z );
	points[ 6 ].set( this._boundingBox.max.x, this._boundingBox.max.y, this._boundingBox.min.z );
	points[ 7 ].set( this._boundingBox.max.x, this._boundingBox.max.y, this._boundingBox.max.z );

	// reset values before calculating
	this._depth = Infinity;
	this._boundingRectangle.makeEmpty();

	// calculate the bounding rectangle and the minimum depth value
	for ( var index = 0; index < points.length; index++ )
	{
		// transform and project point from world to screen space
		points[ index ].project( this._camera );

		// compute the bounding rectangle in screen space
		this._boundingRectangle.expandByPoint( points[ index ] );

		// determine the minimum depth value
		this._depth = Math.min( this._depth, points[ index ].z );
	}
};

/**
 * Computes the position of the impostor. The center point of the bounding
 * rectangle in world space will provide the exact value.
 */
Impostor.prototype._computePosition = function() {

	// calculate center
	var centerScreenSpace = this._boundingRectangle.center();

	// use the center and the depth value to determine the new position of the
	// impostor in screen space
	var positionWorldSpace = new THREE.Vector3( centerScreenSpace.x, centerScreenSpace.y, this._depth );

	// unproject the vector to get world position
	this.billboard.position.copy( positionWorldSpace.unproject( this._camera ) );
};

/**
 * Updates the geometry of the impostor.
 */
Impostor.prototype._updateGeometry = ( function() {

	var translationMatrix = new THREE.Matrix4();
	var rotationMatrix = new THREE.Matrix4();

	// create point array
	var points = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	return function() {

		var index, positionBuffer;

		// shortcut to position buffer
		positionBuffer = this.billboard.geometry.attributes.position.array;

		// get the points of the bounding rectangle
		points[ 0 ].set( this._boundingRectangle.min.x, this._boundingRectangle.min.y, this._depth );
		points[ 1 ].set( this._boundingRectangle.min.x, this._boundingRectangle.max.y, this._depth );
		points[ 2 ].set( this._boundingRectangle.max.x, this._boundingRectangle.min.y, this._depth );
		points[ 3 ].set( this._boundingRectangle.max.x, this._boundingRectangle.max.y, this._depth );

		// set new position
		for ( index = 0; index < points.length; index++ )
		{
			// transform point from screen space to world space
			points[ index ].unproject( this._camera );

			// apply the position to the respective buffer
			positionBuffer[ index * 3 + 0 ] = points[ index ].x;
			positionBuffer[ index * 3 + 1 ] = points[ index ].y;
			positionBuffer[ index * 3 + 2 ] = points[ index ].z;
		}

		// we need to tell three.js to update the buffer
		this.billboard.geometry.attributes.position.needsUpdate = true;

		// prepare matrices
		translationMatrix.identity();
		rotationMatrix.identity();

		// reset the center of the geometry back to origin
		translationMatrix.makeTranslation( -this.billboard.position.x, -this.billboard.position.y, -this.billboard.position.z );

		// undo rotation of the view transform
		rotationMatrix.extractRotation( this._camera.matrixWorldInverse );

		// reset geometry
		this.billboard.geometry.applyMatrix( translationMatrix );
		this.billboard.geometry.applyMatrix( rotationMatrix );
	};

}() );

/**
 * Computes a projection matrix, that encloses the bounding rectangle of the
 * impostor.
 */
Impostor.prototype._computeProjectionMatrix = function() {

	// calculate frustum
	var frustumHeight = this._camera.near * Math.tan( THREE.Math.degToRad( this._camera.fov * 0.5 ) );
	var frustumWidth = frustumHeight * this._camera.aspect;

	// create new projection matrix via min/max values of the bounding rectangle
	this._camera.projectionMatrix.makeFrustum( frustumWidth  * this._boundingRectangle.min.x, 
											   frustumWidth  * this._boundingRectangle.max.x, 
											   frustumHeight * this._boundingRectangle.min.y, 
											   frustumHeight * this._boundingRectangle.max.y, 
											   this._camera.near, 
											   this._camera.far );
};

/**
 * Prepares the scene for rendering. This method ensures, that the actual object
 * and the entire lightning of the scene are part of the rendering.
 * 
 * @param {object} lights - The lights of the stage.
 */
Impostor.prototype._prepareScene = function( lights ) {

	// reset scene
	this._scene = new THREE.Scene();

	// clone object
	var object = this.sourceObject.clone();

	// ensure it's visible
	object.visible = true;

	// add to scene
	this._scene.add( object );

	// add all light sources
	Array.prototype.push.apply( this._scene.children, lights );
};

/**
 * Renders the scene to the render target.
 * 
 * @param {Renderer} renderer - The renderer object.
 */
Impostor.prototype._render = function( renderer ) {

	// save existing clear color and alpha
	var clearColor = renderer.getClearColor();
	var clearAlpha = renderer.getClearAlpha();

	// the following clear ensures that the rendered texture has transparency
	renderer.setClearColor( 0x000000, 0 );

	// render to target
	renderer.render( this._scene, this._camera, this._renderTarget, true );

	// restore clear values
	renderer.setClearColor( clearColor, clearAlpha );
};

module.exports = Impostor;
},{"three":1}],33:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for loading 3D objects in JSON-format from the server. The
 * objects are provided with Blender.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var system = require( "../core/System" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );
/**
 * Creates a JSONLoader.
 * 
 * @constructor
 * @augments THREE.JSONLoader
 * 
 */
function JSONLoader() {

	THREE.JSONLoader.call( this );

	this.crossOrigin = "anonymous";
	this.texturePath = "";
}

JSONLoader.prototype = Object.create( THREE.JSONLoader.prototype );
JSONLoader.prototype.constructor = JSONLoader;

/**
 * Loads a 3D object. Overwrites the standard method of three.js.
 * 
 * @param {string} url - The URL of the 3D object.
 * @param {function} onLoad - This callback function is executed, when the model
 * is loaded and parsed.
 */
JSONLoader.prototype.load = function( url, onLoad ) {

	var self = this;

	// build url
	url = system.cdn + url;

	// build texturePath
	if ( this.texturePath === "" )
	{
		this.texturePath = url.substring( 0, url.lastIndexOf( "/" ) + 1 );
	}

	// add nocache, if necessary
	if ( system.isDevModeActive === true )
	{
		url = url + "?" + new Date().getTime();
	}

	// create XMLHttpRequest object
	var xhr = new global.XMLHttpRequest();

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === xhr.DONE )
		{
			if ( xhr.status === 200 )
			{
				if ( xhr.responseText )
				{
					// parse result
					var result = self.parse( JSON.parse( xhr.responseText ), self.texturePath );

					// execute callback
					onLoad( result.geometry, result.materials );

					// publish message
					eventManager.publish( TOPIC.STAGE.LOADING.COMPLETE.OBJECT, {
						url : url
					} );
					
				}
				else
				{
					throw "ERROR: JSONLoader: '" + url + "' seems to be unreachable or the file is empty.";
				}
			}
			else
			{
				throw "ERROR: JSONLoader: Could not load '" + url + "' (Status: " + xhr.status + ").";
			}

		}
	};

	// start request
	xhr.open( 'GET', url, true );
	xhr.withCredentials = true;
	xhr.send();

	// publish message to inform about status
	eventManager.publish( TOPIC.STAGE.LOADING.START.OBJECT, {
		url : url
	} );
};

module.exports = JSONLoader;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/System":27,"../messaging/EventManager":69,"../messaging/Topic":71,"three":1}],34:[function(require,module,exports){
/**
 * @file This prototype is used for LOD handling. It is an enhancement of the
 * LOD functionality of three.js. Instead of switching directly between LOD
 * objects, this prototype uses a linear blend over a short period of time. This
 * approach provides a smoother switch and so avoids popping.
 * 
 * see: Real-Time Rendering, Third Edition, Akenine-Möller/Haines/Hoffman
 * Chapter 14.7.1, LOD Switching, Blend LODs
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );
/**
 * Creates a LOD instance.
 * 
 * @constructor
 * @augments THREE.LOD
 * 
 * @param {string} id - The id of the LOD instance.
 * @param {number} mode - The transition mode.
 * @param {Camera} camera - The camera object.
 * @param {number} threshold - The threshold where the blending is done.
 */
function LOD( id, mode, camera, threshold ) {

	THREE.LOD.call( this );

	Object.defineProperties( this, {
		idLOD : {
			value : id,
			configurable : false,
			enumerable : true,
			writable : false
		},
		mode : {
			value : mode || LOD.MODE.DIRECT,
			configurable : false,
			enumerable : true,
			writable : true
		},
		camera : {
			value : camera,
			configurable : false,
			enumerable : true,
			writable : true
		},
		threshold : {
			value : threshold || 0,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

LOD.prototype = Object.create( THREE.LOD.prototype );
LOD.prototype.constructor = LOD;

/**
 * Updates the LOD instance. Overwrites the standard method of three.js.
 * 
 * @param {Camera} camera - The camera object.
 */
LOD.prototype.update = ( function() {

	var positionCamera = new THREE.Vector3();
	var positionObject = new THREE.Vector3();

	return function() {
		
		var distance; // calculated distance
		var edge; // this distance marks the begin/end of the transition
		var opacity; // opacity value for blending
		var index; // index for loops
		var currentObject; // current object of the loop
		var previousObject; // previous object of the loop

		if ( this.mode === LOD.MODE.DIRECT )
		{
			// process code of parent prototype
			THREE.LOD.prototype.update.call( this, this.camera );

		}
		else if ( this.mode === LOD.MODE.SMOOTH )
		{
			// process LOD selection only if there are at least two objects
			if ( this.levels.length > 1 )
			{
				// get position of the camera and the LOD instance
				positionCamera.setFromMatrixPosition( this.camera.matrixWorld );
				positionObject.setFromMatrixPosition( this.matrixWorld );

				// calculate distance between camera and LOD instance
				distance = positionCamera.distanceTo( positionObject );

				// set first LOD object always visible and opaque
				this.levels[ 0 ].object.visible = true;
				this.levels[ 0 ].object.material.transparent = false;
				this.levels[ 0 ].object.material.opacity = 1;

				// start the iteration with the second object in the array
				for ( index = 1; index < this.levels.length; index++ )
				{
					// save current object
					currentObject = this.levels[ index ];
					previousObject = this.levels[ index - 1 ];

					// if the calculated distance is smaller than the
					// LOD-distance but greater than the threshold,
					// show the new object smoothly
					if ( distance < currentObject.distance && distance >= ( currentObject.distance - this.threshold ) )
					{
						edge = currentObject.distance - this.threshold;
						opacity = Math.min( ( distance - edge ) / this.threshold, 1 );

						currentObject.object.visible = true;
						currentObject.object.material.transparent = true;
						currentObject.object.material.opacity = opacity;

						previousObject.object.material.transparent = false;
						previousObject.object.material.opacity = 1;

						// if the calculated distance is greater than the
						// LOD-distance but smaller than the threshold,
						// hide the old object smoothly
					}
					else if ( distance >= currentObject.distance && distance < ( currentObject.distance + this.threshold ) )
					{
						edge = currentObject.distance + this.threshold;
						opacity = Math.max( ( edge - distance ) / this.threshold, 0 );

						currentObject.object.material.opacity = 1;
						currentObject.object.material.transparent = false;

						previousObject.object.material.transparent = true;
						previousObject.object.material.opacity = opacity;
					}

					// if the calculated distance is greater than the
					// LOD-distance plus the threshold, show/ hide fully the
					// objects
					else if ( distance >= currentObject.distance + this.threshold )
					{
						currentObject.object.visible = true;
						previousObject.object.visible = false;
					}

					// if no condition is true, exit the loop
					// this happens when the camera is very close to the LOD
					// instance so the object with the highest details is chosen
					else
					{
						break;
					}

				}

				// hide all subsequent levels and reset values
				// we use the index of the previous loop
				for ( ; index < this.levels.length; index++ )
				{
					this.levels[ index ].object.visible = false;
					this.levels[ index ].object.material.transparent = false;
					this.levels[ index ].object.material.opacity = 1;
				}
			}
		}
	};
	
}() );

LOD.MODE = {
	DIRECT : 0,
	SMOOTH : 1
};

module.exports = LOD;
},{"three":1}],35:[function(require,module,exports){
/**
 * @file This prototype manages the characters of the other teammates.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var Teammate = require( "./Teammate" );
var world = require( "../core/World" );
var logger = require( "../core/Logger" );

var self;
/**
 * Creates a multiplayer manager instance.
 * 
 * @constructor
 * 
 */
function MultiplayerManager() {

	Object.defineProperties( this, {
		_teammates : {
			value : [],
			configurable : false,
			enumerable : true,
			writable : false
		}
	} );

	self = this;
}

/**
 * Inits the multiplayer logic.
 */
MultiplayerManager.prototype.init = function() {

	eventManager.subscribe( TOPIC.MULTIPLAYER.UPDATE, this._onUpdate );
	eventManager.subscribe( TOPIC.MULTIPLAYER.STATUS, this._onStatus );
};

/**
 * This method is used update the world information of other teammates.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
MultiplayerManager.prototype._onUpdate = ( function() {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();

	return function( message, data ) {

		// get correct teammate
		var teammate = self._getTeammate( data.clientId );

		// process position and orientation
		position.set( data.player.position.x, data.player.position.y, data.player.position.z );
		quaternion.set( data.player.quaternion._x, data.player.quaternion._y, data.player.quaternion._z, data.player.quaternion._w );

		// update teammate
		teammate.update( position, quaternion );
	};

} )();

/**
 * This method is used to update the status of other teammates.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
MultiplayerManager.prototype._onStatus = function( message, data ) {

	var teammate = null;

	if ( data.online === true )
	{
		// create mesh for teammate
		var mesh = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ),  new THREE.MeshBasicMaterial( {color : "#ff0000"} ) );
		
		// create new teammate
		teammate = new Teammate( data.clientId, mesh );

		// add teammate
		self._addTeammate( teammate );

		// logging
		logger.log( "INFO: MultiplayerManager: Teammate with ID %i online.", data.clientId );

	}
	else
	{
		// get the teammate by its id
		teammate = self._getTeammate( data.clientId );

		// remove teammate
		self._removeTeammate( teammate );

		// logging
		logger.log( "INFO: MultiplayerManager: Teammate with ID %i offline.", data.clientId );

	}
};

/**
 * Adds a teammate object.
 * 
 * @param {Teammate} teammate - The teammate object to be added.
 */
MultiplayerManager.prototype._addTeammate = function( teammate ) {

	// add to internal array
	this._teammates.push( teammate );

	// add to world
	world.addObject3D( teammate.object3D );
};

/**
 * Removes a teammate.
 * 
 * @param {Teammate} teammate - The teammate object to be removed.
 */
MultiplayerManager.prototype._removeTeammate = function( teammate ) {

	// remove from array
	var index = this._teammates.indexOf( teammate );
	this._teammates.splice( index, 1 );

	// remove from world
	world.removeObject3D( teammate.object3D );
};

/**
 * Gets a teammate of the internal array.
 * 
 * @param {number} id - The id of the teammate.
 * 
 * @returns {Teammate} The teammate.
 */
MultiplayerManager.prototype._getTeammate = function( id ) {

	var teammate = null;

	for ( var index = 0; index < this._teammates.length; index++ )
	{
		if ( this._teammates[ index ].multiplayerId === id )
		{
			teammate = this._teammates[ index ];

			break;
		}
	}

	if ( teammate === null )
	{
		throw "ERROR: MultiplayerManager: Teammate with ID " + id + " not existing.";
	}
	else
	{
		return teammate;
	}
};

module.exports = new MultiplayerManager();
},{"../core/Logger":21,"../core/World":31,"../messaging/EventManager":69,"../messaging/Topic":71,"./Teammate":43,"three":1}],36:[function(require,module,exports){
/**
 * @file A 3D arbitrarily oriented bounding box.
 * 
 * This data structure represents a box in 3D space. The local axes of this box
 * can be arbitrarily oriented/rotated with respect to the global world
 * coordinate system. This allows OBBs to more tightly bound objects than AABBs
 * do, which always align with the world space axes. This flexibility has the
 * drawback that the geometry tests and operations involving OBBs are more
 * costly, and representing an OBB in memory takes more space.
 * 
 * Reference:
 * 
 * This file is a JavaScript/three.js implementation of the MathGeoLib by Jukka
 * Jylänki. The prototype does not contain the entire logic of the original
 * source.
 * 
 * https://github.com/juj/MathGeoLib/blob/master/src/Geometry/OBB.h
 * https://github.com/juj/MathGeoLib/blob/master/src/Geometry/OBB.cpp
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

/**
 * Creates the OBB.
 * 
 * @constructor
 * 
 * @param {THREE.Vector3} position - The center position of the OBB.
 * @param {THREE.Vector3} halfSizes - Stores half-sizes to x, y and z directions
 * in the local space of the OBB.
 * @param {THREE.Matrix4} basis - Specifies normalized direction vectors for the
 * local axes.
 */
function OBB( position, halfSizes, basis ) {

	Object.defineProperties( this, {
		position : {
			value : position || new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		halfSizes : {
			value : halfSizes || new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		basis : {
			value : basis || new THREE.Matrix4(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// The OBB-OBB test utilizes a SAT test to detect the intersection.
		// A robust implementation requires an epsilon threshold to test that
		// the used axes are not degenerate.
		_EPSILON : {
			value : 1e-3,
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
}

/**
 * Sets the OBB from a mesh.
 * 
 * The basis of the objects world matrix is assumed to be orthogonal, which
 * means no projection or shear is allowed. Additionally, the matrix must
 * contain only uniform scaling.
 * 
 * @param {THREE.Mesh} object - The mesh object to convert to an OBB.
 * 
 * @returns {OBB} The reference to the OBB.
 */
OBB.prototype.setFromObject = ( function() {

	var vector = new THREE.Vector3();

	return function( object ) {
		
		var scale, aabb, w;

		// calculate AABB, if necessary
		if ( object.geometry.boundingBox === null )
		{
			object.geometry.computeBoundingBox();
		}

		// ensure, world matrix of the object is up to date
		object.updateMatrixWorld();

		// shortcuts
		aabb = object.geometry.boundingBox;
		w = object.matrixWorld.elements;

		// assign the transform center to the position member
		aabb.center( this.position ).applyMatrix4( object.matrixWorld );

		// extract the rotation and assign it to the basis of the OBB
		// for numerical stability, you could orthonormalize the basis
		this.basis.extractRotation( object.matrixWorld );

		// calculate half sizes for each axis
		aabb.size( this.halfSizes ).multiplyScalar( 0.5 );

		// extract the (uniform) scaling and apply it to the halfSizes
		scale = vector.set( w[ 0 ], w[ 1 ], w[ 2 ] ).length();

		// do the scale
		this.halfSizes.multiplyScalar( scale );

		return this;
	};

}() );

/**
 * Sets the OBB from an Axis-Aligned Bounding Box (AABB).
 * 
 * @param {THREE.Box3} aabb - The AABB to convert to an OBB.
 * 
 * @returns {OBB} The reference to the OBB.
 */
OBB.prototype.setFromAABB = function( aabb ) {

	aabb.center( this.position );

	aabb.size( this.halfSizes ).multiplyScalar( 0.5 );

	this.basis.identity();

	return this;
};

/**
 * Sets the OBB from a bounding sphere.
 * 
 * @param {THREE.Sphere} sphere - The bounding sphere to convert to an OBB.
 * 
 * @returns {OBB} The reference to the OBB.
 */
OBB.prototype.setFromSphere = function( sphere ) {

	this.position.copy( sphere.center );

	this.halfSizes.set( sphere.radius, sphere.radius, sphere.radius );

	this.basis.identity();

	return this;
};

/**
 * Computes the closest point inside the OBB to the given point.
 * 
 * @param {THREE.Vector3} point - The target point.
 * 
 * @returns {THREE.Vector3} The closest point inside the OBB.
 */
OBB.prototype.closestPoint = ( function() {

	var displacement = new THREE.Vector3();

	var xAxis = new THREE.Vector3();
	var yAxis = new THREE.Vector3();
	var zAxis = new THREE.Vector3();

	return function( point ) {
		
		var index, value, axis = [];

		var closesPoint = new THREE.Vector3();

		// extract each axis
		this.basis.extractBasis( xAxis, yAxis, zAxis );

		// push axis to array
		axis.push( xAxis, yAxis, zAxis );

		// calculate displacement vector of targetPoint and center position
		displacement.subVectors( point, this.position );

		// start at the center position of the OBB
		closesPoint.copy( this.position );

		// project the target onto the OBB axes and walk towards that point
		for ( index = 0; index < 3; index++ )
		{
			value = THREE.Math.clamp( displacement.dot( axis[ index ] ), -this.halfSizes.getComponent( index ), this.halfSizes.getComponent( index ) );

			closesPoint.add( axis[ index ].multiplyScalar( value ) );
		}

		return closesPoint;
	};

}() );

/**
 * Tests if the given point is fully contained inside the OBB.
 * 
 * @param {THREE.Vector3} point - The point to test.
 * 
 * @returns {boolean} Is the point contained inside the OBB?
 */
OBB.prototype.isPointContained = ( function() {

	var displacement = new THREE.Vector3();

	var xAxis = new THREE.Vector3();
	var yAxis = new THREE.Vector3();
	var zAxis = new THREE.Vector3();

	return function( point ) {

		// calculate displacement vector of point and center position
		displacement.subVectors( point, this.position );

		// extract each axis
		this.basis.extractBasis( xAxis, yAxis, zAxis );

		// project the calculated displacement vector to each axis and
		// compare the result with the respective half size.
		return Math.abs( displacement.dot( xAxis ) ) <= this.halfSizes.x && 
			   Math.abs( displacement.dot( yAxis ) ) <= this.halfSizes.y && 
			   Math.abs( displacement.dot( zAxis ) ) <= this.halfSizes.z;
	};

}() );

/**
 * Tests if the given AABB is fully contained inside the OBB.
 * 
 * @param {THREE.Box3} aabb - The AABB to test.
 * 
 * @returns {boolean} Is the AABB fully contained inside the OBB?
 */
OBB.prototype.isAABBContained = ( function() {

	var points = [ new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3(), 
	               new THREE.Vector3() ];

	return function( aabb ) {

		// determine all corner points
		points[ 0 ].set( aabb.min.x, aabb.min.y, aabb.min.z );
		points[ 1 ].set( aabb.min.x, aabb.min.y, aabb.max.z );
		points[ 2 ].set( aabb.min.x, aabb.max.y, aabb.min.z );
		points[ 3 ].set( aabb.min.x, aabb.max.y, aabb.max.z );
		points[ 4 ].set( aabb.max.x, aabb.min.y, aabb.min.z );
		points[ 5 ].set( aabb.max.x, aabb.min.y, aabb.max.z );
		points[ 6 ].set( aabb.max.x, aabb.max.y, aabb.min.z );
		points[ 7 ].set( aabb.max.x, aabb.max.y, aabb.max.z );

		for ( var index = 0; index < 8; ++index )
		{
			// check each point
			if ( this.isPointContained( points[ index ] ) === false )
			{
				// as soon as one point is outside the OBB, return false
				return false;
			}
		}

		return true;
	};

}() );

/**
 * Tests if the given line segment is fully contained inside the OBB.
 * 
 * @param {THREE.Line3} line - The line segment to test.
 * 
 * @returns {boolean} Is the line segment contained inside the OBB?
 */
OBB.prototype.isLineContained = function( line ) {

	return this.isPointContained( line.start ) && 
		   this.isPointContained( line.end );
};

/**
 * Tests if the given triangle is fully contained inside the OBB.
 * 
 * @param {THREE.Triangle} triangle - The triangle to test.
 * 
 * @returns {boolean} Is the triangle contained inside the OBB?
 */
OBB.prototype.isTriangleContained = function( triangle ) {

	return this.isPointContained( triangle.a ) && 
		   this.isPointContained( triangle.b ) && 
		   this.isPointContained( triangle.c );
};

/**
 * Tests whether this OBB and the given AABB intersect.
 * 
 * @param {THREE.Box3} box - The AABB to test.
 * 
 * @returns {boolean} Is there an intersection between the given AABB and the
 * OBB?
 */
OBB.prototype.isIntersectionAABB = function( box ) {

	return this.isIntersectionOBB( new OBB().setFromAABB( box ) );
};

/**
 * Tests whether this OBB and the given sphere intersect.
 * 
 * @param {THREE.Sphere} sphere - The sphere to test.
 * 
 * @returns {boolean} Is there an intersection between the given sphere and the
 * OBB?
 */
OBB.prototype.isIntersectionSphere = function( sphere ) {

	return this.intersectSphere( sphere ) !== null;
};

/**
 * Tests whether this OBB and the given OBB intersect.
 * 
 * @param {OBB} box - The OBB to test.
 * 
 * @returns {boolean} Is there an intersection between the given OBB and the
 * OBB?
 */
OBB.prototype.isIntersectionOBB = ( function() {

	var xAxisA = new THREE.Vector3();
	var yAxisA = new THREE.Vector3();
	var zAxisA = new THREE.Vector3();

	var xAxisB = new THREE.Vector3();
	var yAxisB = new THREE.Vector3();
	var zAxisB = new THREE.Vector3();

	var translation = new THREE.Vector3();

	var vector = new THREE.Vector3();

	return function( obb ) {
		
		var axisA = [];
		var axisB = [];
		var rotationMatrix = [ [], [], [] ];
		var rotationMatrixAbs = [ [], [], [] ];
		
		var halfSizeA, halfSizeB;
		var t, i;

		// extract each axis
		this.basis.extractBasis( xAxisA, yAxisA, zAxisA );
		obb.basis.extractBasis( xAxisB, yAxisB, zAxisB );

		// push basis vectors into arrays, so you can access them via indices
		axisA.push( xAxisA, yAxisA, zAxisA );
		axisB.push( xAxisB, yAxisB, zAxisB );

		// get displacement vector
		vector.subVectors( obb.position, this.position );

		// express the translation vector in the coordinate frame of the current
		// OBB (this)
		for ( i = 0; i < 3; i++ )
		{
			translation.setComponent( i, vector.dot( axisA[ i ] ) );
		}

		// generate a rotation matrix that transforms from world space to the
		// OBB's coordinate space
		for ( i = 0; i < 3; i++ )
		{
			for ( var j = 0; j < 3; j++ )
			{
				rotationMatrix[ i ][ j ] = axisA[ i ].dot( axisB[ j ] );
				rotationMatrixAbs[ i ][ j ] = Math.abs( rotationMatrix[ i ][ j ] ) + this._EPSILON;
			}
		}

		// test the three major axes of this OBB
		for ( i = 0; i < 3; i++ )
		{
			vector.set( rotationMatrixAbs[ i ][ 0 ], rotationMatrixAbs[ i ][ 1 ], rotationMatrixAbs[ i ][ 2 ] );

			halfSizeA = this.halfSizes.getComponent( i );
			halfSizeB = obb.halfSizes.dot( vector );

			if ( Math.abs( translation.getComponent( i ) ) > halfSizeA + halfSizeB )
			{
				return false;
			}
		}

		// test the three major axes of other OBB
		for ( i = 0; i < 3; i++ )
		{
			vector.set( rotationMatrixAbs[ 0 ][ i ], rotationMatrixAbs[ 1 ][ i ], rotationMatrixAbs[ 2 ][ i ] );

			halfSizeA = this.halfSizes.dot( vector );
			halfSizeB = obb.halfSizes.getComponent( i );

			vector.set( rotationMatrix[ 0 ][ i ], rotationMatrix[ 1 ][ i ], rotationMatrix[ 2 ][ i ] );
			t = translation.dot( vector );

			if ( Math.abs( t ) > halfSizeA + halfSizeB )
			{
				return false;
			}
		}

		// test the 9 different cross-axes

		// A.x <cross> B.x
		halfSizeA = this.halfSizes.y * rotationMatrixAbs[ 2 ][ 0 ] + this.halfSizes.z * rotationMatrixAbs[ 1 ][ 0 ];
		halfSizeB = obb.halfSizes.y * rotationMatrixAbs[ 0 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 0 ][ 1 ];

		t = translation.z * rotationMatrix[ 1 ][ 0 ] - translation.y * rotationMatrix[ 2 ][ 0 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.x < cross> B.y
		halfSizeA = this.halfSizes.y * rotationMatrixAbs[ 2 ][ 1 ] + this.halfSizes.z * rotationMatrixAbs[ 1 ][ 1 ];
		halfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 0 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 0 ][ 0 ];

		t = translation.z * rotationMatrix[ 1 ][ 1 ] - translation.y * rotationMatrix[ 2 ][ 1 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.x <cross> B.z
		halfSizeA = this.halfSizes.y * rotationMatrixAbs[ 2 ][ 2 ] + this.halfSizes.z * rotationMatrixAbs[ 1 ][ 2 ];
		halfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 0 ][ 1 ] + obb.halfSizes.y * rotationMatrixAbs[ 0 ][ 0 ];

		t = translation.z * rotationMatrix[ 1 ][ 2 ] - translation.y * rotationMatrix[ 2 ][ 2 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.y <cross> B.x
		halfSizeA = this.halfSizes.x * rotationMatrixAbs[ 2 ][ 0 ] + this.halfSizes.z * rotationMatrixAbs[ 0 ][ 0 ];
		halfSizeB = obb.halfSizes.y * rotationMatrixAbs[ 1 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 1 ][ 1 ];

		t = translation.x * rotationMatrix[ 2 ][ 0 ] - translation.z * rotationMatrix[ 0 ][ 0 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.y <cross> B.y
		halfSizeA = this.halfSizes.x * rotationMatrixAbs[ 2 ][ 1 ] + this.halfSizes.z * rotationMatrixAbs[ 0 ][ 1 ];
		halfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 1 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 1 ][ 0 ];

		t = translation.x * rotationMatrix[ 2 ][ 1 ] - translation.z * rotationMatrix[ 0 ][ 1 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.y <cross> B.z
		halfSizeA = this.halfSizes.x * rotationMatrixAbs[ 2 ][ 2 ] + this.halfSizes.z * rotationMatrixAbs[ 0 ][ 2 ];
		halfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 1 ][ 1 ] + obb.halfSizes.y * rotationMatrixAbs[ 1 ][ 0 ];

		t = translation.x * rotationMatrix[ 2 ][ 2 ] - translation.z * rotationMatrix[ 0 ][ 2 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.z <cross> B.x
		halfSizeA = this.halfSizes.x * rotationMatrixAbs[ 1 ][ 0 ] + this.halfSizes.y * rotationMatrixAbs[ 0 ][ 0 ];
		halfSizeB = obb.halfSizes.y * rotationMatrixAbs[ 2 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 2 ][ 1 ];

		t = translation.y * rotationMatrix[ 0 ][ 0 ] - translation.x * rotationMatrix[ 1 ][ 0 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.z <cross> B.y
		halfSizeA = this.halfSizes.x * rotationMatrixAbs[ 1 ][ 1 ] + this.halfSizes.y * rotationMatrixAbs[ 0 ][ 1 ];
		halfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 2 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 2 ][ 0 ];

		t = translation.y * rotationMatrix[ 0 ][ 1 ] - translation.x * rotationMatrix[ 1 ][ 1 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// A.z <cross> B.z
		halfSizeA = this.halfSizes.x * rotationMatrixAbs[ 1 ][ 2 ] + this.halfSizes.y * rotationMatrixAbs[ 0 ][ 2 ];
		halfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 2 ][ 1 ] + obb.halfSizes.y * rotationMatrixAbs[ 2 ][ 0 ];

		t = translation.y * rotationMatrix[ 0 ][ 2 ] - translation.x * rotationMatrix[ 1 ][ 2 ];

		if ( Math.abs( t ) > halfSizeA + halfSizeB )
		{
			return false;
		}

		// no separating axis exists, so the two OBB don't intersect
		return true;
	};

}() );

/**
 * Tests whether this OBB and the given plane intersect.
 * 
 * @param {THREE.Plane} plane - The plane to test.
 * 
 * @returns {boolean} Is there an intersection between the given plane and the
 * OBB?
 */
OBB.prototype.isIntersectionPlane = ( function() {

	var xAxis = new THREE.Vector3();
	var yAxis = new THREE.Vector3();
	var zAxis = new THREE.Vector3();

	return function( plane ) {
		
		var t, s;

		// extract each axis
		this.basis.extractBasis( xAxis, yAxis, zAxis );

		// compute the projection interval radius of this OBB onto L(t) =
		// this->pos + x * p.normal;
		t = this.halfSizes.x * Math.abs( plane.normal.dot( xAxis ) ) + 
			this.halfSizes.y * Math.abs( plane.normal.dot( yAxis ) ) + 
			this.halfSizes.z * Math.abs( plane.normal.dot( zAxis ) );

		// compute the distance of this OBB center from the plane
		s = plane.normal.dot( this.position ) - plane.constant;

		return Math.abs( s ) <= t;
	};

}() );

/**
 * Tests whether this OBB and the given ray intersect.
 * 
 * @param {THREE.Ray} ray - The ray to test.
 * 
 * @returns {boolean} Is there an intersection between the given ray and the
 * OBB?
 */
OBB.prototype.isIntersectionRay = function( ray ) {

	return this.intersectRay( ray ) !== null;
};

/**
 * Calculates the intersection point between this OBB and the given ray.
 * 
 * @param {THREE.Ray} ray - The ray to test.
 * 
 * @returns {THREE.Vector3} The intersection point.
 */
OBB.prototype.intersectRay = ( function() {

	var zeroVector = new THREE.Vector3();
	var size = new THREE.Vector3();
	var aabb = new THREE.Box3();
	var rayLocal = new THREE.Ray();

	var transformationMatrix = new THREE.Matrix4();
	var transformationMatrixInverse = new THREE.Matrix4();

	return function( ray ) {

		var intersection;
		
		// get size of OBB
		this.size( size );

		// set AABB to origin with the size of the OBB
		aabb.setFromCenterAndSize( zeroVector, size );

		// transform ray to the local space of the OBB
		transformationMatrix.copy( this.basis );
		transformationMatrix.setPosition( this.position );

		rayLocal.copy( ray );
		rayLocal.applyMatrix4( transformationMatrixInverse.getInverse( transformationMatrix ) );

		// do ray <-> AABB intersection
		intersection = rayLocal.intersectBox( aabb );

		if ( intersection !== null )
		{
			// transform the intersection point back to world space
			intersection.applyMatrix4( transformationMatrix );
		}

		return intersection;
	};

}() );

/**
 * Calculates the intersection point between this OBB and the given sphere.
 * 
 * @param {THREE.Sphere} sphere - The sphere to test.
 * 
 * @returns {THREE.Vector3} The intersection point.
 */
OBB.prototype.intersectSphere = function( sphere ) {

	// find the point on this OBB closest to the sphere center
	var closestPoint = this.closestPoint( sphere.center );

	// if that point is inside the sphere, the OBB and sphere intersect
	if ( closestPoint.distanceToSquared( sphere.center ) <= sphere.radius * sphere.radius )
	{
		return closestPoint;
	}

	return null;
};

/**
 * Gets the size of the OBB.
 * 
 * @param {THREE.Vector3} optionalTarget - An optional target for the operation.
 * 
 * @returns {THREE.Vector3} The size of the OBB.
 */
OBB.prototype.size = function( optionalTarget ) {
	
	var result = optionalTarget || new THREE.Vector3();

	return result.copy( this.halfSizes ).multiplyScalar( 2 );
};

/**
 * Translates the OBB in world space.
 * 
 * @param {THREE.Vector3} offset - The amount of displacement to apply to this
 * OBB, in world space coordinates.
 * 
 * @returns {OBB} The reference to the OBB.
 */
OBB.prototype.translate = function( offset ) {

	this.position.add( offset );

	return this;
};

/**
 * Copies the values of a given OBB to the current OBB.
 * 
 * @param {OBB} obb - The OBB to copy.
 * 
 * @returns {OBB} The reference to the OBB.
 */
OBB.prototype.copy = function( obb ) {

	this.position.copy( obb.position );
	this.halfSizes.copy( obb.halfSizes );
	this.basis.copy( obb.basis );

	return this;
};

/**
 * Creates a new instance from the current OBB.
 * 
 * @returns {OBB} The new OBB.
 */
OBB.prototype.clone = function() {

	return new OBB().copy( this );
};

module.exports = OBB;
},{"three":1}],37:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for loading 3D objects in object-format from the server. The
 * objects are provided with Blender.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var system = require( "../core/System" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

/**
 * Creates a ObjectLoader.
 * 
 * @constructor
 * @augments THREE.ObjectLoader
 * 
 */
function ObjectLoader() {

	THREE.ObjectLoader.call( this );

	this.crossOrigin = "anonymous";
}

ObjectLoader.prototype = Object.create( THREE.ObjectLoader.prototype );
ObjectLoader.prototype.constructor = ObjectLoader;

/**
 * Loads a 3D object. Overwrites the standard method of three.js.
 * 
 * @param {string} url - The URL of the 3d object.
 * @param {function} onLoad - This callback function is executed, when the model
 * is loaded and parsed.
 */
ObjectLoader.prototype.load = function( url, onLoad ) {

	var self = this;

	// build url
	url = system.cdn + url;

	// build texturePath
	if ( this.texturePath === "" )
	{
		this.texturePath = url.substring( 0, url.lastIndexOf( "/" ) + 1 );
	}

	// add nocache, if necessary
	if ( system.isDevModeActive === true )
	{
		url = url + "?" + new Date().getTime();
	}

	// create XMLHttpRequest object
	var xhr = new global.XMLHttpRequest();

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === xhr.DONE )
		{
			if ( xhr.status === 200 )
			{
				if ( xhr.responseText )
				{
					// parse result
					self.parse( JSON.parse( xhr.responseText ), onLoad );

					// publish message
					eventManager.publish( TOPIC.STAGE.LOADING.COMPLETE.OBJECT, {
						url : url
					} );

				}
				else
				{
					throw "ERROR: ObjectLoader: '" + url + "' seems to be unreachable or the file is empty.";
				}
			}
			else
			{
				throw "ERROR: ObjectLoader: Could not load '" + url + "' (Status: " + xhr.status + ").";
			}
		}
	};

	// start request
	xhr.open( 'GET', url, true );
	xhr.withCredentials = true;
	xhr.send();

	// publish message to inform about status
	eventManager.publish( TOPIC.STAGE.LOADING.START.OBJECT, {
		url : url
	} );
};

module.exports = ObjectLoader;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/System":27,"../messaging/EventManager":69,"../messaging/Topic":71,"three":1}],38:[function(require,module,exports){
/**
 * @file Interface for performance handling. This prototype is used in stages to
 * create e.g. LOD instances.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var LOD = require( "./LOD" );
var Impostor = require( "./Impostor" );

var camera = require( "../core/Camera" );
var world = require( "../core/World" );
var renderer = require( "../core/Renderer" );

/**
 * Creates the performance manager.
 * 
 * @constructor
 */
function PerformanceManager() {

	Object.defineProperties( this, {
		_lods : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		_impostors : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		_impostorCamera : {
			value : new THREE.PerspectiveCamera(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		_impostorLights : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
}

/**
 * Creates a LOD instance with direct transitions and stores it to the internal
 * array.
 * 
 * @param {string} id - The id of the LOD instance.
 * 
 * @returns {LOD} The new LOD instance.
 */
PerformanceManager.prototype.createDirectLOD = function( id ) {

	var lod = new LOD( id, LOD.MODE.DIRECT, camera );
	this.addLOD( lod );
	return lod;
};

/**
 * Creates a LOD instance with smooth transitions and stores it to the internal
 * array.
 * 
 * @param {string} id - The id of the LOD instance.
 * @param {number} threshold - The threshold where the blending is done.
 * 
 * @returns {LOD} The new LOD instance.
 */
PerformanceManager.prototype.createSmoothLOD = function( id, threshold ) {

	var lod = new LOD( id, LOD.MODE.SMOOTH, camera, threshold );
	this.addLOD( lod );
	return lod;
};

/**
 * Creates an impostor instance and stores it to the internal array.
 * 
 * @param {string} id - The id of the impostor instance.
 * @param {THREE.Mesh} object - The source 3D object of the impostor.
 * @param {number} resolution - The resolution of the rendered texture.
 * 
 * @returns {Impostor} The new impostor instance.
 */
PerformanceManager.prototype.createImpostor = function( id, object, resolution ) {

	var impostor = new Impostor( id, object, resolution );
	this.addImpostor( impostor );
	return impostor;
};

/**
 * Adds a single LOD instance to the internal array.
 * 
 * @param {LOD} lod - The LOD instance to be added.
 */
PerformanceManager.prototype.addLOD = function( lod ) {

	this._lods.push( lod );
};

/**
 * Adds a single impostor instance to the internal array.
 * 
 * @param {Impostor} impostor - The impostor instance to be added.
 */
PerformanceManager.prototype.addImpostor = function( impostor ) {

	this._impostors.push( impostor );
};

/**
 * Removes a LOD instance from the internal array.
 * 
 * @param {LOD} lod - The LOD instance to be removed.
 */
PerformanceManager.prototype.removeLOD = function( lod ) {

	var index = this._lods.indexOf( lod );
	this._lods.splice( index, 1 );
};

/**
 * Removes an impostor instance from the internal array.
 * 
 * @param {Impostor} impostor - The impostor instance to be removed.
 */
PerformanceManager.prototype.removeImpostor = function( impostor ) {

	var index = this._impostors.indexOf( impostor );
	this._impostors.splice( index, 1 );
};

/**
 * Removes all LOD instances from the internal array.
 */
PerformanceManager.prototype.removeLODs = function() {

	this._lods.length = 0;
};

/**
 * Removes all impostor instances from the internal array.
 */
PerformanceManager.prototype.removeImpostors = function() {

	this._impostors.length = 0;
};

/**
 * Gets a LOD instance of the internal array.
 * 
 * @param {string} id - The id of the LOD instance.
 * 
 * @returns {LOD} The LOD instance.
 */
PerformanceManager.prototype.getLOD = function( id ) {

	var index, lod;

	for ( index = 0; index < this._lods.length; index++ )
	{
		if ( this._lods[ index ].idLOD === id )
		{
			lod = this._lods[ index ];
			break;
		}
	}

	if ( lod === undefined )
	{
		throw "ERROR: PerformanceManager: LOD instance with ID " + id + " not existing.";
	}
	else
	{
		return lod;
	}
};

/**
 * Gets an impostor instance of the internal array.
 * 
 * @param {string} id - The id of the impostor instance.
 * 
 * @returns {Impostor} The impostor instance.
 */
PerformanceManager.prototype.getImpostor = function( id ) {

	var index, impostor;

	for ( index = 0; index < this._impostors.length; index++ )
	{
		if ( this._impostors[ index ].idImpostor === id )
		{
			impostor = this._impostors[ index ];
			break;
		}
	}

	if ( impostor === undefined )
	{
		throw "ERROR: PerformanceManager: Impostor instance with ID " + id + " not existing.";
	}
	else
	{
		return impostor;
	}
};

/**
 * Updates the performance manager.
 */
PerformanceManager.prototype.update = function() {

	this._updateLODs();

	this._updateImpostors();
};

/**
 * This method prepares some global data needed for all impostors (e.g. camera,
 * lights) and triggers the actual generation of all impostors.
 */
PerformanceManager.prototype.generateImpostors = function() {
	
	var index;

	// copy camera properties to impostor camera. we can't use the copy method
	// of the camera object, because it does automatically a deep copy. since
	// the actual camera has child objects (audio), we only want to copy
	// the most necessary data.
	this._impostorCamera.matrixWorldInverse.copy( camera.matrixWorldInverse );
	this._impostorCamera.projectionMatrix.copy( camera.projectionMatrix );

	this._impostorCamera.fov = camera.fov;
	this._impostorCamera.aspect = camera.aspect;
	this._impostorCamera.near = camera.near;
	this._impostorCamera.far = camera.far;
	this._impostorCamera.zoom = camera.zoom;

	// ensure the position of the camera is in world coordinates
	camera.getWorldPosition( this._impostorCamera.position );

	// update the internal array with the entire lighting of the actual stage
	for ( index = 0; index < world.scene.children.length; index++ )
	{
		if ( world.scene.children[ index ] instanceof THREE.Light )
		{
			this._impostorLights.push( world.scene.children[ index ] );
		}
	}

	// generate each impostor
	for ( index = 0; index < this._impostors.length; index++ )
	{
		this._impostors[ index ].generate( renderer, this._impostorCamera, this._impostorLights );
	}

	// clean up
	this._impostorLights.length = 0;
};

/**
 * Updates all LOD instances.
 */
PerformanceManager.prototype._updateLODs = function() {
	
	var index;

	for ( index = 0; index < this._lods.length; index++ )
	{
		this._lods[ index ].update();
	}

};

/**
 * Updates all impostor.
 */
PerformanceManager.prototype._updateImpostors = ( function() {

	var cameraWorldPosition;

	return function() {

		var index;

		if ( cameraWorldPosition === undefined )
		{
			cameraWorldPosition = new THREE.Vector3();
		}

		// the camera world position is equal for each impostor
		camera.getWorldPosition( cameraWorldPosition );

		for ( index = 0; index < this._impostors.length; index++ )
		{
			this._impostors[ index ].update( cameraWorldPosition );
		}
		
	};

}() );

module.exports = new PerformanceManager();
},{"../core/Camera":19,"../core/Renderer":23,"../core/World":31,"./Impostor":32,"./LOD":34,"three":1}],39:[function(require,module,exports){
/**
 * @file This prototype can be used to create a reflector. The implementation
 * can use two variants to create reflection:
 * 
 * 1. Stencil Buffer: First, the logic renders the shape of the reflector to the
 * stencil and color buffer. Then all reflected objects are drawn with activated
 * stencil test and the rest of the stage is rendered normally. The invocation
 * of the reflector's update method must always happen AFTER the invocation of
 * the stage render method.
 * 
 * see: Real-Time Rendering, Third Edition, Akenine-Möller/Haines/Hoffman
 * Chapter 9.3.1 Planar Reflections
 * 
 * 2. Projective Texture Mapping: This variant renders the reflection into a
 * texture. This map is then applied to the reflector via projective texture
 * mapping. The invocation of the reflector's update method must always happen
 * BEFORE the invocation of the stage render method.
 * 
 * see: http://www.futurenation.net/glbase/reflect.htm
 * 
 * When using this prototype, you must ensure that the autoClear property of
 * renderer is set to false and the stage clears the buffer manually.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var ReflectorShader = require( "../shader/ReflectorShader" );

/**
 * Creates a reflector.
 * 
 * @constructor
 * @augments THREE.Mesh
 * 
 * @param {Renderer} renderer - The renderer object.
 * @param {Camera} camera - The camera object.
 * @param {World} world - The world object.
 * @param {object} options - The options of the reflector.
 */
function Reflector( renderer, camera, world, options ) {

	THREE.Mesh.call( this );

	Object.defineProperties( this, {

		// the width of the reflector
		width : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the height of the reflector
		height : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this value can be used to add a little offset to the normal of the
		// reflection plane. it avoids render errors/ artifacts when working
		// with the stencil buffer
		offset : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this value can be used to tweak the clipping if projective texture
		// mapping is used
		clipBias : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// approximate resolution value of the render target
		resolution : {
			value : 2048,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// controls the type of reflector algorithm
		useStencilBuffer : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// a reference to the renderer object
		_renderer : {
			value : renderer,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to the camera object
		_camera : {
			value : camera,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to the world object
		_world : {
			value : world,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the reflection plane of the reflector. this plane will be used to build
		// the reflection matrix
		_reflectionPlane : {
			value : new THREE.Plane(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this will be used to transform the virtual camera to the correct
		// viewpoint of the reflector
		_reflectionMatrix : {
			value : new THREE.Matrix4(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the virtual camera. it represents the actual view of the reflector
		_reflectorCamera : {
			value : new THREE.PerspectiveCamera(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this special scene holds only the reflector for rendering to the
		// stencil buffer. three.js render method can't render single objects,
		// but just scenes
		_sceneReflector : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this texture contains the reflection of the reflector
		_reflectionMap : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this matrix is used to generate uv coordinates in the shader to map
		// the texture to the reflector's surface
		_textureMatrix : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this helper object visualizes the position of the virtual camera
		_cameraHelper : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this helper shows the view direction of the reflector's camera
		_directionHelper : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
	
	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}

	this._init();
}

Reflector.prototype = Object.create( THREE.Mesh.prototype );
Reflector.prototype.constructor = Reflector;

/**
 * Update method of the reflector.
 */
Reflector.prototype.update = function() {
	
	this._beforeRender();

	this._render();
	
	this._afterRender();
};

/**
 * This overrides the standard three.js method. If this method is called, we
 * also want to update the reflection entities.
 */
Reflector.prototype.updateMatrix = function() {

	THREE.Mesh.prototype.updateMatrix.call( this );

	this.makeReflectionPlane();

	this.makeReflectionMatrix();
};

/**
 * Creates the reflection plane of the reflector.
 */
Reflector.prototype.makeReflectionPlane = ( function() {

	var normal, position, quaternion, scale;

	return function() {

		if ( normal === undefined )
		{
			normal = new THREE.Vector3();
			position = new THREE.Vector3();
			quaternion = new THREE.Quaternion();
			scale = new THREE.Vector3();
		}
		
		// ensure matrixWorld is up to date
		this.updateMatrixWorld( true );
		
		// then extract position and orientation 
		this.matrixWorld.decompose( position, quaternion, scale );
		
		// get the normal of the reflector/plane
		normal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();
		
		// optional: tweak the normal to avoid render artifacts ( stencil buffer )
		normal.add( this.offset ).normalize();

		// calculate reflection plane
		this._reflectionPlane.setFromNormalAndCoplanarPoint( normal, position );
	};

}() );

/**
 * Creates the reflection matrix of the reflector.
 * 
 * see: 3D Math Primer for Graphics and Game Development (Second Edition),
 * Chapter 5.4 Reflection, 3D matrix to reflect about an arbitrary plane
 */
Reflector.prototype.makeReflectionMatrix = function() {

	// construct reflection matrix from reflection plane

	this._reflectionMatrix.elements[ 0 ] = -2 * this._reflectionPlane.normal.x * this._reflectionPlane.normal.x + 1;
	this._reflectionMatrix.elements[ 1 ] = -2 * this._reflectionPlane.normal.y * this._reflectionPlane.normal.x;
	this._reflectionMatrix.elements[ 2 ] = -2 * this._reflectionPlane.normal.z * this._reflectionPlane.normal.x;
	this._reflectionMatrix.elements[ 3 ] = 0;

	this._reflectionMatrix.elements[ 4 ] = -2 * this._reflectionPlane.normal.x * this._reflectionPlane.normal.y;
	this._reflectionMatrix.elements[ 5 ] = -2 * this._reflectionPlane.normal.y * this._reflectionPlane.normal.y + 1;
	this._reflectionMatrix.elements[ 6 ] = -2 * this._reflectionPlane.normal.z * this._reflectionPlane.normal.y;
	this._reflectionMatrix.elements[ 7 ] = 0;

	this._reflectionMatrix.elements[ 8 ] = -2 * this._reflectionPlane.normal.x * this._reflectionPlane.normal.z;
	this._reflectionMatrix.elements[ 9 ] = -2 * this._reflectionPlane.normal.y * this._reflectionPlane.normal.z;
	this._reflectionMatrix.elements[ 10 ] = -2 * this._reflectionPlane.normal.z * this._reflectionPlane.normal.z + 1;
	this._reflectionMatrix.elements[ 11 ] = 0;

	this._reflectionMatrix.elements[ 12 ] = -2 * this._reflectionPlane.normal.x * this._reflectionPlane.constant;
	this._reflectionMatrix.elements[ 13 ] = -2 * this._reflectionPlane.normal.y * this._reflectionPlane.constant;
	this._reflectionMatrix.elements[ 14 ] = -2 * this._reflectionPlane.normal.z * this._reflectionPlane.constant;
	this._reflectionMatrix.elements[ 15 ] = 1;
};

/**
 * Initializes the reflector.
 */
Reflector.prototype._init = function() {
	
	// geometry of the reflector
	this.geometry = new THREE.PlaneBufferGeometry( this.width, this.height, 1, 1 );
	
	// no auto-update for virtual camera
	this._reflectorCamera.matrixAutoUpdate = false;
	
	// no auto-update for reflector itself 
	this.matrixAutoUpdate = false;

	// check the usage of the stencil buffer. if set to true, we don't render the reflection to
	// a texture but directly to the world
	if ( this.useStencilBuffer === true )
	{
		// when we don't use a render target, we must ensure that the reflector
		// itself is not written to the depth buffer. otherwise we won't see
		// objects "inside" the reflector
		this.material = new THREE.MeshBasicMaterial( {
			color : this._renderer.getClearColor(),
			depthWrite : false
		} );

		// we need to store the reflector in a separate scene for rendering to
		// the stencil buffer
		this._sceneReflector = new THREE.Scene();
		this._sceneReflector.add( this );
	}
	else
	{
		// custom shader material
		this.material = new THREE.ShaderMaterial( {
			uniforms : THREE.UniformsUtils.clone( ReflectorShader.uniforms ),
			vertexShader : ReflectorShader.vertexShader,
			fragmentShader : ReflectorShader.fragmentShader
		} );

		// create a render target for the reflection texture
		this._createRenderTarget();

		// create texture matrix
		this._textureMatrix = new THREE.Matrix4();

		// assign uniform data
		this.material.uniforms.reflectionMap.value = this._reflectionMap;
		this.material.uniforms.textureMatrix.value = this._textureMatrix;
	}

};

/**
 * Render method of the reflector.
 */
Reflector.prototype._render = function() {

	if ( this.useStencilBuffer === true )
	{
		// draw all reflected objects to the framebuffer
		this._renderer.render( this._world.scene, this._reflectorCamera );
	}
	else
	{
		// draw all reflected objects into the render target
		this._renderer.render( this._world.scene, this._reflectorCamera, this._reflectionMap, true );	
	}

};

/**
 * This method is called before rendering.
 */
Reflector.prototype._beforeRender = function() {

	this._updateCamera();

	if ( this.useStencilBuffer === true )
	{
		this._updateStencilBuffer();
	}
	else
	{
		this._updateTextureMatrix();

		this._updateClipping();
		
		// the reflector should not render itself
		this.material.visible = false;
	}

	// update culling of faces
	this._updateCulling();

};

/**
 * This method is called after rendering.
 */
Reflector.prototype._afterRender = function() {

	var gl = this._renderer.getWebGLContext();
	var glState = this._renderer.getWebGLState();

	if ( this.useStencilBuffer === true )
	{
		// disable stencil test
		glState.disable( gl.STENCIL_TEST );
	}
	else
	{
		this.material.visible = true;
	}

	this._updateCulling();
};

/**
 * This will update the stencil buffer. It ensures that the viewer sees
 * reflected objects only inside the reflector. So it's just a special form of
 * clipping.
 */
Reflector.prototype._updateStencilBuffer = function() {

	var gl = this._renderer.getWebGLContext();
	var glState = this._renderer.getWebGLState();

	// enable stencil test
	glState.enable( gl.STENCIL_TEST );
	gl.stencilFunc( gl.ALWAYS, 1, 0xff );
	gl.stencilOp( gl.REPLACE, gl.KEEP, gl.REPLACE );

	// draw reflector to stencil buffer
	this._renderer.render( this._sceneReflector, this._camera );

	// change stencil function and operation for testing
	gl.stencilFunc( gl.EQUAL, 1, 0xff );
	gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
};

/**
 * This will update the virtual camera to the correct view position and
 * orientation.
 */
Reflector.prototype._updateCamera = function() {

	// we use our reflection matrix to flip the position and orientation of our
	// virtual camera
	this._reflectorCamera.matrix.copy( this._reflectionMatrix ).multiply( this._camera.matrixWorld );

	// update matrices
	this._reflectorCamera.updateMatrixWorld( true );
	this._reflectorCamera.projectionMatrix.copy( this._camera.projectionMatrix );

	// this is only necessary if we render to a texture
	if ( this.useStencilBuffer === false )
	{
		this._reflectorCamera.matrixWorldInverse.getInverse( this._reflectorCamera.matrixWorld );
	}
};

/**
 * Updates helper objects.
 */
Reflector.prototype._updateHelpers = function() {

	this._cameraHelper.position.setFromMatrixPosition( this._reflectorCamera.matrix );
	this._directionHelper.setDirection( this._reflectorCamera.getWorldDirection() );
};

/**
 * Adds 3D helper objects for debugging.
 */
Reflector.prototype._addHelpers = function() {

	var helperGeometry = new THREE.BoxGeometry( 2, 2, 2 );
	var helperMaterial = new THREE.MeshBasicMaterial( {
		color : 0xffffff
	} );

	// create a simple mesh to visualize the position of the reflector camera
	this._cameraHelper = new THREE.Mesh( helperGeometry, helperMaterial );

	// create a arrow to visualize the orientation of the reflector camera
	this._directionHelper = new THREE.ArrowHelper( this._cameraHelper.getWorldDirection(), new THREE.Vector3(), 10 );

	// add helpers to world
	this._cameraHelper.add( this._directionHelper );
	this._world.addObject3D( this._cameraHelper );
};

/**
 * This method controls the culling mode of objects. Because reflection reverses
 * the winding order, it is necessary to switch the culling mode for each
 * object.
 */
Reflector.prototype._updateCulling = function() {

	var index, self;
	
	self = this;

	this._world.scene.traverseVisible( function( object ) {

		if ( object.material !== undefined )
		{
			// multi materials have an array of materials
			if ( object.material instanceof THREE.MultiMaterial )
			{
				for ( index = 0; index < object.material.materials.length; index++ )
				{
					self._flipFaceCulling( object.material.materials[ index ] );
				}
			}
			else
			{
				self._flipFaceCulling( object.material );
			}

		}
		
	} );
};

/**
 * This method changes between front and back face culling.
 * 
 * @param {THREE.Material} material - The material object.
 */
Reflector.prototype._flipFaceCulling = function( material ) {

	if ( material.side !== THREE.DoubleSide )
	{
		material.side = ( material.side === THREE.FrontSide ) ? THREE.BackSide : THREE.FrontSide;
	}
};

/**
 * Creates the render target that is used to rendering the reflection into a
 * texture.
 */
Reflector.prototype._createRenderTarget = function() {

	var resolution = new THREE.Vector2();
	var parameter = {
		format : THREE.RGBFormat,
		stencilBuffer : false
	};

	// we check the ratio of the dimensions and calculate an appropriate
	// resolution
	if ( this.width > this.height )
	{
		resolution.x = this.resolution;
		resolution.y = Math.floor( this.resolution * ( this.height / this.width ) );

	}
	else
	{
		resolution.x = Math.floor( this.resolution * ( this.width / this.height ) );
		resolution.y = this.resolution;
	}

	// create the render target
	this._reflectionMap = new THREE.WebGLRenderTarget( resolution.x, resolution.y, parameter );
};

/**
 * This will update the texture matrix that is used for projective texture
 * mapping in the shader.
 * 
 * see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf
 */
Reflector.prototype._updateTextureMatrix = function() {

	// this matrix does range mapping to [ 0, 1 ]
	this._textureMatrix.set( 0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0 );

	// we use "Object Linear Texgen", so we need to multiply the texture matrix T
	// (matrix above) with the projection and view matrix of the virtual camera
	// and the model matrix of the 3D object (the reflector)
	this._textureMatrix.multiply( this._reflectorCamera.projectionMatrix );
	this._textureMatrix.multiply( this._reflectorCamera.matrixWorldInverse );
	this._textureMatrix.multiply( this.matrixWorld );
};

/**
 * This method creates an oblique view frustum for clipping.
 * 
 * see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.
 * Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp.
 * 5–16.
 */
Reflector.prototype._updateClipping = ( function() {

	var clipPlane, clipVector, q;

	return function() {

		// shortcut
		var projectionMatrix = this._reflectorCamera.projectionMatrix;

		if ( clipPlane === undefined )
		{
			clipPlane = new THREE.Plane();
			clipVector = new THREE.Vector4();
			q = new THREE.Vector4();
		}

		// copy the reflection plane and apply the inverse world matrix of the
		// reflector camera
		clipPlane.copy( this._reflectionPlane );
		clipPlane.applyMatrix4( this._reflectorCamera.matrixWorldInverse );

		// we transfer the information of our plane to a four component vector
		clipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );

		// calculate the clip-space corner point opposite the clipping plane and
		// transform it into camera space by multiplying it by the inverse of
		// the projection matrix
		q.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
		q.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
		q.z = - 1.0;
		q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

		// calculate the scaled plane vector
		clipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );

		// replacing the third row of the projection matrix
		projectionMatrix.elements[ 2 ] = clipVector.x;
		projectionMatrix.elements[ 6 ] = clipVector.y;
		projectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - this.clipBias;
		projectionMatrix.elements[ 14 ] = clipVector.w;
	};

}() );

module.exports = Reflector;
},{"../shader/ReflectorShader":91,"three":1}],40:[function(require,module,exports){
/**
 * @file This prototype can be used to create a refractor. The logic renders
 * everything behind a clipping plane into a texture. The associated shader
 * program can implement different effects like distortions. Compared with the
 * reflector this prototype provides just one type of rendering.
 * 
 * 1. Projective Texture Mapping: This variant renders the refraction into a
 * texture map. This map is then applied to the refractor via projective texture
 * mapping. The invocation of the refractor's update method must always happen
 * BEFORE the invocation of the stage render method.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var RefractorShader = require( "../shader/RefractorShader" );

/**
 * Creates a refractor.
 * 
 * @constructor
 * @augments THREE.Mesh
 * 
 * @param {Renderer} renderer - The renderer object.
 * @param {Camera} camera - The camera object.
 * @param {World} world - The world object.
 * @param {object} options - The options of the refractor.
 */
function Refractor( renderer, camera, world, options ) {

	THREE.Mesh.call( this );

	Object.defineProperties( this, {

		// the width of the refractor
		width : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the height of the refractor
		height : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this value can be used to tweak the clipping
		clipBias : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// approximate resolution value of the render target
		resolution : {
			value : 2048,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// a reference to the renderer object
		_renderer : {
			value : renderer,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to the camera object
		_camera : {
			value : camera,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to the world object
		_world : {
			value : world,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this will be used as a clipping plane
		_refractionPlane : {
			value : new THREE.Plane(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the virtual camera. it represents the actual view of the refractor
		_refractorCamera : {
			value : new THREE.PerspectiveCamera(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this texture contains the refraction
		_refractionMap : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this matrix is used to generate uv coordinates in the shader to map
		// the texture to the refractor's surface
		_textureMatrix : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
	
	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}

	this._init();
}

Refractor.prototype = Object.create( THREE.Mesh.prototype );
Refractor.prototype.constructor = Refractor;

/**
 * Update method of the refractor.
 */
Refractor.prototype.update = function() {
	
	this._beforeRender();

	this._render();
	
	this._afterRender();
};

/**
 * This overrides the standard three.js method. If this method is called, we
 * also want to update the refraction plane.
 */
Refractor.prototype.updateMatrix = function() {

	THREE.Mesh.prototype.updateMatrix.call( this );

	this.makeRefractionPlane();
};

/**
 * Creates the clipping plane of the refractor.
 */
Refractor.prototype.makeRefractionPlane = ( function() {

	var normal, position, quaternion, scale;

	return function() {

		if ( normal === undefined )
		{
			normal = new THREE.Vector3();
			position = new THREE.Vector3();
			quaternion = new THREE.Quaternion();
			scale = new THREE.Vector3();
		}
		
		// ensure matrixWorld is up to date
		this.updateMatrixWorld( true );
		
		// then extract position and orientation 
		this.matrixWorld.decompose( position, quaternion, scale );
		
		// get the normal of the refractor plane
		normal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();
		
		// flip the normal, because we want to cull everything above the plane
		normal.negate();
		
		// calculate refractor plane
		this._refractionPlane.setFromNormalAndCoplanarPoint( normal, position );
	};

}() );

/**
 * Initializes the refractor.
 */
Refractor.prototype._init = function() {
	
	// geometry of the refractor
	this.geometry = new THREE.PlaneBufferGeometry( this.width, this.height, 1, 1 );

	// custom shader material
	this.material = new THREE.ShaderMaterial( {
		uniforms : THREE.UniformsUtils.clone( RefractorShader.uniforms ),
		vertexShader : RefractorShader.vertexShader,
		fragmentShader : RefractorShader.fragmentShader
	} );
		
	// create a render target for the refraction texture
	this._createRenderTarget();
	
	// create texture matrix
	this._textureMatrix = new THREE.Matrix4();
	
	// assign uniform data
	this.material.uniforms.refractionMap.value = this._refractionMap;
	this.material.uniforms.textureMatrix.value = this._textureMatrix;
	
	// no auto-update for virtual camera
	this._refractorCamera.matrixAutoUpdate = false;
	
	// no auto-update for refractor itself 
	this.matrixAutoUpdate = false;
};

/**
 * Render method of the refractor.
 */
Refractor.prototype._render = function() {
	
	this._renderer.render( this._world.scene, this._refractorCamera, this._refractionMap, true );
};

/**
 * This method is called before rendering.
 */
Refractor.prototype._beforeRender = function() {
	
	// the refractor should not render itself
	this.material.visible = false;

	this._updateCamera();
	
	this._updateTextureMatrix();
	
	this._updateClipping();
};

/**
 * This method is called after rendering.
 */
Refractor.prototype._afterRender = function() {

	this.material.visible = true;
};


/**
 * This will update the virtual camera to the correct view position and
 * orientation.
 */
Refractor.prototype._updateCamera = function() {

	// we just copy the values of our camera to the virtual camera of the refractor
	this._refractorCamera.matrix.copy( this._camera.matrixWorld );
	this._refractorCamera.updateMatrixWorld( true );
	this._refractorCamera.projectionMatrix.copy( this._camera.projectionMatrix );
	this._refractorCamera.matrixWorldInverse.getInverse( this._refractorCamera.matrixWorld );
};

/**
 * Creates the render target that is used to rendering the refraction into a
 * texture.
 */
Refractor.prototype._createRenderTarget = function() {

	var resolution = new THREE.Vector2();
	var parameter = {
		format : THREE.RGBFormat,
		stencilBuffer : false
	};

	// we check the ratio of the dimensions and calculate an appropriate
	// resolution
	if ( this.width > this.height )
	{
		resolution.x = this.resolution;
		resolution.y = Math.floor( this.resolution * ( this.height / this.width ) );

	}
	else
	{
		resolution.x = Math.floor( this.resolution * ( this.width / this.height ) );
		resolution.y = this.resolution;
	}

	// create the render target
	this._refractionMap = new THREE.WebGLRenderTarget( resolution.x, resolution.y, parameter );
};

/**
 * This will update the texture matrix that is used for projective texture
 * mapping in the shader.
 * 
 * see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf
 */
Refractor.prototype._updateTextureMatrix = function() {

	// this matrix does range mapping to [ 0, 1 ]
	this._textureMatrix.set( 0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0 );

	// we use "Object Linear Texgen", so we need to multiply the texture matrix T
	// (matrix above) with the projection and view matrix of the virtual camera
	// and the model matrix of the 3D object (the refractor)
	this._textureMatrix.multiply( this._refractorCamera.projectionMatrix );
	this._textureMatrix.multiply( this._refractorCamera.matrixWorldInverse );
	this._textureMatrix.multiply( this.matrixWorld );
};

/**
 * This method creates an oblique view frustum for clipping.
 * 
 * see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.
 * Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp.
 * 5–16.
 */
Refractor.prototype._updateClipping = ( function() {

	var clipPlane, clipVector, q;

	return function() {

		// shortcut
		var projectionMatrix = this._refractorCamera.projectionMatrix;

		if ( clipPlane === undefined )
		{
			clipPlane = new THREE.Plane();
			clipVector = new THREE.Vector4();
			q = new THREE.Vector4();
		}

		// copy the reflection plane and apply the inverse world matrix of the
		// refractor camera
		clipPlane.copy( this._refractionPlane );
		clipPlane.applyMatrix4( this._refractorCamera.matrixWorldInverse );

		// we transfer the information of our plane to a four component vector
		clipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );

		// calculate the clip-space corner point opposite the clipping plane and
		// transform it into camera space by multiplying it by the inverse of
		// the projection matrix
		q.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
		q.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
		q.z = - 1.0;
		q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

		// calculate the scaled plane vector
		clipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );

		// replacing the third row of the projection matrix
		projectionMatrix.elements[ 2 ] = clipVector.x;
		projectionMatrix.elements[ 6 ] = clipVector.y;
		projectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - this.clipBias;
		projectionMatrix.elements[ 14 ] = clipVector.w;
	};

}() );

module.exports = Refractor;
},{"../shader/RefractorShader":92,"three":1}],41:[function(require,module,exports){
(function (global){
/**
 * @file Interface for entire savegame-handling. This prototype is using HTML
 * Storage API for saving data on the client-side.
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates the savegame manager.
 * 
 * @constructor
 */
function SaveGameManager() {

	Object.defineProperties( this, {
		_storage : {
			value : global.localStorage,
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
}

/**
 * Saves the progress to localStorage. The savegame object is transformed to
 * JSON and then encoded to BASE64.
 * 
 * @param {string} stageId - The ID of the stage.
 * @param {boolean} isFinish - Is the game finished?
 */
SaveGameManager.prototype.save = function( stageId, isFinish ) {

	var saveGame = {
		time : new Date().getTime(),
		stageId : stageId,
		isFinish : isFinish || false
	};

	// transform object to JSON-string and encode to BASE64
	saveGame = global.window.btoa( JSON.stringify( saveGame ) );

	// save
	this._storage.setItem( "savegame", saveGame );
};

/**
 * Loads the savegame from localStorage. At first, the string gets BASE64
 * decoded and then parsed from JSON to an object.
 * 
 * @returns {object} The savegame.
 */
SaveGameManager.prototype.load = function() {

	var saveGame = this._storage.getItem( "savegame" );

	if ( saveGame !== null )
	{
		// Decode BASE64 and parse JSON-string to object
		saveGame = JSON.parse( global.window.atob( saveGame ) );
	}

	return saveGame;
};

/**
 * Removes the savegame from localStorage.
 */
SaveGameManager.prototype.remove = function() {

	this._storage.removeItem( "savegame" );
};

module.exports = new SaveGameManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],42:[function(require,module,exports){
(function (global){
/**
 * @file Interface for entire settings-handling. This prototype is used to
 * access and save settings via HTML5-Storage API.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var system = require( "../core/System" );

/**
 * Creates the settings manager and loads the current settings.
 * 
 * @constructor
 */
function SettingsManager() {

	Object.defineProperties( this, {
		_storage : {
			value : global.localStorage,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_settings : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	this._settings = this.load();
}

/**
 * Saves the settings to storage. The settings object is transformed to JSON and
 * then encoded to BASE64.
 * 
 * @param {string} graphicSettings - The common graphic settings.
 * @param {number} mouseSensitivity - The mouse sensitivity.
 */
SettingsManager.prototype.save = function( graphicSettings, mouseSensitivity ) {

	var settings = {
		graphicSettings : graphicSettings,
		mouseSensitivity : mouseSensitivity
	};

	// transform object to JSON-string and encode to BASE64
	settings = global.window.btoa( JSON.stringify( settings ) );

	// save
	this._storage.setItem( "settings", settings );
};

/**
 * Loads the settings from storage. At first, the string gets BASE64 decoded and
 * then parsed from JSON to an object.
 * 
 * @returns {object} The settings.
 */
SettingsManager.prototype.load = function() {

	var settings = this._storage.getItem( "settings" );

	if ( settings !== null )
	{

		// decode BASE64 and parse JSON-string to object
		settings = JSON.parse( global.window.atob( settings ) );
	}
	else
	{
		// default settings
		settings = {
			graphicSettings : SettingsManager.GRAPHICS.HIGH,
			mouseSensitivity : SettingsManager.MOUSE.MIDDLE
		};
	}

	return settings;
};

/**
 * Removes the settings from storage.
 */
SettingsManager.prototype.remove = function() {

	this._storage.removeItem( "settings" );
};

/**
 * Adjusts some properties of the given materials. The result depends on the
 * current graphic settings.
 * 
 * @param {object} materials - An arrays of THREE.Material objects.
 * @param {THREE.WebGLRenderer} renderer - The renderer of the application.
 */
SettingsManager.prototype.adjustMaterials = function( materials, renderer ) {

	for ( var i = 0; i < materials.length; i++ )
	{
		if ( this._settings.graphicSettings === SettingsManager.GRAPHICS.HIGH )
		{
			// anisotropy filter on high-settings
			if ( materials[ i ].map !== undefined && materials[ i ].map !== null )
			{
				materials[ i ].map.anisotropy = renderer.getMaxAnisotropy();
			}
			if ( materials[ i ].normalMap !== undefined && materials[ i ].normalMap !== null )
			{
				materials[ i ].normalMap.anisotropy = renderer.getMaxAnisotropy();
			}
		}
		else if ( this._settings.graphicSettings === SettingsManager.GRAPHICS.LOW )
		{
			// no anisotropy filter and normal maps on low-settings
			if ( materials[ i ].normalMap !== undefined && materials[ i ].normalMap !== null )
			{
				materials[ i ].normalMap = null;
			}
		}
	}
};

/**
 * Adjusts some properties of the given light. The result depends on the current
 * graphic settings.
 * 
 * @param {THREE.Light} light - The light to adjusted.
 */
SettingsManager.prototype.adjustLight = function( light ) {

	if ( this._settings.graphicSettings === SettingsManager.GRAPHICS.HIGH )
	{
		// smoother shadows on high-settings
		light.castShadow = true;
		light.shadow.mapSize.x = 1024;
		light.shadow.mapSize.y = 1024;
	}
	else if ( this._settings.graphicSettings === SettingsManager.GRAPHICS.MIDDLE )
	{
		// shadows on middle-settings
		light.castShadow = true;
		light.shadow.mapSize.x = 512;
		light.shadow.mapSize.y = 512;
	}
	else
	{
		// no shadows on low-settings
		light.castShadow = false;
	}
	
};

/**
 * Gets the mouse sensitivity.
 * 
 * @param {number} light - The mouse sensitivity.
 */
SettingsManager.prototype.getMouseSensitivity = function() {

	return this._settings.mouseSensitivity;
};

SettingsManager.GRAPHICS = {
	LOW : 0,
	MIDDLE : 1,
	HIGH : 2
};

SettingsManager.MOUSE = {
	LOW : 2,
	MIDDLE : 5,
	HIGH : 8
};

module.exports = new SettingsManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/System":27,"three":1}],43:[function(require,module,exports){
/**
 * @file This prototype represents the character of a teammate.
 * 
 * @author Human Interactive
 */
"use strict";

var GameEntity = require( "../game/entity/GameEntity" );

/**
 * Creates a teammate instance.
 * 
 * @constructor
 * @augments GameEntity
 * 
 * @param {number} id - The multiplayer id of the teammate entity.
 * @param {THREE.Mesh} mesh - The mesh of the teammate.
 */
function Teammate( id, mesh ) {

	GameEntity.call( this, mesh );

	Object.defineProperties( this, {
		multiplayerId : {
			value : id,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
	
}

Teammate.prototype = Object.create( GameEntity.prototype );
Teammate.prototype.constructor = Teammate;

/**
 * Updates the teammate.
 * 
 * @param {THREE.Vector3} position - The new position of the teammate.
 * @param {THREE.Quaternion} quaternion - The new orientation of the teammate.
 */
Teammate.prototype.update = function( position, quaternion ) {

	this.position.copy( position );
	this.quaternion.copy( quaternion );
};

module.exports = Teammate;
},{"../game/entity/GameEntity":48}],44:[function(require,module,exports){
(function (global){
/**
 * @file Interface for entire text-handling. This prototype is used in stages to
 * access text-based logic and to load localized texts.
 * 
 * @author Human Interactive
 */
"use strict";

var system = require( "../core/System" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

/**
 * Creates the text manager.
 * 
 * @constructor
 */
function TextManager() {

	Object.defineProperties( this, {
		_texts : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
}

/**
 * Loads the localized text file for the given stage and buffers the result.
 * 
 * @param {string} stageId - The ID of the stage.
 * @param {function} callback - Executed, when the loading was successful.
 */
TextManager.prototype.load = function( stageId, callback ) {

	var self = this;

	// build url
	var url = system.cdn + "/assets/locales/" + system.locale + "/stage_" + stageId + ".js";

	// add nocache, if necessary
	if ( system.isDevModeActive === true )
	{
		url = url + "?" + new Date().getTime();
	}

	// create XMLHttpRequest object
	var xhr = new global.XMLHttpRequest();

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === xhr.DONE )
		{
			if ( xhr.status === 200 )
			{
				if ( xhr.responseText !== "" )
				{
					// assign texts
					self._texts = JSON.parse( xhr.responseText );

					// search for keys and replace with text
					self._searchAndRepalce();

					// publish message to inform about status
					eventManager.publish( TOPIC.STAGE.LOADING.COMPLETE.TEXT, {
						url : url
					} );

					if ( typeof callback === "function" )
					{
						callback();
					}

				}
				else
				{
					throw "ERROR: TextManager: Unable to parse texts for stageId '" + stageId + "'. Textfile could be empty.";
				}
			}
			else
			{
				throw "ERROR: TextManager: Could not load '" + url + "' (Status: " + xhr.status + ").";
			}
		}
	};

	// start request
	xhr.open( 'GET', url, true );
	xhr.withCredentials = true;
	xhr.send();

	// publish message to inform about status
	eventManager.publish( TOPIC.STAGE.LOADING.START.TEXT, {
		url : url
	} );
};

/**
 * Gets the localized text by the given key.
 * 
 * @param {string} key - The key of the text.
 * 
 * @returns {string} The localized text.
 */
TextManager.prototype.get = function( key ) {

	var value;

	if ( this._texts !== null && this._texts[ key ] !== undefined )
	{
		value = this._texts[ key ];
	}
	else
	{
		value = key;
	}

	return value;
};

/**
 * Removes the buffered texts.
 */
TextManager.prototype.removeTexts = function() {

	this._texts = null;
};

/**
 * Gets all text nodes under a specific DOM-Element.
 * 
 * @param {object} element - The source DOM-Element for the search.
 * 
 * @returns {object} An array with text nodes.
 */
TextManager.prototype._getAllTextNodes = function( element ) {

	var textNodeList = [];
	var treeWalker = global.document.createTreeWalker( element, global.NodeFilter.SHOW_TEXT, null, false );
	while ( treeWalker.nextNode() )
	{
		textNodeList.push( treeWalker.currentNode );
	}
	return textNodeList;
};

/**
 * Searches for Text-IDs and replaces it with the actual text.
 */
TextManager.prototype._searchAndRepalce = function() {

	var key = null;
	var index = 0;
	var textNodes = this._getAllTextNodes( global.document.querySelector( "#ui-container" ) );

	for ( key in this._texts )
	{
		if ( this._texts.hasOwnProperty( key ) )
		{
			for ( index = 0; index < textNodes.length; index++ )
			{
				// because the property textContent is used, it's not possible
				// to replace an ID with text, which contains HTML-entities
				textNodes[ index ].textContent = textNodes[ index ].textContent.replace( key, this._texts[ key ] );
			}
		}
	}
};

module.exports = new TextManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/System":27,"../messaging/EventManager":69,"../messaging/Topic":71}],45:[function(require,module,exports){
(function (global){
/**
 * @file All helper and util functions are organized in this module.
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates an instance of utils.
 * 
 * @constructor
 */
function Utils() {

	Object.defineProperties( this, {
		TWO_PI : {
			value : Math.PI * 2,
			configurable : false,
			enumerable : true,
			writable : false
		},
		HALF_PI : {
			value : Math.PI * 0.5,
			configurable : false,
			enumerable : true,
			writable : false
		}
	} );
}

/**
 * This method colors the faces of a geometry with two colors in an alternating
 * way.
 * 
 * @param {THREE.Geometry} geometry - The geometry object.
 * @param {THREE.Color} color1 - The first color of the faces.
 * @param {THREE.Color} color2 - The second color of the faces.
 */
Utils.prototype.colorFaces = function( geometry, color1, color2 ) {

	var index;

	for ( index = 0; index < geometry.faces.length; index++ )
	{
		if ( index % 2 === 0 )
		{
			geometry.faces[ index ].color = color1;
		}
		else
		{
			geometry.faces[ index ].color = color2;
		}
	}

};

/**
 * Preloads images and executes a callback, when all work is done.
 * 
 * @param {object} images - An array with URLs of images.
 * @param {function} callback - This function is executed, when all images are
 * loaded.
 */
Utils.prototype.preloadImages = function( images, callback ) {

	var count = 0;

	var onLoad = function() {

		if ( ++count === images.length && typeof callback === "function" )
		{
			callback();
		}
	};

	var onError = function( e ) {

		throw "ERROR: Utils: Unable to preload image with URL: " + e.target.src;
	};

	for ( var i = 0; i < images.length; i++ )
	{
		var image = new global.Image();
		image.src = images[ i ];

		image.onload = onLoad;
		image.onerror = onError;
	}
};

module.exports = new Utils();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],46:[function(require,module,exports){
/**
 * @file This file creates a realistic and expensive water effect. The material
 * is real-time reflective & refractive, it calculates a distortion of the water
 * surface and implements a basic fresnel and lighting equation.
 * 
 * The shader needs a normal and du/dv map. The du/dv map is used to create
 * distortions and can be easily created with Photoshop from a normal map in
 * just two steps (see https://developer.valvesoftware.com/wiki/Du/dv_map).
 * 
 * 1. Open the normal map and invert the colors. 
 * 2. Go to Image > Adjustments > Brightness/Contrast. 
 * 		1. Check "Use Legacy" 
 * 		2. Set Brightness to -17 
 * 		3. Set Contrast to 100
 * 
 * Maybe you have to tweak the values to get a good result. It's important that
 * the du/dv map does not contain full black or white areas.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );
var Reflector = require( "./Reflector" );
var Refractor = require( "./Refractor" );

var WaterShader = require( "../shader/WaterShader" );

/**
 * Creates a water.
 * 
 * @constructor
 * @augments THREE.Mesh
 * 
 * @param {Renderer} renderer - The renderer object.
 * @param {Camera} camera - The camera object.
 * @param {World} world - The world object.
 * @param {object} options - The options of the reflector.
 */
function Water( renderer, camera, world, options ) {
	
	THREE.Mesh.call( this );
	
	Object.defineProperties( this, {

		// the width of the water mesh
		width : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the height of the water mesh
		height : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// approximate resolution value of the render target
		resolution : {
			value : 2048,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// strength of the waves
		waveStrength : {
			value : 0.1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// speed of the waves
		waveSpeed : {
			value : 0.03,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the reflectivity of the water
		waterReflectivity : {
			value : 0.02,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the direction of the light
		lightDirection : {
			value : new THREE.Vector3( 0, 1, 0),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the color of the light
		lightColor : {
			value : new THREE.Color(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the shininess of the water
		shininess : {
			value : 20,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the amount of segments of the water geometry
		segments : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// a reference to the renderer object
		_renderer : {
			value : renderer,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to the camera object
		_camera : {
			value : camera,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to the world object
		_world : {
			value : world,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// a reference to a reflector
		_reflector : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// a reference to a refractor
		_refractor : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
	
	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}

	this._init();
}

Water.prototype = Object.create( THREE.Mesh.prototype );
Water.prototype.constructor = Water;

/**
 * Update method of the water.
 * 
 * @param {number} elapsedTime - The elapsed time.
 */
Water.prototype.update = function( elapsedTime ){
	
	// the water should not render itself
	this.material.visible = false;
	
	// update reflection and refraction
	this._reflector.update();
	this._refractor.update();
	
	// make material visible again
	this.material.visible = true;
	
	// update time uniform
	this.material.uniforms.time.value = elapsedTime;
	
	// update water properties
	this.material.uniforms.waveStrength.value = this.waveStrength;
	this.material.uniforms.waveSpeed.value = this.waveSpeed;
	this.material.uniforms.waterReflectivity.value = this.waterReflectivity;
	
	// update light properties
	this.material.uniforms.lightDirection.value = this.lightDirection;
	this.material.uniforms.lightColor.value = this.lightColor;
	this.material.uniforms.shininess.value = this.shininess;
};

/**
 * This overrides the standard three.js method. It ensures that other components
 * of the water have the same position and orientation.
 */
Water.prototype.updateMatrix = function() {

	THREE.Mesh.prototype.updateMatrix.call( this );
	
	// just copy the matrix
	this._reflector.matrix.copy( this.matrix );
	this._refractor.matrix.copy( this.matrix );
	
	// update entities for reflection and refraction
	this._reflector.makeReflectionPlane();	
	this._reflector.makeReflectionMatrix();
	
	this._refractor.makeRefractionPlane();
};

/**
 * Initializes the water.
 */
Water.prototype._init = function() {
	
	// geometry of the reflector
	this.geometry = new THREE.PlaneBufferGeometry( this.width, this.height, this.segments, this.segments );
	
	// custom shader material
	this.material = new THREE.ShaderMaterial( {
		uniforms : THREE.UniformsUtils.clone( WaterShader.uniforms ),
		vertexShader : WaterShader.vertexShader,
		fragmentShader : WaterShader.fragmentShader
	} );

	// create reflector
	this._reflector = new Reflector( this._renderer, this._camera, this._world, {
		width: this.width,
		height: this.height,
		resolution: this.resolution
	});
	
	// create refractor
	this._refractor = new Refractor( this._renderer, this._camera, this._world, {
		width: this.width,
		height: this.height,
		resolution: this.resolution
	});
	
	// load du/dv map
	var dudvMap = new THREE.TextureLoader().load( "/assets/textures/Water_1_M_DuDv.jpg" );
	dudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;
	
	// load corresponding normal map (as mentioned before, normal and du/dv
	// map should always match)
	var normalMap = new THREE.TextureLoader().load( "/assets/textures/Water_1_M_Normal.jpg" );
	normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;
		
	// set reflection and refraction map
	this.material.uniforms.reflectionMap.value = this._reflector._reflectionMap;
	this.material.uniforms.refractionMap.value = this._refractor._refractionMap;

	// set texture matrices for projective texture mapping
	this.material.uniforms.textureMatrixReflection.value = this._reflector._textureMatrix;
	this.material.uniforms.textureMatrixRefraction.value = this._refractor._textureMatrix;
	
	// set du/dv and normal map to uniforms
	this.material.uniforms.dudvMap.value = dudvMap;
	this.material.uniforms.normalMap.value = normalMap;

	// set the amount of segments of the water. this value determines, how often
	// the normal and du/dv map are repeated
	this.material.uniforms.segments.value = this.geometry.parameters.widthSegments;
	
	// no auto-update for water
	this.matrixAutoUpdate = false;
};

module.exports = Water;
},{"../shader/WaterShader":94,"./Reflector":39,"./Refractor":40,"three":1}],47:[function(require,module,exports){
/**
 * @file This prototype manages all game entities.
 * 
 * @author Human Interactive
 */
"use strict";

var GameEntity = require( "./GameEntity" );
var Player = require( "./Player" );
var Vehicle = require( "./Vehicle" );

/**
 * Creates the entity manager.
 * 
 * @constructor
 */
function EntityManager() {

	Object.defineProperties( this, {

		entities : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}

	} );
}

/**
 * Creates the player object
 * 
 * @param {World} world - The reference to the world object.
 * 
 * @returns {Player} The new player.
 */
EntityManager.prototype.createPlayer = function( world ) {

	var player = new Player( world );
	this.addEntity( player );
	return player;
};

/**
 * Creates a vehicle, a moving entity that uses steering behaviors.
 * 
 * @param {World} world - The reference to the world object.
 * @param {THREE.Object3D} object3D - The 3D object of the entity.
 * @param {number} numSamplesForSmoothing - How many samples the smoother will use to average the velocity.
 * 
 * @returns {Vehicle} The new vehicle.
 */
EntityManager.prototype.createVehicle = function( world, object3D, numSamplesForSmoothing ) {

	var vehicle = new Vehicle( world, object3D, numSamplesForSmoothing );
	this.addEntity( vehicle );
	return vehicle;
};

/**
 * Updates all entities.
 * 
 * @param {number} delta - The time delta value.
 */
EntityManager.prototype.update = function( delta ) {

	for ( var index = 0; index < this.entities.length; index++ )
	{
		this.entities[ index ].update( delta );
	}
};

/**
 * Gets an entity by its ID.
 * 
 * @param {number} id - The ID of the entity.
 * 
 * @returns {GameEntity} The entity.
 */
EntityManager.prototype.getEntity = function( id ) {

	var entity = null;

	for ( var index = 0; index < this.entities.length; index++ )
	{
		if ( this.entities[ index ].id === id )
		{
			entity = this.entities[ index ];

			break;
		}
	}

	if ( entity === null )
	{
		throw "ERROR: EntityManager: Entity with ID " + id + " not existing.";
	}
	else
	{
		return entity;
	}
};

/**
 * Adds a single entity to the internal array.
 * 
 * @param {GameEntity} entity - The entity to add.
 */
EntityManager.prototype.addEntity = function( entity ) {

	this.entities.push( entity );
};

/**
 * Removes a single entity from the internal array.
 * 
 * @param {GameEntity} entity - The entity to remove.
 */
EntityManager.prototype.removeEntity = function( entity ) {

	var index = this.entities.indexOf( entity );
	this.entities.splice( index, 1 );
};

/**
 * Removes all entities from the internal array.
 * 
 * @param {boolean} isClear - Should also all world entities be removed?
 */
EntityManager.prototype.removeEntities = function( isClear ) {

	if ( isClear === true )
	{
		this.entities.length = 0;
	}
	else
	{
		for ( var index = this.entities.length - 1; index >= 0; index-- )
		{
			// only remove entities with scope "STAGE"
			if ( this.entities[ index ].scope === GameEntity.SCOPE.STAGE )
			{
				this.remove( this.children[ index ] );
			}
		}
	}
};

module.exports = new EntityManager();
},{"./GameEntity":48,"./Player":50,"./Vehicle":51}],48:[function(require,module,exports){
/**
 * @file All entities that are part of the game logic inherit from this
 * prototype.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var nextId = 0;

/**
 * Creates a game entity.
 * 
 * @constructor
 * 
 * @param {THREE.Object3D} object3D - The 3D object of the entity.
 */
function GameEntity( object3D ) {

	Object.defineProperties( this, {
		// a unique id to identify a game entity
		id : {
			value : nextId++,
			configurable : false,
			enumerable : true,
			writable : false
		},
		// each game entity is a 3D object
		object3D : {
			value : object3D || new THREE.Object3D(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// this will be used for collision detection
		boundingRadius : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this will be used to determine the lifetime of a game entity
		scope : {
			value : GameEntity.SCOPE.STAGE,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the following are shortcuts to object3D properties
		position : {
			configurable : false,
			enumerable : true,
			get : function() {

				return this.object3D.position;
			},
			set : function( value ) {

				this.object3D.position.copy( value );
			}
		},
		rotation : {
			configurable : false,
			enumerable : true,
			get : function() {

				return this.object3D.rotation;
			},
			set : function( value ) {

				this.object3D.rotation.copy( value );
			}
		},
		quaternion : {
			configurable : false,
			enumerable : true,
			get : function() {

				return this.object3D.quaternion;
			},
			set : function( value ) {

				this.object3D.quaternion.copy( value );
			}
		},
		scale : {
			configurable : false,
			enumerable : true,
			get : function() {

				return this.object3D.scale;
			},
			set : function( value ) {

				this.object3D.scale.copy( value );
			}
		}

	} );
}

/**
 * All entities must implement an update function.
 * 
 * @param {number} delta - The time delta value.
 */
GameEntity.prototype.update = function( delta ) {

};

/**
 * If an entity wants to communicate with other entities, it must implement this
 * method. Besides, the entity needs to register itself at the event manager.
 * 
 * @param {Telegram} telegram - The telegram of the message.
 * 
 * @returns {boolean} Is the message handled successfully?
 */
GameEntity.prototype.handleMessage = function( telegram ) {

	return false;
};

/**
 * Updates the matrix of the 3D object.
 */
GameEntity.prototype.updateMatrix = function() {

	this.object3D.updateMatrix();
};

/**
 * Updates the world matrix of the 3D object and its children.
 */
GameEntity.prototype.updateMatrixWorld = function() {

	this.object3D.updateMatrixWorld();
};

GameEntity.SCOPE = {
	WORLD : 0,
	STAGE : 1
};

module.exports = GameEntity;
},{"three":1}],49:[function(require,module,exports){
/**
 * @file Base prototype from which all moving game agents are derived.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var GameEntity = require( "./GameEntity" );

/**
 * Creates a moving entity.
 * 
 * @constructor
 * @augments GameEntity
 * 
 * @param {THREE.Object3D} object3D - The 3D object of the entity.
 */
function MovingEntity( object3D ) {

	GameEntity.call( this, object3D );

	Object.defineProperties( this, {
		// the velocity of the agent
		velocity : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the mass of the agent
		mass : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum speed at which this entity may travel
		maxSpeed : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum force this entity can produce to power itself (think
		// rockets and thrust).
		maxForce : {
			value : 100,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum rate (radians per second) at which this vehicle can
		// rotate.
		maxTurnRate : {
			value : Math.PI,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

MovingEntity.prototype = Object.create( GameEntity.prototype );
MovingEntity.prototype.constructor = MovingEntity;

/**
 * This method rotates the entity to the given direction.
 * 
 * @param {THREE.Vector3} direction - The direction to rotate.
 */
MovingEntity.prototype.rotateToDirection = ( function() {

	var xAxis, yAxis, zAxis, upTemp, rotationMatrix;

	return function( direction ) {
		
		if( xAxis === undefined ){
			
			 xAxis = new THREE.Vector3(); // right
			 yAxis = new THREE.Vector3(); // up
			 zAxis = new THREE.Vector3(); // front
			 
			 upTemp = new THREE.Vector3( 0, 1, 0 );
			 
			 rotationMatrix = new THREE.Matrix4();
		}

		// the front vector always points to the direction vector
		zAxis.copy( direction ).normalize();

		// avoid zero-length axis
		if ( zAxis.lengthSq() === 0 )
		{
			zAxis.z = 1;
		}

		// compute right vector
		xAxis.crossVectors( upTemp, zAxis );

		// avoid zero-length axis
		if ( xAxis.lengthSq() === 0 )
		{
			zAxis.x += 0.0001;
			xAxis.crossVectors( upTemp, zAxis ).normalize();
		}

		// compute up vector
		yAxis.crossVectors( zAxis, xAxis );

		// setup a rotation matrix of the basis
		rotationMatrix.makeBasis( xAxis, yAxis, zAxis );

		// apply rotation
		this.quaternion.setFromRotationMatrix( rotationMatrix );
	};

}() );

/**
 * Given a target position, this method rotates the entity by an amount not
 * greater than maxTurnRate until it directly faces the target.
 * 
 * @param {THREE.Vector3} targetPosition - The target position to face.
 * 
 * @returns {boolean} Is the entity facing the target?
 */
MovingEntity.prototype.isRotateToTarget = ( function() {

	var direction, rotationToTarget, quaternionToTarget;

	return function( targetPosition ) {

		var angle, t;

		if ( direction === undefined )
		{
			direction = new THREE.Vector3();
			rotationToTarget = new THREE.Matrix4();
			quaternionToTarget = new THREE.Quaternion();
		}

		// get direction of moving entity
		this.getDirection( direction );

		// first determine the angle between the look vector and the target
		angle = targetPosition.angleTo( direction );

		// return true if the player is facing the target
		if ( angle < 0.00001 )
		{
			return true;
		}

		// clamp the amount to turn to the max turn rate
		t = ( angle > this.maxTurnRate ) ? ( this.maxTurnRate / angle ) : 1;

		// get target rotation
		rotationToTarget.lookAt( targetPosition, this.position, this.object3D.up );
		quaternionToTarget.setFromRotationMatrix( rotationToTarget );

		// interpolate rotation
		this.quaternion.slerp( quaternionToTarget, t );

		// adjust velocity
		this.velocity.applyQuaternion( this.quaternion );

		return false;
	};

}() );

/**
 * Gets the speed of the moving entity.
 * 
 * @returns {number} The speed of the entity.
 */
MovingEntity.prototype.getSpeed = function() {

	return this.velocity.length();
};

/**
 * Gets the speed of the moving entity in squared space.
 * 
 * @returns {number} The speed of the entity.
 */
MovingEntity.prototype.getSpeedSq = function() {

	return this.velocity.lengthSq();
};

/**
 * Gets the normalized direction of the vehicle.
 * 
 * @param {THREE.Vector3} optionalTarget - The optional target vector.
 * 
 * @returns {THREE.Vector3} The direction vector.
 */
MovingEntity.prototype.getDirection = function( optionalTarget ) {
	
	var result = optionalTarget || new THREE.Vector3();

	return result.set( 0, 0, 1 ).applyQuaternion( this.quaternion ).normalize();
};

module.exports = MovingEntity;
},{"./GameEntity":48,"three":1}],50:[function(require,module,exports){
/**
 * @file This prototype represents the player body.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var GameEntity = require( "./GameEntity" );
var eventManager = require( "../../messaging/EventManager" );
var TOPIC = require( "../../messaging/Topic" );
var FirstPersonControls = require( "../../controls/FirstPersonControls" );
var system = require( "../../core/System" );

/**
 * Creates a player object.
 * 
 * @constructor
 * @augments GameEntity
 * 
 */
function Player( world ) {

	GameEntity.call( this );

	Object.defineProperties( this, {
		// the reference to the world object, so the player can access
		// grounds, walls etc.
		world : {
			value : world,
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the controls of the player
		controls : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the bounding volume of the player
		boundingVolume : {
			value : new THREE.Box3(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// this will be used as the parent object for the camera
		head : {
			value : new THREE.Object3D(),
			configurable : false,
			enumerable : true,
			writable : false
		}
	} );
	
	// create controls
	this.controls = new FirstPersonControls( this );
	
	// change the default type of the object3D.
	// this prevents the player object to be deleted 
	// within a stage change
	this.object3D.type = "Player";
	
	// build object hierarchy
	this.object3D.add( this.head );
}

Player.prototype = Object.create( GameEntity.prototype );
Player.prototype.constructor = Player;

/**
 * The update method of the player.
 * 
 * @param {number} delta - The time delta value.
 */
Player.prototype.update = ( function() {

	var oldPosition = new THREE.Vector3();
	var displacement = new THREE.Vector3();

	return function( delta ) {
		
		// only update the controls if the mouse pointer is captured AND
		// the controls are not locked
		if ( this.controls.isCaptured === true && this.controls.isLocked === false )
		{
			// store current position
			oldPosition.copy( this.position );
			
			// update the controls and retrieve new displacement values
			this.controls.update( delta, displacement );

			// translate the player to the new position. the used methods
			// translate the player object on the rotated cardinal axis
			this.object3D.translateX( displacement.x );
			this.object3D.translateY( displacement.y );
			this.object3D.translateZ( displacement.z );
			
			// update the bounding volume of the player
			this._updateBoundingVolume();

			// do ground and collision test. in this game scenario the
			// player can only move on valid grounds and if there is no
			// intersection
			if ( this._isPlayerOnGround() === true && this._isCollisionDetected() === false )
			{
				// calculate camera motions only if the player can move without
				// hindrance
				this.controls.calculateCameraMotion( delta, displacement );
			}
			else
			{
				// restore old position
				this.position.copy( oldPosition );
				
				// restore old bounding volume
				this._updateBoundingVolume();

				// reset camera position
				this.controls.resetCamera();
			}

			// only publish player status if multiplayer components are active
			if ( system.isMultiplayerActive === true )
			{
				this._publishPlayerStatus();
			}
		}
		else
		{
			// reset the camera position to its native position
			// if the player is not moving due to locked controls
			this.controls.resetCamera();
			
			// the bounding volume must also calculated if the controls are locked
			this._updateBoundingVolume();
		}

	};

}() );

/**
 * Sets the direction of the player.
 * 
 * @param {THREE.Vector3} direction - The new direction of the player.
 */
Player.prototype.setDirection = function( direction ) {

	this.controls.setDirection( direction );
};

/**
 * Returns the direction of the player.
 * 
 * @param {THREE.Vector3} optionalTarget - The optional target vector.
 * 
 * @returns {THREE.Vector3} The direction of the player.
 */
Player.prototype.getDirection = function( optionalTarget ) {
	
	var result = optionalTarget || new THREE.Vector3();

	return this.controls.getDirection( result );
};

/**
 * Returns the position of the head in world coordinates.
 * 
 * @param {THREE.Vector3} optionalTarget - The optional target vector.
 * 
 * @returns {THREE.Vector3} The position of the head.
 */
Player.prototype.getHeadPosition = function( optionalTarget ) {
	
	var result = optionalTarget || new THREE.Vector3();

	return this.head.getWorldPosition( result );
};

/**
 * Publish the world information of the player to all players in the multiplayer
 * session.
 */
Player.prototype._publishPlayerStatus = ( function() {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();

	return function() {

		position.copy( this.position );
		quaternion.copy( this.quaternion );

		eventManager.publish( TOPIC.MULTIPLAYER.PLAYER, {
			position : position,
			quaternion : quaternion
		} );

	};

}() );

/**
 * Updates the bounding volume of the player.
 */
Player.prototype._updateBoundingVolume = ( function() {

	var center = new THREE.Vector3();
	var size = new THREE.Vector3();

	return function() {

		// calculate the center of the player's body
		center.copy( this.position );
		center.y += this.head.position.y * 0.5;

		// calculate size of the player's body
		size.set( 4, this.head.position.y, 4 );

		// create bounding box
		this.boundingVolume.setFromCenterAndSize( center, size );
	};

}() );

/**
 * Checks, of the player is on a ground object.
 * 
 * @returns {boolean} Is the player on a ground?
 */
Player.prototype._isPlayerOnGround = ( function() {

	// this will be used for a intersection test to determine the distance to
	// the current ground
	var rayCaster = new THREE.Raycaster();

	// ray properties
	var origin = new THREE.Vector3();
	var direction = new THREE.Vector3( 0, -1, 0 );

	return function() {

		var intersects;

		// only do intersection test if there are grounds
		if ( this.world.grounds.length !== 0 )
		{
			origin.copy( this.position );
			origin.y += this.head.position.y;

			// set origin and direction of raycast
			rayCaster.set( origin, direction );
			rayCaster.far = this.head.position.y + 1;

			// do intersection test
			intersects = rayCaster.intersectObjects( this.world.grounds );

			// if there is an intersection, update the height of the player and return true
			if ( intersects.length > 0 )
			{
				this.position.y += ( this.head.position.y - intersects[ 0 ].distance );
				
				return true;
			}
			else
			{
				// no ground intersection
				return false;
			}
		}
		
		// no grounds
		return false;
	};

}() );

/**
 * This method checks, if there are collision between the any action objects in the
 * world and the player's bounding volume.
 * 
 * @returns {boolean} Is there a collision between an action object and the player.
 */
Player.prototype._isCollisionDetected = function() {

	var index, object;

	// now do the collision test with all objects
	for ( index = 0; index < this.world.actionObjects.length; index++ )
	{
		object =  this.world.actionObjects[ index ];

		// do collision detection but only with visible objects
		if ( object.mesh.visible === true && object.isIntersection( this.boundingVolume ) === true )
		{
			// exit method, because there is an intersection
			return true;
		}

	} // next object 

	// no intersection
	return false;
};

module.exports = Player;
},{"../../controls/FirstPersonControls":17,"../../core/System":27,"../../messaging/EventManager":69,"../../messaging/Topic":71,"./GameEntity":48,"three":1}],51:[function(require,module,exports){
/**
 * @file A simple vehicle that uses steering behaviors.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var MovingEntity = require( "./MovingEntity" );
var SteeringBehaviors = require( "../steering/SteeringBehaviors" );
var Smoother = require( "../steering/Smoother" );

/**
 * Creates a vehicle.
 * 
 * @constructor
 * @augments MovingEntity
 * 
 * @param {World} world - The reference to the world object.
 * @param {THREE.Object3D} object3D - The 3D object of the entity.
 * @param {number} numSamplesForSmoothing - How many samples the smoother will use to average the velocity.
 */
function Vehicle( world, object3D, numSamplesForSmoothing ) {

	MovingEntity.call( this, object3D );

	Object.defineProperties( this, {
		// the reference to the world object, so the vehicle can access
		// grounds, walls etc.
		world : {
			value : world,
			configurable : false,
			enumerable : true,
			writable : false
		},
		// an instance of the steering behavior prototype
		steering : {
			value : new SteeringBehaviors( this ),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// when true, smoothing is active
		isSmoothingOn : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// some steering behaviors give jerky looking movement. The following
		// member us are to smooth the vehicle's velocity
		_smoother : {
			value : new Smoother( numSamplesForSmoothing || 0 ),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this vector represents the average of the vehicle's heading vector
		// smoothed over the last few frames
		_smoothedVelocity : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
	
}

Vehicle.prototype = Object.create( MovingEntity.prototype );
Vehicle.prototype.constructor = Vehicle;

/**
 * Updates the position and orientation of the vehicle.
 * 
 * @param {number} delta - The time delta value.
 */
Vehicle.prototype.update = ( function() {

	var displacement, acceleration;

	return function( delta ) {

		if ( displacement === undefined )
		{
			displacement = new THREE.Vector3();
			acceleration = new THREE.Vector3();
		}

		// calculate steering force
		var steeringForce = this.steering.calculate( delta );

		// acceleration = force / mass
		acceleration.copy( steeringForce ).divideScalar( this.mass );

		// update velocity
		this.velocity.add( acceleration.multiplyScalar( delta ) );

		// make sure vehicle does not exceed maximum speed
		if ( this.getSpeedSq() > ( this.maxSpeed * this.maxSpeed ) )
		{
			this.velocity.normalize();

			this.velocity.multiplyScalar( this.maxSpeed );
		}

		// calculate displacement
		displacement.copy( this.velocity ).multiplyScalar( delta );

		// update the position
		this.position.add( displacement );

		// update the orientation if the vehicle has non zero speed
		if ( this.getSpeedSq() > 0.00000001 )
		{
			// check smoothing
			if ( this.isSmoothingOn === true )
			{
				// decouple velocity and heading. calculate the orientation
				// with an averaged velocity to avoid oscillations/judder.
				this._smoother.update( this.velocity, this._smoothedVelocity );

				this.rotateToDirection( this._smoothedVelocity );
			}
			else
			{
				// couple velocity and orientation
				this.rotateToDirection( this.velocity );
			}
		}

	};

}() );

module.exports = Vehicle;
},{"../steering/Smoother":67,"../steering/SteeringBehaviors":68,"./MovingEntity":49,"three":1}],52:[function(require,module,exports){
/**
 * @file Super prototype for states used by FSMs.
 * 
 * see "Programming Game AI by Example", Mat Buckland, Chapter 2
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates a new state.
 * 
 * @constructor
 * 
 */
function State() { }

/**
 * This executes when the state is entered.
 * 
 * @param {GameEntity} entity - A reference to the entity.
 */
State.prototype.enter = function( entity ) { };

/**
 * This is called by the FSM's update function each update step.
 * 
 * @param {GameEntity} entity - A reference to the entity.
 */
State.prototype.execute = function( entity ) { };

/**
 * This executes when the state is exited.
 * 
 * @param {GameEntity} entity - A reference to the entity.
 */
State.prototype.exit = function( entity ) { };

/**
 * This executes if the agent receives a message from the messaging system.
 * 
 * @param {GameEntity} entity - A reference to the entity.
 * @param {Telegram} telegram - The telegram of the message.
 * 
 * @returns {boolean} Is the message handled successfully by a state?
 */
State.prototype.onMessage = function( entity, telegram ) { return false; };

module.exports = State;
},{}],53:[function(require,module,exports){
/**
 * @file This prototype is a basic finite state machine used for AI logic.
 * 
 * see "Programming Game AI by Example", Mat Buckland, Chapter 2
 * 
 * @author Human Interactive
 */

"use strict";

var logger = require( "../../core/Logger" );
var State = require( "./State" );

/**
 * Creates a finite state machine.
 * 
 * @constructor
 * 
 * @param {GameEntity} owner - A reference to the agent that owns this instance.
 */
function StateMachine( owner ) {

	Object.defineProperties( this, {
		_owner : {
			value : owner,
			configurable : false,
			enumerable : true,
			writable : true
		},
		currentState : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// a record of the last state the agent was in
		previousState : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this state logic is called every time the FSM is updated
		globalState : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

/**
 * This method update the FSM. This method should not be called in render loop,
 * but in an separate loop for AI logic.
 */
StateMachine.prototype.update = function() {

	// if a global state exists, call its execute method
	if ( this.globalState !== null )
	{
		this.globalState.execute( this._owner );
	}

	// same for the current state
	if ( this.currentState !== null )
	{
		this.currentState.execute( this._owner );
	}
};

/**
 * Changes the state of the FSM.
 * 
 * @param {State} newState - The new state of the FSM.
 */
StateMachine.prototype.changeState = function( newState ) {

	// check type of parameter
	logger.assert( newState instanceof State, "StateMachine: State parameter is no instance of type \"State\"." );

	// keep a record of the previous state
	this.previousState = this.currentState;

	// call the exit method of the existing state
	this.currentState.exit( this._owner );

	// change state to the new state
	this.currentState = newState;

	// call the entry method of the new state
	this.currentState.enter( this._owner );
};

/**
 * Handles the messages of an agent.
 * 
 * @param {Telegram} telegram - The telegram of the message.
 * 
 * @returns {boolean} Is the message handled successfully by a state?
 */
StateMachine.prototype.handleMessage = function( telegram ) {

	// first see, if the current state is valid and that it can handle the
	// message
	if ( this.currentState !== null && this.currentState.onMessage( this._owner, telegram ) === true )
	{
		return true;
	}

	// if not, and if a global state has been implemented, send the message to
	// the global state
	if ( this.globalState !== null && this.globalState.onMessage( this._owner, telegram ) === true )
	{
		return true;
	}

	return false;
};

/**
 * This method changes state back to the previous state.
 */
StateMachine.prototype.revertToPrevoiusState = function() {

	this.changeState( this.previousState );
};

/**
 * Returns true, if the current state’s type is equal to the type of the object
 * passed as a parameter.
 * 
 * @returns {boolean} Is the current state equal to the passed parameter?
 */
StateMachine.prototype.isInState = function( state ) {

	return state === this.currentState;
};

module.exports = StateMachine;
},{"../../core/Logger":21,"./State":52}],54:[function(require,module,exports){
/**
 * @file Prototype to define an edge connecting two nodes. An edge has an
 * associated cost.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates a graph edge.
 * 
 * @constructor
 * 
 * @param {number} from - An edge connects two nodes. Valid node indices are always positive.
 * @param {number} to - An edge connects two nodes. Valid node indices are always positive.
 * @param {number} cost - The cost of traversing the edge
 */
function GraphEdge( from, to, cost ) {

	Object.defineProperties( this, {
		from : {
			value : from,
			configurable : false,
			enumerable : true,
			writable : true
		},
		to : {
			value : to,
			configurable : false,
			enumerable : true,
			writable : true
		},
		cost : {
			value : cost,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

/**
 * Tests, if two edges are equal.
 * 
 * @param {GraphEdge} edgeToCompare - The edge to compare.
 * 
 * @returns {boolean} Are both edges equal?
 */
GraphEdge.prototype.isEqual = function( edgeToCompare ) {

	return this.from === edgeToCompare.from && 
		   this.to === edgeToCompare.to && 
		   this.cost === edgeToCompare.cost;
};

/**
 * Clones the edge. Used by digraphes.
 * 
 * @returns {GraphEdge} The cloned edge.
 */
GraphEdge.prototype.clone = function(){
	
	return new this.constructor().copy( this );
};

/**
 * Copies all values from one edge to an other.
 * 
 * @returns {GraphEdge} The reference to the current edge.
 */
GraphEdge.prototype.copy = function( source ){
	
	this.from = source.from;
	this.to = source.to;
	this.cost = source.cost;
	
	return this;
};

module.exports = GraphEdge;
},{}],55:[function(require,module,exports){
/**
 * @file Some useful functions you can use with graphs.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var NavGraphNode = require( "./NavGraphNode" );
var NavGraphEdge = require( "./NavGraphEdge" );

var world = require( "../../core/World" );

/**
 * Creates a graph helper.
 * 
 * @constructor
 */
function GraphHelper() {

}

/**
 * Creates a graph based on a grid layout.
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {THREE.Vector2} dimension - The dimension of the grid.
 * @param {number} offset - The offset between nodes.
 */
GraphHelper.prototype.generateGridLayout = function( graph, dimension, offset ) {

	// first create all the nodes
	generateNodesGridLayout( graph, dimension, offset );

	// now to calculate the edges.
	generateEdges( graph, offset );

};

/**
 * Creates a helper mesh to visualize the grid. 
 * 
 * @param {THREE.Vector2} dimension - The dimension of the grid.
 * @param {number} offset - The offset between nodes.
 * @param {THREE.Color} color - The color of the grid.
 */
GraphHelper.prototype.createGridHelper = function( dimension, offset, color ) {

	var grid, gridSize, i;

	// increase the dimensions, because the nodes should be in the center
	// of a grid cell
	gridSize = dimension.clone();
	gridSize.addScalar( offset * 0.5 );

	// mesh properties
	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( {
		color : color || new THREE.Color( 0xffffff )
	} );

	// generate vertices for the grid
	for ( i = -gridSize.x; i <= gridSize.x; i += offset )
	{
		geometry.vertices.push( new THREE.Vector3( i, 0.01, -gridSize.y ), new THREE.Vector3( i, 0.01, gridSize.y ) );
	}

	for ( i = -gridSize.y; i <= gridSize.y; i += offset )
	{
		geometry.vertices.push( new THREE.Vector3( -gridSize.x, 0.01, i ), new THREE.Vector3( gridSize.x, 0.01, i ) );
	}

	// create the lines
	grid = new THREE.LineSegments( geometry, material );

	// prevent auto update
	grid.matrixAutoUpdate = false;
	grid.updateMatrix();

	world.addObject3D( grid );

};

/**
 * Creates helper meshes to visualize the nodes. 
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {THREE.Color} color - The color of the edges.
 * @param {number} size - The size of the helpers.
 */
GraphHelper.prototype.createNodeHelper = function( graph, color, size ) {
	
	var geometry = new THREE.PlaneBufferGeometry( size || 1, size || 1, 1, 1 );

	var mesh, i;

	// create for each node position a mesh as visual feedback
	for ( i = 0; i < graph.getNumberOfNodes(); i++ )
	{
		mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {
			color : color || new THREE.Color( 0xffffff ),
			side : THREE.DoubleSide
		} ) );

		// adjust mesh
		mesh.position.copy( graph.getNode( i ).position );
		mesh.rotation.set( Math.PI * -0.5, 0, 0 );
		
		// save a reference to the node
		// used for intersection tests
		mesh.userData.nodeIndex = i;

		// prevent auto update
		mesh.matrixAutoUpdate = false;
		mesh.updateMatrix();

		world.addObject3D( mesh );
	}
};

/**
 * Creates a helper mesh to visualize the edges. 
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {THREE.Color} color - The color of the edges.
 */
GraphHelper.prototype.createEdgeHelper = function( graph, color ) {

	var start, end, edges, lines, i, j;

	// mesh properties
	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( {
		color : color || new THREE.Color( 0xffffff )
	} );

	// iterate over all nodes
	for ( i = 0; i < graph.getNumberOfNodes(); i++ )
	{
		// get edges of the current node
		edges = graph.getEdgesOfNode( i );

		// extract the position of from/to and store them into the geometry for
		// the linesegements
		for ( j = 0; j < edges.length; j++ )
		{
			start = graph.getNode( edges[ j ].from ).position.clone();
			end = graph.getNode( edges[ j ].to ).position.clone();
			
			// lift the lines a bit
			start.y += 0.01;
			end.y += 0.01;
			
			// store the vertices in the geometry
			geometry.vertices.push( start, end );
		}
	}

	// create the lines
	lines = new THREE.LineSegments( geometry, material );

	// prevent auto update
	lines.matrixAutoUpdate = false;
	lines.updateMatrix();

	world.addObject3D( lines );
};

/**
 * Creates a helper mesh to visualize a path. The path object
 * is an array, that holds all node indices from a start to a
 * destination node.
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {object} path - The path as an array with node indices.
 * @param {THREE.Color} color - The color of the path.
 */
GraphHelper.prototype.createPathHelper = function( graph, path, color ) {

	var start, end, lines, i;

	// mesh properties
	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( {
		color : color || new THREE.Color( 0xff0000 )
	} );

	for ( i = 0; i < path.length - 1; i++ )
	{
		start = graph.getNode( path[ i ] ).position.clone();
		end = graph.getNode( path[ i + 1 ] ).position.clone();

		// lift the lines a bit
		start.y += 0.03;
		end.y += 0.03;
		
		// store the vertices in the geometry
		geometry.vertices.push( start, end );
	}

	// create the lines
	lines = new THREE.LineSegments( geometry, material );

	// prevent auto update
	lines.matrixAutoUpdate = false;
	lines.updateMatrix();

	world.addObject3D( lines );
};

/**
 * Creates a helper mesh to visualize a path. The path object
 * is an array, that holds all node indices from a start to a
 * destination node.
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {object} tree - An array with edges the search has examined
 * @param {THREE.Color} color - The color of the path.
 */
GraphHelper.prototype.createSearchTreeHelper = function( graph, tree, color ) {

	var start, end, edges, lines, i, j;

	// mesh properties
	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( {
		color : color || new THREE.Color( 0x00ff00 )
	} );

	// iterate over all edges
	for ( i = 0; i < tree.length; i++ )
	{
		// extract the position of from/to and store them into the geometry for
		// the linesegements
		start = graph.getNode( tree[ i ].from ).position.clone();
		end = graph.getNode( tree[ i ].to ).position.clone();

		// lift the lines a bit
		start.y += 0.02;
		end.y += 0.02;

		// store the vertices in the geometry
		geometry.vertices.push( start, end );

	}

	// create the lines
	lines = new THREE.LineSegments( geometry, material );

	// prevent auto update
	lines.matrixAutoUpdate = false;
	lines.updateMatrix();

	world.addObject3D( lines );
};

module.exports = new GraphHelper();

/**
 * Generates nodes based on a grid layout.
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {THREE.Vector2} dimension - The dimension of the grid.
 * @param {number} offset - The offset between nodes.
 */
function generateNodesGridLayout( graph, dimension, offset ) {

	var i, j;

	for ( i = -dimension.x; i <= dimension.x; i += offset )
	{
		for ( j = -dimension.y; j <= dimension.y; j += offset )
		{
			graph.addNode( new NavGraphNode( graph.getNextFreeNodeIndex(), new THREE.Vector3( i, 0, j ) ) );
		}
	}
}

/**
 * Generates edges based on existing nodes in the graph.
 * 
 * @param {SparseGraph} graph - The graph object.
 * @param {number} offset - The offset between nodes.
 */
function generateEdges( graph, offset ) {

	var i, j, node, neighbor, distance;

	// this will be used to determine the adjacent nodes
	var boundingSphere = new THREE.Sphere();

	// the radius is the length of the diagonal of a node area plus a little
	// buffer
	boundingSphere.radius = offset * Math.SQRT2 + 0.01;

	// iterate over all nodes
	for ( i = 0; i < graph.getNumberOfNodes(); i++ )
	{
		// retrieve node
		node = graph.getNode( i );

		// set the position of the bounding sphere to the current node
		boundingSphere.center.copy( node.position );

		// now check all other nodes for neighborhood
		for ( j = 0; j < graph.getNumberOfNodes(); j++ )
		{
			// the current node can't be its own neighbor
			if ( i !== j )
			{
				// retrieve neighbor
				neighbor = graph.getNode( j );

				// check, if the neighbor is within the radius
				if ( boundingSphere.containsPoint( neighbor.position ) === true )
				{
					// calculate distance, the cost of the edge
					distance = node.position.distanceTo( neighbor.position );

					// this neighbor is okay so it can be added
					graph.addEdge( new NavGraphEdge( i, j, distance ) );
				}
			}
		}
	}// next node

}
},{"../../core/World":31,"./NavGraphEdge":57,"./NavGraphNode":58,"three":1}],56:[function(require,module,exports){
/**
 * @file Node prototype to be used with graphs.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates a graph node.
 * 
 * @constructor
 * 
 * @param {number} index - Every node has an index. A valid index is >= 0.
 */
function GraphNode( index ) {

	Object.defineProperties( this, {
		index : {
			value : ( index >= 0 ) ? index : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

GraphNode.INVALID_NODE_INDEX = -1;

module.exports = GraphNode;
},{}],57:[function(require,module,exports){
/**
 * @file Prototype to define an edge connecting two navigation nodes.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

var GraphEdge = require( "./GraphEdge" );

/**
 * Creates a navigation graph edge.
 * 
 * @constructor
 * 
 * @param {number} from - An edge connects two nodes. Valid node indices are always positive.
 * @param {number} to - An edge connects two nodes. Valid node indices are always positive.
 * @param {number} cost - The cost of traversing the edge
 * @param {number} flags - The type of action the player needs to do to solve this edge.
 * @param {number} id - If this edge intersects with an object (such as a door or lift), then this is that object's ID. 
 */
function NavGraphEdge( from, to, cost, flags, id ) {
	
	GraphEdge.call( this, from, to, cost );

	Object.defineProperties( this, {
		flags : {
			value : flags || NavGraphEdge.FLAGS.NORMAL,
			configurable : false,
			enumerable : true,
			writable : true
		},
		iDofIntersectingEntity : {
			value : id || -1,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

NavGraphEdge.prototype = Object.create( GraphEdge.prototype );
NavGraphEdge.prototype.constructor = NavGraphEdge;

/**
 * Clones the navigation edge. Used by digraphes.
 * 
 * @returns {NavGraphEdge} The cloned edge.
 */
NavGraphEdge.prototype.clone = function(){
	
	return new this.constructor().copy( this );
};

/**
 * Copies all values from one edge to an other.
 * 
 * @returns {NavGraphEdge} The reference to the current edge.
 */
NavGraphEdge.prototype.copy = function( source ){
	
	GraphEdge.prototype.copy.call( this, source );
	
	this.flags = source.flags;
	this.iDofIntersectingEntity = source.iDofIntersectingEntity;
	
	return this;
};

NavGraphEdge.FLAGS = {
	NORMAL : 0,
	SWIM : 1,
	CRAWL : 2,
	CREEP : 3,
	JUMP : 4,
	FLY : 5,
	GRAPPLE : 6,
	GOES_THROUGH_DOOR : 7,
};

module.exports = NavGraphEdge;
},{"./GraphEdge":54}],58:[function(require,module,exports){
/**
 * @file Graph node for use in creating a navigation graph. This node contains
 * the position of the node and a pointer to a GameEntity... useful if you want
 * your nodes to represent health packs, gold mines and the like.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var GraphNode = require( "./GraphNode" );
/**
 * Creates a graph node.
 * 
 * @constructor
 * 
 * @param {number} index - Every node has an index. A valid index is >= 0.
 * @param {THREE.Vector3} position - The node's position
 * @param {object} extraInfo - Often you will require a navgraph node to contain
 * additional information. For example a node might represent a pickup such as
 * armor in which case "extraInfo" could be an enumerated value denoting the
 * pickup type, thereby enabling a search algorithm to search a graph for
 * specific items. Going one step further, "extraInfo" could be a pointer to the
 * instance of the item type the node is twinned with. This would allow a search
 * algorithm to test the status of the pickup during the search.
 */
function NavGraphNode( index, position, extraInfo ) {

	GraphNode.call( this, index );

	Object.defineProperties( this, {
		position : {
			value : position || new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		extraInfo : {
			value : extraInfo || null,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

NavGraphNode.prototype = Object.create( GraphNode.prototype );
NavGraphNode.prototype.constructor = NavGraphNode;

module.exports = NavGraphNode;
},{"./GraphNode":56,"three":1}],59:[function(require,module,exports){
/**
 * @file Graph prototype using the adjacency list representation.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates a sparse graph.
 * 
 * @constructor
 * 
 * @param {boolean} isDigraph - Is this a directed graph?
 */
function SparseGraph( isDigraph ) {

	Object.defineProperties( this, {
		// is this a directed graph?
		isDigraph : {
			value : isDigraph || false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the nodes that comprise this graph, organized in an associative array
		_nodes : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// an associative array of adjacency edge list. (each node index keys
		// into the list of edges associated with that node)
		_edges : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// the index of the next node to be added
		_nextNodeIndex : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

}

/**
 * Given a node this method first checks to see if the node has been added
 * previously but is now innactive. If it is, it is reactivated.
 * 
 * If the node has not been added previously, it is checked to make sure its
 * index matches the next node index before being added to the graph
 * 
 * @param {GraphNode} node - The node to add.
 * 
 * @returns {number} The index of the node.
 */
SparseGraph.prototype.addNode = function( node ) {

	if ( !this.isNodePresent( node.index ) )
	{
		// make sure the new node has been indexed correctly
		if ( node.index === this._nextNodeIndex )
		{
			this._nodes[ node.index ] = node;
			this._edges[ node.index ] = [];

			return this._nextNodeIndex++;
		}
		else
		{
			throw "ERROR: SparseGraph: Invalid node index. Unable to add node.";
		}

	}
	else
	{
		throw "ERROR: SparseGraph: Attempting to add a node with a duplicate index.";
	}
};

/**
 * Use this to add an edge to the graph. The method will ensure that the edge
 * passed as a parameter is valid before adding it to the graph. If the graph is
 * a digraph then a similar edge connecting the nodes in the opposite direction
 * will be automatically added.
 * 
 * @param {GraphEdge} edge - The edge to add.
 */
SparseGraph.prototype.addEdge = function( edge ) {

	var newEdge;

	// first make sure the from and to nodes exist within the graph and
	// both nodes are active before adding the edge
	if ( this.isNodePresent( edge.from ) && this.isNodePresent( edge.to ) )
	{
		// add the edge, first making sure it is unique
		if ( this._isEdgeUnique( edge.from, edge.to ) )
		{
			this._edges[ edge.from ].push( edge );
		}

		// if the graph is undirected we must add another connection in the
		// opposite direction
		if ( this.isDigraph === false )
		{
			// check to make sure the edge is unique before adding
			if ( this._isEdgeUnique( edge.to, edge.from ) )
			{
				// clone the edge
				newEdge = edge.clone();

				// change direction
				newEdge.from = edge.to;
				newEdge.to = edge.from;

				// add second edge
				this._edges[ edge.to ].push( newEdge );
			}
		}
	}
	else
	{
		throw "ERROR: SparseGraph: Invalid node indices of edge. Unable to add edge.";
	}

};

/**
 * Returns the reference to a specific node.
 * 
 * @param {number} index - The index of the node.
 * 
 * @returns {GraphNode} The reference to the node.
 */
SparseGraph.prototype.getNode = function( index ) {

	if ( this.isNodePresent( index ) )
	{
		return this._nodes[ index ];
	}
	else
	{
		throw "ERROR: SparseGraph: Invalid node index. Unable to get node.";
	}

};

/**
 * Returns the reference to a specific edge.
 * 
 * @param {number} from - The index of the first node.
 * @param {number} to -The index of the second node.
 * 
 * @returns {GraphEdge} The reference to the edge.
 */
SparseGraph.prototype.getEdge = function( from, to ) {
	
	var index, edge;

	// first, test if both node indices are present in the graph
	if ( this.isNodePresent( from ) && this.isNodePresent( to ) )
	{
		// then iterate over all edges of the "from" node and test, if "from/to"
		// is present in one single edge
		for ( index = 0; index <  this._edges[ from ].length; index++ )
		{
			edge = this._edges[ from ][ index ];
				
			if ( edge.to === to )
			{
				return edge;
			}
		}

		throw "ERROR: SparseGraph: From/to nodes are not connected to an edege.";
	}
	else
	{
		throw "ERROR: SparseGraph: Invalid from/to indices.";
	}
};

/**
 * Returns the edges outgoing of a node.
 * 
 * @param {number} from - The index the node.
 * 
 * @returns {object} An array of edges.
 */
SparseGraph.prototype.getEdgesOfNode = function( index ) {

	if ( this.isNodePresent( index ) )
	{
		return this._edges[ index ];
	}
	else
	{
		throw "ERROR: SparseGraph: Invalid node index. Unable to get edges of node.";
	}

};

/**
 * Returns the number of nodes present in the graph.
 * 
 * @returns {number} The total number of nodes.
 */
SparseGraph.prototype.getNumberOfNodes = function() {
	
	return Object.keys( this._nodes ).length;
};

/**
 * Returns the total number of edges present in the graph.
 * 
 * @returns {number} The total number of edges.
 */
SparseGraph.prototype.getNumberOfEdges = function() {

	var list, numberOfEdges = 0;

	// iterate over all edgeLists
	for ( list in this._edges )
	{
		if ( this._edges.hasOwnProperty( list ) )
		{
			// sum up the amount of edges
			numberOfEdges += this._edges[ list ].length;
		}
	}

	return numberOfEdges;
};

/**
 * Retrieves the next free node index.
 * 
 * @returns {number} The next valid node index.
 */
SparseGraph.prototype.getNextFreeNodeIndex = function() {

	return this._nextNodeIndex;
};

/**
 * Sets the cost of a specific edge.
 * 
 * @param {number} from - The index of the first node.
 * @param {number} to -The index of the second node.
 * @param {number} cost - The new cost to set.
 */
SparseGraph.prototype.setEdgeCost = function( from, to, cost ){
	
	var index, edge;
	
	// first, test if both node indices are present in the graph
	if ( this.isNodePresent( from ) && this.isNodePresent( to ) )
	{
		// determine the correct edge of the node's edge list
		for ( index = 0; index < this._edges[ from ].length; index++ )
		{
			edge = this._edges[ from ][ index ];

			if ( edge.to === to )
			{
				// assign the new cost
				edge.cost  = cost;
			}
		}
	}
	else
	{
		throw "ERROR: SparseGraph: Invalid from/to indices.";
	}
};

/**
 * Removes a node from the graph and removes any links to neighbouring nodes.
 * 
 * @param {number} index - The index of the node to remove.
 */
SparseGraph.prototype.removeNode = function( index ) {

	var i, j, edgeToNeighbor, edgeFromNeigbor;

	// if the node is present, delete it
	if ( this.isNodePresent( index ) )
	{
		delete this._nodes[ index ];

		// if the graph is not directed remove all edges leading to this node
		// and then clear the edges leading from the node
		if ( this.isDigraph === false )
		{
			// visit each neighbor and erase any edges leading to this node
			for ( i = 0; i < this._edges[ index ].length; i++ )
			{
				// this is a edge to a neighbor
				edgeToNeighbor = this._edges[ index ][ i ];

				// now iterate over all edges of the neighbor
				for ( j = 0; j < this._edges[ edgeToNeighbor.to ].length; j++ )
				{
					edgeFromNeigbor = this._edges[ edgeToNeighbor.to ][ j ];

					// if one of the edge leads to the specific node, remove the
					// edge from the list of the neighbor
					if ( edgeFromNeigbor.to === index )
					{
						this._edges[ edgeToNeighbor.to ].splice( j, 1 );

						break;
					}
				}
			}
		}
		else
		{
			// if a digraph remove the edges the slow way
			this._cullInvalidEdges();
		}
		
		// finally, clear this node's edges
		delete this._edges[ index ];
	}
	else
	{
		throw "ERROR: SparseGraph: Invalid node index. Unable to remove node.";
	}

};

/**
 * Removes the edge connecting "from" and "to" from the graph (if present). If a
 * digraph then the edge connecting the nodes in the opposite direction will
 * also be removed.
 * 
 * @param {number} from - The index of the first node.
 * @param {number} to -The index of the second node.
 */
SparseGraph.prototype.removeEdge = function( from, to ) {

	var index, currentEdge;

	// first, test if both node indices are present in the graph
	if ( this.isNodePresent( from ) && this.isNodePresent( to ) )
	{
		if ( this.isDigraph === false )
		{
			// delete the edge connecting the nodes in the opposite direction
			for ( index = 0; index < this._edges[ to ].length; index++ )
			{
				currentEdge = this._edges[ to ][ index ];

				if ( currentEdge.to === from )
				{
					this._edges[ to ].splice( index, 1 );
				}
			}
		}

		// delete the edge from the node's edge list
		for ( index = 0; index < this._edges[ from ].length; index++ )
		{
			currentEdge = this._edges[ from ][ index ];

			if ( currentEdge.to === to )
			{
				this._edges[ from ].splice( index, 1 );
			}
		}

	}
	else
	{
		throw "ERROR: SparseGraph: Invalid from/to indices.";
	}

};

/**
 * Removes all edges from the edge lists.
 */
SparseGraph.prototype.removeEdges = function() {
	
	var list;
	
	// iterate over all edgeLists
	for ( list in this._edges )
	{
		if ( this._edges.hasOwnProperty( list ) )
		{
			this._edges[list].length = 0;
		}
	}
};

/**
 * Clears the graph ready for new node insertions.
 */
SparseGraph.prototype.clear = function() {
	
	this._nodes = {};
	this._edges = {};
	this._nextNodeIndex = 0;
};

/**
 * Returns true if a node with the given index is present in the graph.
 * 
 * @param {number} index - The index of the node to check.
 * 
 * @returns {boolean} Is the node with the given index present in the graph?
 */
SparseGraph.prototype.isNodePresent = function( index ) {

	return this._nodes.hasOwnProperty( index );

};

/**
 * Returns true if an edge with the given "from/to" is present in the graph.
 * 
 * @param {number} from - The index of the first node.
 * @param {number} to -The index of the second node.
 * 
 * @returns {boolean} Is the edge with the given from/to present in the graph?
 */
SparseGraph.prototype.isEdgePresent = function( from, to ) {

	var index, edge;

	// first, test if both node indices are present in the graph
	if ( this.isNodePresent( from ) && this.isNodePresent( to ) )
	{
		// then iterate over all edges of the "from" node and test, if "from/to"
		// is present in one single edge
		for ( index = 0; index < this._edges[ from ].length; index++ )
		{
			edge = this._edges[ from ][ index ];

			if ( edge.to === to )
			{
				return true;
			}
		}

		return false;
	}
	else
	{
		return false;
	}

};

/**
 * Returns true if the edge is not present in the graph. Used when adding edges
 * to prevent duplication.
 * 
 * @param {number} from - The index of the first node.
 * @param {number} to -The index of the second node.
 * 
 * @returns {boolean} Is the edge unique?
 */
SparseGraph.prototype._isEdgeUnique = function( from, to ) {

	var index, edge;

	// iterate over all edges of the "from" node and test, if "from/to"
	// is present in one single edge
	for ( index = 0; index < this._edges[ from ].length; index++ )
	{
		edge = this._edges[ from ][ index ];

		if ( edge.to === to )
		{
			return false;
		}
	}

	return true;
};

/**
 * Iterates through all the edges in the graph and removes any that point to an
 * invalidated node.
 */
SparseGraph.prototype._cullInvalidEdges = function() {

	var list, index, edge;

	// iterate over all edge lists( edges per node )
	for ( list in this._edges )
	{
		if ( this._edges.hasOwnProperty( list ) )
		{
			// for each list, iterate over all edges
			for ( index = 0; index <  this._edges[list].length; index++ )
			{
				edge = this._edges[list][ index ];

				// if the from OR to index is invalid, delete the edge from
				// the list
				if ( !this._nodes.hasOwnProperty( edge.from ) || !this._nodes.hasOwnProperty( edge.to ) )
				{
					this._edges[list].splice( index, 1 );
				}

			}
		}
	}

};

module.exports = SparseGraph;
},{}],60:[function(require,module,exports){
/**
 * @file Some useful functions you can use with algorithms.
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates a algorithm helper.
 * 
 * @constructor
 */
function AlgorithmHelper() {

}

/**
 * Updates an entry in the queue.
 * 
 * @param {object} queue - The queue object.
 * @param {number} index - The index of the node to update.
 * @param {number} cost - The new cost value.
 */
AlgorithmHelper.prototype.updateEntryInQueue = function( queue, index, cost ) {

	for ( var i = 0; i < queue.length; i++ )
	{
		if ( queue[ i ].nodeIndex === index )
		{
			// update entry
			queue[ i ].cost = cost;

			// because the cost is less than it was previously, the queue
			// must be re-sorted to account for this
			queue.sort( this.sortQueueByCost );

			return;
		}
	}
};

/**
 * Compare function for queue.
 * 
 * @param {object} a - The first object to compare.
 * @param {object} b - The second object to compare.
 * 
 * @returns {number} Indicates, if the objects are greater, smaller or equal.
 */
AlgorithmHelper.prototype.sortQueueByCost = function( a, b ) {
	
	if ( a.cost > b.cost )
	{
		return 1;
	}
	
	if ( a.cost < b.cost )
	{
		return -1;
	}
	
	// a must be equal to b
	return 0;
};

module.exports = new AlgorithmHelper();
},{}],61:[function(require,module,exports){
/**
 * @file Prototype to implement the A* search algorithm.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

var algorithmHelper = require( "./AlgorithmHelper" );

var GraphNode = require( "../GraphNode" );
var GraphEdge = require( "../GraphEdge" );

/**
 * Creates a instance of the A* search algorithm.
 * 
 * @constructor
 * 
 * @param {SparseGraph} graph - A reference to the graph to be searched.
 * @param {number} source - The source node index.
 * @param {number} target - The target node index.
 * @param {AStarHeuristicPolicy} heuristic - A heuristic policy for use with the A* algorithm.
 */
function GraphSearchAStar( graph, source, target, heuristic ) {

	Object.defineProperties( this, {
		_graph : {
			value : graph,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_heuristic : {
			value : heuristic,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_source : {
			value : ( source >= 0 ) ? source : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_target : {
			value : ( target >= 0 ) ? target : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this array contains the edges that comprise the shortest path tree -
		// a directed sub-tree of the graph that encapsulates the best paths
		// from every node on the SPT to the source node
		_shortestPathTree : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// contains the "real" accumulative cost to a node
		_GCosts : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// contains the cost from adding this._GCosts[n] to the heuristic cost
		// from n to the target node.
		_FCosts : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this is an indexed (by node) object of "parent" edges leading to
		// nodes connected to the SPT but that have not been added to the SPT
		// yet. This is a little like the stack or queue used in BST and DST
		// searches.
		_searchFrontier : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// true if a path to the target has been found
		isFound : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
	
	// execute search
	this.isFound = this._search();
}

/**
 * Returns an array of node indices that comprise the shortest path from the
 * source to the target.
 * 
 * @returns {object} The path as an array with node indices.
 */
GraphSearchAStar.prototype.getPathToTarget = function() {

	var currentNode, path = [];

	// just return an empty path if no path to target found or if no target has
	// been specified
	if ( this.isFound === false || this._target < 0 )
	{
		return path;
	}

	// start with the target of the path
	path.unshift( currentNode = this._target );

	// while the current node is not the source node keep processing
	while ( ( currentNode !== this._source ) )
	{
		// determine the parent of the current node
		currentNode = this._shortestPathTree[ currentNode ].from;

		// push the new current node at the beginning of the array
		path.unshift( currentNode );
	}

	return path;
};

/**
 * Returns the array of edges that defines the SPT. If a target was given in the
 * constructor then this will be an SPT comprising of all the nodes examined
 * before the target was found, else it will contain all the nodes in the graph.
 * 
 * @returns {object} An array with edges the search has examined.
 */
GraphSearchAStar.prototype.getSearchTree = function() {
	
	var object = this._shortestPathTree;

	// this will return an array, converted from an object
	return Object.keys( object ).map( function( key ) {

		return object[ key ];
	} );
};

/**
 * Returns the total cost to the target.
 * 
 * @returns {number} The total cost to the target.
 */
GraphSearchAStar.prototype.getCostToTarget = function() {

	return this._GCosts[ this._target ];
};

/**
 * Returns the total cost to the given node
 * 
 * @param {number} index - The index of the node.
 * 
 * @returns {number} The total cost to the given node.
 */
GraphSearchAStar.prototype.getCostToNode = function( index ) {

	return this._GCosts[ index ];
};

/**
 * This method performs the A* algorithm.
 * 
 * @returns {boolean} Is a path found to the target?
 */
GraphSearchAStar.prototype._search = function() {

	var i, j, nextClosestNode, outgoingEdges, edge, HCost, GCost, FCost;

	// create a queue(FIFO) of objects, in JavaScript done via an array.
	// the objects in this queue will be sorted smallest to largest cost.
	var queue = [];

	// put the source node on the queue
	queue.push( {
		cost : 0,
		nodeIndex : this._source
	} );

	// while the queue is not empty
	while ( queue.length > 0 )
	{
		// get lowest cost node from the queue. Don't forget, the return value
		// is a node index, not the node itself. This node is the node not
		// already on the SPT that is the closest to the source node
		nextClosestNode = queue.shift().nodeIndex;

		// move this edge from the frontier to the shortest path tree
		if ( this._searchFrontier.hasOwnProperty( nextClosestNode ) === true )
		{
			this._shortestPathTree[ nextClosestNode ] = this._searchFrontier[ nextClosestNode ];
		}

		// if the target has been found exit
		if ( nextClosestNode === this._target )
		{
			return true;
		}

		// now relax the edges
		outgoingEdges = this._graph.getEdgesOfNode( nextClosestNode );

		for ( i = 0; i < outgoingEdges.length; i++ )
		{
			edge = outgoingEdges[ i ];
			
			// A* cost formula : F = G + H
			
			// H is the heuristic estimate of the distance to the target
			HCost = this._heuristic.calculate( this._graph, this._target, edge.to );

			// G is the cumulative cost to reach a node
			GCost = ( this._GCosts[ nextClosestNode ] || 0 ) + edge.cost;
			
			// F is the sum of G and H
			FCost = GCost + HCost;

			// if the node has not been added to the frontier, add it and update
			// the G and F costs
			if ( this._searchFrontier.hasOwnProperty( edge.to ) === false )
			{
				this._FCosts[ edge.to ] = FCost;
				this._GCosts[ edge.to ] = GCost;

				this._searchFrontier[ edge.to ] = edge;

				queue.push( {
					cost : FCost,
					nodeIndex : edge.to
				} );

				queue.sort( algorithmHelper.sortQueueByCost );
			}

			// else test to see if the cost to reach the destination node via
			// the current node is cheaper than the cheapest cost found so far.
			// If this path is cheaper, update its entry in the queue to reflect
			// the change, update the cost of the destination node and add the
			// edge to the frontier
			else if ( ( GCost < this._GCosts[ edge.to ] ) && ( this._shortestPathTree.hasOwnProperty( edge.to ) === false ) )
			{
				this._FCosts[ edge.to ] = FCost;
				this._GCosts[ edge.to ] = GCost;

				this._searchFrontier[ edge.to ] = edge;
				
				algorithmHelper.updateEntryInQueue( queue, edge.to, FCost );
			}
			
		} // next edge
	}
	
	// no path to target
	return false;
};

module.exports = GraphSearchAStar;
},{"../GraphEdge":54,"../GraphNode":56,"./AlgorithmHelper":60}],62:[function(require,module,exports){
/**
 * @file Prototype to implement a breadth first search.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

var GraphNode = require( "../GraphNode" );
var GraphEdge = require( "../GraphEdge" );

/**
 * Creates a instance of the breadth first search.
 * 
 * @constructor
 * 
 * @param {SparseGraph} graph - A reference to the graph to be searched.
 * @param {number} source - The source node index.
 * @param {number} target - The target node index.
 */
function GraphSearchBFS( graph, source, target ) {

	Object.defineProperties( this, {
		_graph : {
			value : graph,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_source : {
			value : ( source >= 0 ) ? source : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_target : {
			value : ( target >= 0 ) ? target : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this records the indexes of all the nodes that are visited as the
		// search progresses
		_visited : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this holds the route taken to the target. Given a node index, the
		// value at that index is the node's parent.
		_route : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// As the search progresses, this will hold all the edges the algorithm
		// has examined. THIS IS NOT NECESSARY FOR THE SEARCH, IT IS HERE PURELY
		// TO PROVIDE THE USER WITH SOME VISUAL FEEDBACK
		_spanningTree : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// true if a path to the target has been found
		isFound : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
	
	// execute search
	this.isFound = this._search();
}

/**
 * Returns an array of node indices that comprise the shortest path from the
 * source to the target.
 * 
 * @returns {object} The path as an array with node indices.
 */
GraphSearchBFS.prototype.getPathToTarget = function() {

	var currentNode, path = [];

	// just return an empty path if no path to target found or if no target has
	// been specified
	if ( this.isFound === false || this._target < 0 )
	{
		return path;
	}

	// start with the target of the path
	path.unshift( currentNode = this._target );

	// while the current node is not the source node keep processing
	while ( currentNode !== this._source )
	{
		// determine the parent of the current node
		currentNode = this._route[ currentNode ];

		// push the new current node at the beginning of the array
		path.unshift( currentNode );
	}

	return path;
};

/**
 * Returns an array containing references to all the edges the search has examined.
 * 
 * @returns {object} An array with edges the search has examined.
 */
GraphSearchBFS.prototype.getSearchTree = function() {

	return this._spanningTree;
};

/**
 * This method performs the BFS search.
 * 
 * @returns {boolean} Is a path found to the target?
 */
GraphSearchBFS.prototype._search = function() {

	var index, nextEdge, outgoingEdges;

	// create a queue(FIFO) of edges, in JavaScript done via an array
	var queue = [];

	// create a dummy edge and put on the queue
	var dummy = new GraphEdge( this._source, this._source, 0 );
	queue.push( dummy );

	// while there are edges in the queue keep searching
	while ( queue.length > 0 )
	{
		// grab the first edge and remove it from the queue
		nextEdge = queue.shift();

		// make a note of the parent of the node this edge points to
		this._route[ nextEdge.to ] = nextEdge.from;
		
		// put it on the tree. (making sure the dummy edge is not placed on the tree)
		if ( !nextEdge.isEqual( dummy ) )
		{
			this._spanningTree.unshift( nextEdge );
		}

		// if the target has been found the method can return success
		if ( nextEdge.to === this._target )
		{
			return true;
		}

		// determine outgoing edges
		outgoingEdges = this._graph.getEdgesOfNode( nextEdge.to );

		// push the edges leading from the node this edge points to onto the
		// stack (provided the edge does not point to a previously visited node)
		for ( index = 0; index < outgoingEdges.length; index++ )
		{
			// if the node hasn't already been visited we can push the
			// edge onto the queue
			if ( this._visited[ outgoingEdges[ index ].to ] !== true )
			{
				queue.push( outgoingEdges[ index ] );

				// and mark it visited
				this._visited[ outgoingEdges[ index ].to ] = true;
			}
			
		} // next edge
	}

	// no path to target
	return false;
};

module.exports = GraphSearchBFS;
},{"../GraphEdge":54,"../GraphNode":56}],63:[function(require,module,exports){
/**
 * @file Prototype to implement a depth first search.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

var GraphNode = require( "../GraphNode" );
var GraphEdge = require( "../GraphEdge" );

/**
 * Creates a instance of the depth first search.
 * 
 * @constructor
 * 
 * @param {SparseGraph} graph - A reference to the graph to be searched.
 * @param {number} source - The source node index.
 * @param {number} target - The target node index.
 */
function GraphSearchDFS( graph, source, target ) {

	Object.defineProperties( this, {
		_graph : {
			value : graph,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_source : {
			value : ( source >= 0 ) ? source : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_target : {
			value : ( target >= 0 ) ? target : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this records the indexes of all the nodes that are visited as the
		// search progresses
		_visited : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this holds the route taken to the target. Given a node index, the
		// value at that index is the node's parent.
		_route : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// true if a path to the target has been found
		isFound : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
	
	// execute search
	this.isFound = this._search();
}

/**
 * Returns an array of node indices that comprise the shortest path from the
 * source to the target.
 * 
 * @returns {object} The path as an array with node indices.
 */
GraphSearchDFS.prototype.getPathToTarget = function() {

	var currentNode, path = [];

	// just return an empty path if no path to target found or if no target has
	// been specified
	if ( this.isFound === false || this._target < 0 )
	{
		return path;
	}

	// start with the target of the path
	path.unshift( currentNode = this._target );

	// while the current node is not the source node keep processing
	while ( currentNode !== this._source )
	{
		// determine the parent of the current node
		currentNode = this._route[ currentNode ];

		// push the new current node at the beginning of the array
		path.unshift( currentNode );
	}

	return path;
};

/**
 * This method performs the DFS search.
 * 
 * @returns {boolean} Is a path found to the target?
 */
GraphSearchDFS.prototype._search = function() {

	var index, nextEdge, outgoingEdges;

	// create a stack(LIFO) of edges, in JavaScript done via an array
	var stack = [];

	// create a dummy edge and put on the stack
	stack.push( new GraphEdge( this._source, this._source, 0 ) );

	// while there are edges in the stack keep searching
	while ( stack.length > 0 )
	{
		// grab the next edge and remove it from the stack
		nextEdge = stack.pop();

		// make a note of the parent of the node this edge points to
		this._route[ nextEdge.to ] = nextEdge.from;

		// and mark it visited
		this._visited[ nextEdge.to ] = true;

		// if the target has been found the method can return success
		if ( nextEdge.to === this._target )
		{
			return true;
		}
		
		// determine outgoing edges
		outgoingEdges = this._graph.getEdgesOfNode( nextEdge.to );

		// push the edges leading from the node this edge points to onto the
		// stack (provided the edge does not point to a previously visited node)
		for ( index = 0; index < outgoingEdges.length; index++ )
		{
			if ( this._visited[ outgoingEdges[ index ].to ] !== true )
			{
				stack.push( outgoingEdges[ index ] );
			}
			
		} // next edge
	}
	
	// no path to target
	return false;
};

module.exports = GraphSearchDFS;
},{"../GraphEdge":54,"../GraphNode":56}],64:[function(require,module,exports){
/**
 * @file Prototype to implement dijkstra’s shortest path algorithm.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

var algorithmHelper = require( "./AlgorithmHelper" );

var GraphNode = require( "../GraphNode" );
var GraphEdge = require( "../GraphEdge" );

/**
 * Creates a instance of dijkstra’s shortest path algorithm.
 * 
 * @constructor
 * 
 * @param {SparseGraph} graph - A reference to the graph to be searched.
 * @param {number} source - The source node index.
 * @param {number} target - The target node index.
 */
function GraphSearchDijkstra( graph, source, target ) {

	Object.defineProperties( this, {
		_graph : {
			value : graph,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_source : {
			value : ( source >= 0 ) ? source : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_target : {
			value : ( target >= 0 ) ? target : GraphNode.INVALID_NODE_INDEX,
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this array contains the edges that comprise the shortest path tree -
		// a directed sub-tree of the graph that encapsulates the best paths
		// from every node on the SPT to the source node
		_shortestPathTree : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this is indexed into by node index and holds the total cost of the
		// best path found so far to the given node. For example,
		// this._costToThisNode[5] will hold the total cost of all the edges
		// that comprise the best path to node 5 found so far in the search (if
		// node 5 is present and has been visited of course).
		_costToThisNode : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this is an indexed (by node) object of "parent" edges leading to
		// nodes connected to the SPT but that have not been added to the SPT
		// yet. This is a little like the stack or queue used in BST and DST
		// searches.
		_searchFrontier : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		// true if a path to the target has been found
		isFound : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	// execute search
	this.isFound = this._search();
}

/**
 * Returns an array of node indices that comprise the shortest path from the
 * source to the target.
 * 
 * @returns {object} The path as an array with node indices.
 */
GraphSearchDijkstra.prototype.getPathToTarget = function() {

	var currentNode, path = [];

	// just return an empty path if no path to target found or if no target has
	// been specified
	if ( this.isFound === false || this._target < 0 )
	{
		return path;
	}

	// start with the target of the path
	path.unshift( currentNode = this._target );

	// while the current node is not the source node keep processing
	while ( ( currentNode !== this._source ) )
	{
		// determine the parent of the current node
		currentNode = this._shortestPathTree[ currentNode ].from;

		// push the new current node at the beginning of the array
		path.unshift( currentNode );
	}

	return path;
};

/**
 * Returns the array of edges that defines the SPT. If a target was given in the
 * constructor then this will be an SPT comprising of all the nodes examined
 * before the target was found, else it will contain all the nodes in the graph.
 * 
 * @returns {object} An array with edges the search has examined.
 */
GraphSearchDijkstra.prototype.getSearchTree = function() {
	
	var object = this._shortestPathTree;

	// this will return an array, converted from an object
	return Object.keys( object ).map( function( key ) {

		return object[ key ];
	} );
};

/**
 * Returns the total cost to the target.
 * 
 * @returns {number} The total cost to the target.
 */
GraphSearchDijkstra.prototype.getCostToTarget = function() {

	return this._costToThisNode[ this._target ];
};

/**
 * Returns the total cost to the given node
 * 
 * @param {number} index - The index of the node.
 * 
 * @returns {number} The total cost to the given node.
 */
GraphSearchDijkstra.prototype.getCostToNode = function( index ) {

	return this._costToThisNode[ index ];
};

/**
 * This method performs the dijkstra’s shortest path algorithm.
 * 
 * @returns {boolean} Is a path found to the target?
 */
GraphSearchDijkstra.prototype._search = function() {

	var i, j, nextClosestNode, outgoingEdges, edge, newCost;

	// create a queue(FIFO) of objects, in JavaScript done via an array.
	// the objects in this queue will be sorted smallest to largest cost.
	var queue = [];

	// put the source node on the queue
	queue.push( {
		cost : 0,
		nodeIndex : this._source
	} );

	// while the queue is not empty
	while ( queue.length > 0 )
	{
		// get lowest cost node from the queue. Don't forget, the return value
		// is a node index, not the node itself. This node is the node not
		// already on the SPT that is the closest to the source node
		nextClosestNode = queue.shift().nodeIndex;

		// move this edge from the frontier to the shortest path tree
		if ( this._searchFrontier.hasOwnProperty( nextClosestNode ) === true )
		{
			this._shortestPathTree[ nextClosestNode ] = this._searchFrontier[ nextClosestNode ];
		}

		// if the target has been found exit
		if ( nextClosestNode === this._target )
		{
			return true;
		}

		// now relax the edges
		outgoingEdges = this._graph.getEdgesOfNode( nextClosestNode );

		for ( i = 0; i < outgoingEdges.length; i++ )
		{
			edge = outgoingEdges[ i ];

			// the total cost to the node this edge points to is the cost to the
			// current node plus the cost of the edge connecting them.
			newCost = ( this._costToThisNode[ nextClosestNode ] || 0 ) + edge.cost;

			// if this edge has never been on the frontier make a note of the
			// cost to get to the node it points to, then add the edge to the
			// frontier and the destination node to the queue
			if ( this._searchFrontier.hasOwnProperty( edge.to ) === false )
			{
				this._costToThisNode[ edge.to ] = newCost;

				this._searchFrontier[ edge.to ] = edge;

				queue.push( {
					cost : newCost,
					nodeIndex : edge.to
				} );

				queue.sort( algorithmHelper.sortQueueByCost );
			}

			// else test to see if the cost to reach the destination node via
			// the current node is cheaper than the cheapest cost found so far.
			// If this path is cheaper, update its entry in the queue to reflect
			// the change, update the cost of the destination node and add the
			// edge to the frontier
			else if ( ( newCost < this._costToThisNode[ edge.to ] ) && ( this._shortestPathTree.hasOwnProperty( edge.to ) === false ) )
			{
				this._costToThisNode[ edge.to ] = newCost;

				this._searchFrontier[ edge.to ] = edge;
				
				algorithmHelper.updateEntryInQueue( queue, edge.to, newCost );
			}
			
		} // next edge
	}
	
	// no path to target
	return false;
};

module.exports = GraphSearchDijkstra;
},{"../GraphEdge":54,"../GraphNode":56,"./AlgorithmHelper":60}],65:[function(require,module,exports){
/**
 * @file This prototype defines heuristic policies for use with the A* search
 * algorithm.
 * 
 * see: "Programming Game AI by Example", Chapter: "The Secret Life of Graphs",
 * by Mat Buckland
 * 
 * @author Human Interactive
 */

"use strict";

/**
 * Creates the interface of a heuristic policy.
 * 
 * @constructor
 */
function HeuristicPolicy() {
}

/**
 * Calculates a heuristic estimate.
 * 
 * @param {number} node1 - The index of the first node.
 * @param {number} node2 - The index of the second node.
 * 
 * @returns {number} The heuristic estimate.
 */
HeuristicPolicy.prototype.calculate = function( node1, node2 ) {

	throw "ERROR: HeuristicPolicy: Policy needs to be implemented by inheriting prototype";
};

/**
 * Heuristic policy "Euclid"
 * -------------------------------------------------------------------------
 */

/**
 * Creates a euclidean heuristic (straight-line distance).
 * 
 * @constructor
 */
function HeuristicPolicyEuclid() {

	HeuristicPolicy.call( this );
}

HeuristicPolicyEuclid.prototype = Object.create( HeuristicPolicy.prototype );
HeuristicPolicyEuclid.prototype.constructor = HeuristicPolicyEuclid;

/**
 * Calculates the straight line distance from node1 to node2.
 * 
 * @param {SparseGraph} graph - A reference to the graph.
 * @param {number} node1 - The index of the first node.
 * @param {number} node2 - The index of the second node.
 * 
 * @returns {number} The heuristic estimate.
 */
HeuristicPolicyEuclid.prototype.calculate = function( graph, node1, node2 ) {

	return graph.getNode( node1 ).position.distanceTo( graph.getNode( node2 ).position );
};

/**
 * Heuristic policy "EuclidSq"
 * -------------------------------------------------------------------------
 */

/**
 * Creates a euclidean heuristic (straight-line distance in squared space).
 * 
 * @constructor
 */
function HeuristicPolicyEuclidSq() {

	HeuristicPolicy.call( this );
}

HeuristicPolicyEuclidSq.prototype = Object.create( HeuristicPolicy.prototype );
HeuristicPolicyEuclidSq.prototype.constructor = HeuristicPolicyEuclidSq;

/**
 * Calculates the straight line distance in squared space from node1 to node2.
 * 
 * @param {SparseGraph} graph - A reference to the graph.
 * @param {number} node1 - The index of the first node.
 * @param {number} node2 - The index of the second node.
 * 
 * @returns {number} The heuristic estimate.
 */
HeuristicPolicyEuclidSq.prototype.calculate = function( graph, node1, node2 ) {

	return graph.getNode( node1 ).position.distanceToSquared( graph.getNode( node2 ).position );
};

/**
 * Heuristic policy "Dijkstra"
 * -------------------------------------------------------------------------
 */

/**
 * You can use this class to turn the A* algorithm into Dijkstra's search. This
 * is because Dijkstra's is equivalent to an A* search using a heuristic value
 * that is always equal to zero.
 * 
 * @constructor
 */
function HeuristicPolicyDijkstra() {

	HeuristicPolicy.call( this );
}

HeuristicPolicyDijkstra.prototype = Object.create( HeuristicPolicy.prototype );
HeuristicPolicyDijkstra.prototype.constructor = HeuristicPolicyDijkstra;

/**
 * Returns always a zero value.
 * 
 * @param {SparseGraph} graph - A reference to the graph.
 * @param {number} node1 - The index of the first node.
 * @param {number} node2 - The index of the second node.
 * 
 * @returns {number} The heuristic estimate.
 */
HeuristicPolicyDijkstra.prototype.calculate = function( graph, node1, node2 ) {

	return 0;
};

module.exports = {
	Euclidean : new HeuristicPolicyEuclid(),
	EuclideanSq : new HeuristicPolicyEuclidSq(),
	Dijkstra : new HeuristicPolicyDijkstra()
};
},{}],66:[function(require,module,exports){
/**
 * @file Prototype to define, manage, and traverse a path defined by a series of
 * 3D vectors.
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var logger = require( "../../core/Logger" );

/**
 * Creates a new path.
 * 
 * @constructor
 * 
 * @param {boolean} loop - Flag to indicate if the path should be looped.
 */
function Path( loop ) {

	Object.defineProperties( this, {
		loop : {
			value : loop || false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		_waypoints : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		_index : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
}

/**
 * Adds a waypoint to the end of the path.
 * 
 * @param {THREE.Vector3} waypoint - The waypoint to add.
 * 
 * @returns {Path} The reference to the instance.
 */
Path.prototype.addWaypoint = function( waypoint ) {

	this._waypoints.push( waypoint );

	return this;
};

/**
 * Clears the path.
 * 
 * @returns {Path} The reference to the instance.
 */
Path.prototype.clear = function() {

	this._waypoints.length = 0;

	return this;
};

/**
 * Returns true if the end of the array has been reached.
 * 
 * @returns {boolean} Is the end of the array reached.
 */
Path.prototype.isFinished = function() {

	return this.loop === true ? false : ( this._index === this._waypoints.length - 1 );
};

/**
 * Moves the index to the next waypoint in the array.
 * 
 * @returns {Path} The reference to the instance.
 */
Path.prototype.setNextWaypoint = function() {

	logger.assert( this._waypoints.length > 0, "Path: No waypoints are assigned to path object." );

	if ( ++this._index === this._waypoints.length )
	{
		if ( this.loop === true )
		{
			this._index = 0;
		}
		else
		{
			this._index--;
		}

	}

	return this;
};

/**
 * Returns the current waypoint.
 * 
 * @returns {THREE.Vector3} The current waypoint.
 */
Path.prototype.getCurrentWaypoint = function() {

	return this._waypoints[ this._index ];
};

/**
 * Creates a random path which is bound by a bounding box.
 * 
 * @param {number} Number of waypoints.
 * @param {THREE.Box3} This bounding box describes the area of points.
 * 
 * @returns {Path} The reference to the instance.
 */
Path.prototype.createRandomPath = function( numberOfWaypoints, boundingBox ) {

	// buffer some entities
	var radialDistance = new THREE.Vector3();
	var axis = new THREE.Vector3( 0, 1, 0 );
	var spacing = 2 * Math.PI / numberOfWaypoints;
	var center = boundingBox.center();

	// clear existing waypoints
	this.clear();

	// create new waypoints
	for ( var index = 0; index < numberOfWaypoints; index++ )
	{
		var waypoint = new THREE.Vector3();

		// new random position on planar surface
		radialDistance.x = THREE.Math.randFloat( boundingBox.min.x * 0.2, boundingBox.min.x );
		radialDistance.y = 0;
		radialDistance.z = THREE.Math.randFloat( boundingBox.min.z * 0.2, boundingBox.min.z );

		waypoint.copy( radialDistance );

		// rotate around y-axis to better distribute the waypoints
		waypoint.applyAxisAngle( axis, spacing * index );

		// add center value
		waypoint.x += center.x;
		waypoint.y += center.y;
		waypoint.z += center.z;

		// add waypoint to array
		this.addWaypoint( waypoint );
	}

	return this;
};

module.exports = Path;
},{"../../core/Logger":21,"three":1}],67:[function(require,module,exports){
/**
 * @file Prototype to help calculate the average value of a history of vector
 * values.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates a new smoother.
 * 
 * @constructor
 * 
 * @param {number} numberOfSamples - How many samples the smoother will use to
 * average a value.
 */
function Smoother( numberOfSamples ) {

	Object.defineProperties( this, {
		_numberOfSamples : {
			value : numberOfSamples || 10,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_history : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		_slot : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// initialize history with objects
	for ( var index = 0; index < this._numberOfSamples; index++ )
	{
		this._history[ index ] = new THREE.Vector3();
	}
}

/**
 * Each time you want to get a new average, feed it the most recent value and
 * this method will return an average over the last numberOfSamples updates.
 * 
 * @param {THREE.Vector3} mostRecentValue - The most recent value to add.
 * @param {THREE.Vector3} average - The target average vector.
 */
Smoother.prototype.update = function( mostRecentValue, average ) {

	// ensure, average is a zero vector
	average.set( 0, 0, 0 );

	// make sure the slot index wraps around
	if ( this._slot === this._numberOfSamples )
	{
		this._slot = 0;
	}

	// overwrite the oldest value with the newest
	this._history[ this._slot ].copy( mostRecentValue );

	// increase slot index
	this._slot++;

	// now calculate the average of the history array
	for ( var index = 0; index < this._numberOfSamples; index++ )
	{
		average.add( this._history[ index ] );
	}

	average.divideScalar( this._numberOfSamples );

};

module.exports = Smoother;
},{"three":1}],68:[function(require,module,exports){
/**
 * @file Prototype to encapsulate steering behaviors for a vehicle.
 * 
 * see "Programming Game AI by Example", Mat Buckland, Chapter 3
 * 
 * @author Human Interactive
 */
"use strict";

var THREE = require( "three" );

var logger = require( "../../core/Logger" );

/**
 * Creates a steering behaviors instance.
 * 
 * @constructor
 * 
 * @param {Vehicle} vehicle - The vehicle agent.
 */
function SteeringBehaviors( vehicle ) {

	Object.defineProperties( this, {
		vehicle : {
			value : vehicle,
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the current target
		target : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// these can be used to keep track of friends, pursuers or prey
		targetAgent1 : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		targetAgent2 : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// use these values to tweak the amount that each steering force
		// contributes to the total steering force
		weights : {
			value : {
				seek : 1,
				flee : 1,
				arrive : 1,
				wander : 1,
				cohesion : 4,
				separation : 1,
				alignment : 2,
				obstacleAvoidance : 10,
				wallAvoidance : 10,
				followPath : 1,
				pursuit : 1,
				evade : 1,
				interpose : 1,
				hide : 1,
				flock : 1,
				offsetPursuit : 1
			},
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the list of waypoints to follow
		path : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// distance from the hiding spot
		distanceFromBoundary : {
			value : 10,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// amount of deceleration for arrive behavior
		deceleration : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// offset for offset pursuit behavior
		offset : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// panic distance for flee and evade behavior
		panicDistance : {
			value : 50,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the distance a waypoint is set to the new target
		waypointSeekDist : {
			value : 5,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the length of the "feeler/s" used in wall detection
		wallDetectionFeelerLength : {
			value : 20,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the radius of the constraining circle for the wander behavior
		wanderRadius : {
			value : 5,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the distance the wander sphere is projected in front of the agent
		wanderDistance : {
			value : 10,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum amount of displacement along the sphere each frame
		wanderJitter : {
			value : 80,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// how close a neighbour must be before an agent perceives it (considers
		// it to be within its neighborhood)
		viewDistance : {
			value : 200,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the actual target of the wander behavior
		_wanderTarget : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : false,
			writable : true
		},
		// the calculated steering force per simulation step
		_steeringForce : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : false,
			writable : true
		},
		// bitmask for enable/ disable behaviors
		_behaviorFlag : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// array with "feelers" for wall avoidance
		_feelers : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// array with neighbors for flocking
		_neighbors : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );

	this.setupWanderTarget();
}

/**
 * Calculates and sums the steering forces from any active behaviors.
 * 
 * @param {number} delta - The time delta value.
 * @param {THREE.Vector3} optionalTarget - The optional target vector.
 * 
 * @returns {THREE.Vector3} The steering force.
 */
SteeringBehaviors.prototype.calculate = function( delta, optionalTarget ) {
	
	var result = optionalTarget || new THREE.Vector3();

	// preparations
	this._prepareCalculation();

	// summing method
	this._calculatePrioritized( delta );
	
	// copy steering force to result
	return result.copy( this._steeringForce );
};

/**
 * This method calls each active steering behavior in order of priority and
 * accumulates their forces until the max steering force magnitude is reached,
 * at which time the function returns the steering force accumulated to that
 * point.
 * 
 * @param {number} delta - The time delta value.
 */
SteeringBehaviors.prototype._calculatePrioritized = ( function() {

	var force;

	return function( delta ) {

		if ( force === undefined )
		{
			force = new THREE.Vector3();
		}

		// wall avoidance
		if ( this._isOn( SteeringBehaviors.TYPES.WALLAVOIDANCE ) )
		{
			force.set( 0, 0, 0 );

			this._wallAvoidance( force );

			force.multiplyScalar( this.weights.wallAvoidance );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// obstacle avoidance
		if ( this._isOn( SteeringBehaviors.TYPES.OBSTACLEAVOIDANCE ) )
		{
			force.set( 0, 0, 0 );

			this._obstacleAvoidance( force );

			force.multiplyScalar( this.weights.obstacleAvoidance );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// evade
		if ( this._isOn( SteeringBehaviors.TYPES.EVADE ) )
		{
			logger.assert( this.targetAgent1 !== null, "SteeringBehaviors: Evade target not assigned" );

			force.set( 0, 0, 0 );

			this._evade( force, this.targetAgent1 );

			force.multiplyScalar( this.weights.evade );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// separation
		if ( this._isOn( SteeringBehaviors.TYPES.SEPARATION ) )
		{
			force.set( 0, 0, 0 );

			this._separation( force );

			force.multiplyScalar( this.weights.separation );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// alignment
		if ( this._isOn( SteeringBehaviors.TYPES.ALIGNMENT ) )
		{
			force.set( 0, 0, 0 );

			this._alignment( force );

			force.multiplyScalar( this.weights.alignment );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// cohesion
		if ( this._isOn( SteeringBehaviors.TYPES.COHESION ) )
		{
			force.set( 0, 0, 0 );

			this._cohesion( force );

			force.multiplyScalar( this.weights.cohesion );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// flee
		if ( this._isOn( SteeringBehaviors.TYPES.FLEE ) )
		{
			force.set( 0, 0, 0 );

			this._flee( force, this.target );

			force.multiplyScalar( this.weights.flee );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// seek
		if ( this._isOn( SteeringBehaviors.TYPES.SEEK ) )
		{
			force.set( 0, 0, 0 );

			this._seek( force, this.target );

			force.multiplyScalar( this.weights.seek );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// arrive
		if ( this._isOn( SteeringBehaviors.TYPES.ARRIVE ) )
		{
			force.set( 0, 0, 0 );

			this._arrive( force, this.target, this.deceleration );

			force.multiplyScalar( this.weights.arrive );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// wander
		if ( this._isOn( SteeringBehaviors.TYPES.WANDER ) )
		{
			force.set( 0, 0, 0 );

			this._wander( force, delta );

			force.multiplyScalar( this.weights.wander );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// pursuit
		if ( this._isOn( SteeringBehaviors.TYPES.PURSUIT ) )
		{
			logger.assert( this.targetAgent1 !== null, "SteeringBehaviors: Pursuit target not assigned" );

			force.set( 0, 0, 0 );

			this._pursuit( force, this.targetAgent1 );

			force.multiplyScalar( this.weights.pursuit );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// offset pursuit
		if ( this._isOn( SteeringBehaviors.TYPES.OFFSETPURSUIT ) )
		{
			logger.assert( this.targetAgent1 !== null, "SteeringBehaviors: Pursuit target not assigned" );

			force.set( 0, 0, 0 );

			this._offsetPursuit( force, this.targetAgent1, this.offset );

			force.multiplyScalar( this.weights.offsetPursuit );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// interpose
		if ( this._isOn( SteeringBehaviors.TYPES.INTERPOSE ) )
		{
			logger.assert( this.targetAgent1 !== null && this.targetAgent2 !== null, "SteeringBehaviors: Interpose targets not assigned" );

			force.set( 0, 0, 0 );

			this._interpose( force, this.targetAgent1, this.targetAgent2 );

			force.multiplyScalar( this.weights.interpose );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// hide
		if ( this._isOn( SteeringBehaviors.TYPES.HIDE ) )
		{
			logger.assert( this.targetAgent1 !== null, "SteeringBehaviors: Hide target not assigned" );

			force.set( 0, 0, 0 );

			this._hide( force, this.targetAgent1 );

			force.multiplyScalar( this.weights.hide );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

		// follow path
		if ( this._isOn( SteeringBehaviors.TYPES.FOLLOWPATH ) )
		{
			force.set( 0, 0, 0 );

			this._followPath( force );

			force.multiplyScalar( this.weights.followPath );

			if ( !this._accumulateForce( force ) )
			{
				return;
			}

		}

	};

}() );

/**
 * This function calculates how much of its max steering force the vehicle has
 * left to apply and then applies that amount of the force to add.
 * 
 * @param {THREE.Vector3} forceToAdd - The time delta value.
 * 
 * @returns {boolean} The steering force.
 */
SteeringBehaviors.prototype._accumulateForce = function( forceToAdd ) {

	var magnitudeSoFar, magnitudeRemaining, magnitudeToAdd;

	// calculate how much steering force the vehicle has used so far
	magnitudeSoFar = this._steeringForce.length();

	// calculate how much steering force remains to be used by this vehicle
	magnitudeRemaining = this.vehicle.maxForce - magnitudeSoFar;

	// return false if there is no more force left to use
	if ( magnitudeRemaining <= 0 )
	{
		return false;
	}

	// calculate the magnitude of the force we want to add
	magnitudeToAdd = forceToAdd.length();

	// restrict the magnitude of forceToAdd, so we don't exceed the
	// maximum force of the vehicle
	if ( magnitudeToAdd > magnitudeRemaining )
	{
		forceToAdd.normalize().multiplyScalar( magnitudeRemaining );
	}

	// add force
	this._steeringForce.add( forceToAdd );

	return true;
};

/**
 * This method tests if a specific bit of m_iFlags is set.
 * 
 * @param {number} behaviorType - The type of behavior.
 * 
 * @returns {boolean} Is the behavior active?
 */
SteeringBehaviors.prototype._isOn = function( behaviorType ) {

	/* jslint bitwise: true */return ( this._behaviorFlag & behaviorType ) === behaviorType;
};

/**
 * Prepares the calculation of the steering behaviors.
 */
SteeringBehaviors.prototype._prepareCalculation = function() {

	// reset steering force
	this._steeringForce.set( 0, 0, 0 );

	// update model matrices
	this.vehicle.updateMatrixWorld();

	if ( this.targetAgent1 !== null )
	{
		this.targetAgent1.updateMatrixWorld();
	}

	if ( this.targetAgent2 !== null )
	{
		this.targetAgent2.updateMatrixWorld();
	}

	// calculate neighbors if one of the following group behaviors is active
	if ( this._isOn( SteeringBehaviors.TYPES.SEPARATION ) || this._isOn( SteeringBehaviors.TYPES.ALIGNMENT ) || this._isOn( SteeringBehaviors.TYPES.COHESION ) )
	{
		this.vehicle.world.calculateNeighbors( this.vehicle, this.viewDistance, this._neighbors );
	}

};

/**
 * Creates the antenna utilized by wallAvoidance.
 */
SteeringBehaviors.prototype._createFeelers = ( function() {

	var rotation, direction;

	return function() {

		if ( rotation === undefined )
		{
			rotation = new THREE.Matrix4();
			direction = new THREE.Vector3();
		}

		// if there are no feelers yet, create them
		if ( this._feelers.length === 0 )
		{
			this._feelers.push( new THREE.Raycaster(), new THREE.Raycaster(), new THREE.Raycaster() );
		}
		
		// get direction of the vehicle
		this.vehicle.getDirection( direction );

		// first feeler pointing straight in front
		this._feelers[ 0 ].ray.origin.copy( this.vehicle.position );
		this._feelers[ 0 ].ray.direction.copy( direction );
		this._feelers[ 0 ].far = this.wallDetectionFeelerLength;

		// second feeler to left
		rotation.identity();
		rotation.makeRotationY( Math.PI * 1.75 );

		this._feelers[ 1 ].ray.origin.copy( this.vehicle.position );
		this._feelers[ 1 ].ray.direction.copy( direction ).transformDirection( rotation );
		this._feelers[ 1 ].far = this.wallDetectionFeelerLength * 0.5;

		// third feeler to right
		rotation.identity();
		rotation.makeRotationY( Math.PI * 0.25 );

		this._feelers[ 2 ].ray.origin.copy( this.vehicle.position );
		this._feelers[ 2 ].ray.direction.copy( direction ).transformDirection( rotation );
		this._feelers[ 2 ].far = this.wallDetectionFeelerLength * 0.5;
	};

}() );

/**
 * Given the position of a hunter, and the position and radius of an obstacle,
 * this method calculates a position distanceFromBoundary away from its bounding
 * radius and directly opposite the hunter.
 * 
 * @param {THREE.Vector3} positionObstacle - The position of the obstacle.
 * @param {THREE.Vector3} radiusObstacle - The radius of the obstacle.
 * @param {THREE.Vector3} positionHunter - The position of the hunter.
 * @param {THREE.Vector3} hidingSpot - The calculated hiding spot.
 */
SteeringBehaviors.prototype._getHidingPosition = ( function() {

	var toHidingSpot;

	return function( positionObstacle, radiusObstacle, positionHunter, hidingSpot ) {

		if ( toHidingSpot === undefined )
		{
			toHidingSpot = new THREE.Vector3();
		}

		// calculate how far away the agent is to be from the chosen obstacle's
		// bounding radius
		var distanceAway = radiusObstacle + this.distanceFromBoundary;

		// calculate the heading toward the object from the hunter
		toHidingSpot.subVectors( positionObstacle, positionHunter ).normalize();

		// scale it to size
		toHidingSpot.multiplyScalar( distanceAway );

		// add direction vector to the obstacles position to get the hiding spot
		hidingSpot.addVectors( toHidingSpot, positionObstacle );
	};

}() );

/**
 * Setup wander target.
 */
SteeringBehaviors.prototype.setupWanderTarget = function() {

	var theta = Math.random() * Math.PI * 2;

	// setup a vector to a target position on the wander sphere
	this._wanderTarget.x = this.wanderRadius * Math.cos( theta );
	this._wanderTarget.y = 0;
	this._wanderTarget.z = this.wanderRadius * Math.sin( theta );

};

// /////////////////////////////////////////////////////////////////////////////
// START OF BEHAVIORS

/**
 * This behavior moves the agent towards a target position.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {THREE.Vector3} targetPosition - The target position.
 */
SteeringBehaviors.prototype._seek = ( function() {

	var desiredVelocity;

	return function( force, targetPosition ) {

		if ( desiredVelocity === undefined )
		{
			desiredVelocity = new THREE.Vector3();
		}

		// First the desired velocity is calculated.
		// This is the velocity the agent would need to reach the target
		// position in an ideal world.
		// It represents the vector from the agent to the target,
		// scaled to be the length of the maximum possible speed of the agent.
		desiredVelocity.subVectors( targetPosition, this.vehicle.position ).normalize();

		desiredVelocity.multiplyScalar( this.vehicle.maxSpeed );

		// The steering force returned by this method is the force required,
		// which when added to the agent’s current velocity vector gives the
		// desired velocity.
		// To achieve this you simply subtract the agent’s current velocity from
		// the desired velocity.
		force.subVectors( desiredVelocity, this.vehicle.velocity );
	};

}() );

/**
 * Does the opposite of seek.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {THREE.Vector3} targetPosition - The target position.
 */
SteeringBehaviors.prototype._flee = ( function() {

	var desiredVelocity;

	return function( force, targetPosition ) {

		if ( desiredVelocity === undefined )
		{
			desiredVelocity = new THREE.Vector3();
		}

		// only flee if the target is within panic distance
		if ( this.vehicle.position.distanceToSquared( targetPosition ) < ( this.panicDistance * this.panicDistance ) )
		{
			// from here, the only difference compared to seek is that the
			// desired velocity is calculated using a vector pointing in the
			// opposite direction
			desiredVelocity.subVectors( this.vehicle.position, targetPosition ).normalize();

			desiredVelocity.multiplyScalar( this.vehicle.maxSpeed );

			force.subVectors( desiredVelocity, this.vehicle.velocity );

		}
		
	};

}() );

/**
 * This behavior is similar to seek but it attempts to arrive at the target with
 * a zero velocity.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {THREE.Vector3} targetPosition - The target position.
 * @param {number} deceleration - The deceleration of the vehicle.
 */
SteeringBehaviors.prototype._arrive = ( function() {

	var desiredVelocity, toTarget;

	return function( force, targetPosition, deceleration ) {

		var distance, speed;

		if ( desiredVelocity === undefined )
		{
			desiredVelocity = new THREE.Vector3();
			toTarget = new THREE.Vector3();
		}

		// calculate displacement vector
		toTarget.subVectors( targetPosition, this.vehicle.position );

		// calculate the distance to the target
		distance = toTarget.length();

		if ( distance > 0 )
		{
			// calculate the speed required to reach the target given the
			// desired deceleration
			speed = distance / deceleration;

			// make sure the velocity does not exceed the max
			speed = Math.min( speed, this.vehicle.maxSpeed );

			// from here proceed just like "seek" except we don't need to
			// normalize
			// the "toTarget" vector because we have already gone to the trouble
			// of calculating its length: distance.
			desiredVelocity.copy( toTarget ).multiplyScalar( speed ).divideScalar( distance );

			force.subVectors( desiredVelocity, this.vehicle.velocity );
		}

	};

}() );

/**
 * This behavior creates a force that steers the agent towards the evader.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {Vehicle} evader - The evader to pursuit.
 */
SteeringBehaviors.prototype._pursuit = ( function() {

	var toEvader, vehicleDirection, evaderDirection, newEvaderVelocity, predcitedPosition;

	return function( force, evader ) {
		
		var isFacing, isEvaderAhead, lookAheadTime;
		
		if( toEvader === undefined ){
			
			toEvader = new THREE.Vector3();
			vehicleDirection = new THREE.Vector3();
			evaderDirection = new THREE.Vector3();
			newEvaderVelocity = new THREE.Vector3();
			predcitedPosition = new THREE.Vector3();
		}

		// 1. if the evader is ahead and facing the agent then we can just seek
		// for the evader's current position

		// calculate displacement vector
		toEvader.subVectors( evader.position, this.vehicle.position );

		// buffer vehicle and evader direction
		this.vehicle.getDirection( vehicleDirection );
		evader.getDirection( evaderDirection );

		// check first condition. evader must be in front of the pursuer
		isEvaderAhead = toEvader.dot( vehicleDirection ) > 0;

		// check second condition. evader must almost directly facing the agent
		isFacing = vehicleDirection.dot( evaderDirection ) < 0.95;

		if ( isEvaderAhead && isFacing )
		{
			this._seek( force, evader.position );
			
			return;
		}

		// 2. not considered ahead so we predict where the evader will be

		// the lookahead time is proportional to the distance between the evader
		// and the pursuer. and is inversely proportional to the sum of the
		// agent's velocities
		lookAheadTime = toEvader.length() / ( this.vehicle.maxSpeed + evader.getSpeed() );

		// calculate new velocity and predicted future position
		newEvaderVelocity.copy( evader.velocity ).multiplyScalar( lookAheadTime );

		predcitedPosition.addVectors( evader.position, newEvaderVelocity );

		// now seek to the predicted future position of the evader
		this._seek( force, predcitedPosition );
	};

}() );

/**
 * Produces a steering force that keeps a vehicle at a specified offset from a
 * leader vehicle.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {Vehicle} leader - The leader vehicle.
 * @param {THREE.Vector3} offset - The offset of the leader.
 */
SteeringBehaviors.prototype._offsetPursuit = ( function() {

	var offsetWorld, toOffset, newLeaderVelocity, predcitedPosition;

	return function( force, leader, offset ) {

		var lookAheadTime;

		if ( offsetWorld === undefined )
		{
			offsetWorld = new THREE.Vector3();
			toOffset = new THREE.Vector3();
			newLeaderVelocity = new THREE.Vector3();
			predcitedPosition = new THREE.Vector3();
		}

		// calculate the offset's position in world space
		offsetWorld.copy( offset ).applyMatrix4( leader.object3D.matrixWorld );

		// calculate the vector that points from the vehicle to the offset position
		toOffset.subVectors( offsetWorld, this.vehicle.position );

		// the lookahead time is proportional to the distance between the leader
		// and the pursuer; and is inversely proportional to the sum of both
		// agent's velocities
		lookAheadTime = toOffset.length() / ( this.vehicle.maxSpeed + leader.getSpeed() );

		// calculate new velocity and predicted future position
		newLeaderVelocity.copy( leader.velocity ).multiplyScalar( lookAheadTime );

		predcitedPosition.addVectors( offsetWorld, newLeaderVelocity );

		// now arrive at the predicted future position of the offset
		this._arrive( force, predcitedPosition, SteeringBehaviors.DECELERATION.VERY_FAST );
	};

}() );

/**
 * Similar to pursuit except the agent flees from the estimated future position
 * of the pursuer.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {Vehicle} pursuer - The pursuer.
 */
SteeringBehaviors.prototype._evade = ( function() {

	var toPursuer, newPursuerVelocity, predcitedPosition;

	return function( force, pursuer ) {

		var lookAheadTime;

		if ( toPursuer === undefined )
		{
			toPursuer = new THREE.Vector3();
			newPursuerVelocity = new THREE.Vector3();
			predcitedPosition = new THREE.Vector3();
		}

		// calculate displacement vector
		toPursuer.subVectors( pursuer.position, this.vehicle.position );

		// evade only when pursuers are inside a threat range
		if ( toPursuer.lengthSq() > ( this.panicDistance * this.panicDistance ) )
		{
			return new THREE.Vector3();
		}

		// the lookahead time is proportional to the distance between the evader
		// and the pursuer. and is inversely proportional to the sum of the
		// agent's velocities
		lookAheadTime = toPursuer.length() / ( this.vehicle.maxSpeed + pursuer.getSpeed() );

		// calculate new velocity and predicted future position
		newPursuerVelocity.copy( pursuer.velocity ).multiplyScalar( lookAheadTime );

		predcitedPosition.addVectors( pursuer.position, newPursuerVelocity );

		// now flee away from predicted future position of the pursuer
		this._flee( force, predcitedPosition );
	};

}() );

/**
 * Given two agents, this method returns a force that attempts to position the
 * vehicle between them.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {Vehicle} agentA - The first agent.
 * @param {Vehicle} agentB - The second agent.
 */
SteeringBehaviors.prototype._interpose = ( function() {

	var midPoint, newVelocityAgentA, newVelocityAgentB, predcitedPositionAgentA, predcitedPositionAgentB;

	return function( force, agentA, agentB ) {

		var time;

		if ( midPoint === undefined )
		{
			midPoint = new THREE.Vector3();

			newVelocityAgentA = new THREE.Vector3();
			newVelocityAgentB = new THREE.Vector3();

			predcitedPositionAgentA = new THREE.Vector3();
			predcitedPositionAgentB = new THREE.Vector3();
		}

		// first we need to figure out where the two agents are going to be
		// in the future. This is approximated by determining the time
		// taken to reach the mid way point at the current time at at max speed
		midPoint.addVectors( agentA.position, agentB.position ).multiplyScalar( 0.5 );

		time = this.vehicle.position.distanceTo( midPoint ) / this.vehicle.maxSpeed;

		// now we have the time, we assume that agent A and agent B will
		// continue on a straight trajectory and extrapolate to get their future
		// positions
		newVelocityAgentA.copy( agentA.velocity ).multiplyScalar( time );
		predcitedPositionAgentA.addVectors( agentA.position, newVelocityAgentA );

		newVelocityAgentB.copy( agentB.velocity ).multiplyScalar( time );
		predcitedPositionAgentB.addVectors( agentB.position, newVelocityAgentB );

		// calculate the mid point of these predicted positions
		midPoint.addVectors( predcitedPositionAgentA, predcitedPositionAgentB ).multiplyScalar( 0.5 );

		// then steer to arrive at it
		this._arrive( force, midPoint, SteeringBehaviors.DECELERATION.VERY_FAST );
	};

}() );

/**
 * Given another agent position to hide from and a list of obstacles this method
 * attempts to put an obstacle between itself and its opponent.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {Vehicle} hunter - The hunter agent.
 */
SteeringBehaviors.prototype._hide = ( function() {

	var hidingSpot, bestHidingSpot;

	return function( force, hunter ) {

		var distanceSq, closestDistanceSq, obstacle, index;

		if ( hidingSpot === undefined )
		{
			hidingSpot = new THREE.Vector3();
			bestHidingSpot = new THREE.Vector3();
		}

		// this will be used to track the distance to the closest hiding spot
		closestDistanceSq = Infinity;

		for ( index = 0; index < this.vehicle.world.actionObjects.length; index++ )
		{
			obstacle = this.vehicle.world.actionObjects[ index ];

			// calculate the position of the hiding spot for this obstacle
			this._getHidingPosition( obstacle.boundingSphere.center, obstacle.boundingSphere.radius, hunter.position, hidingSpot );

			// work in distance-squared space to find the closest hiding spot to
			// the agent
			distanceSq = hidingSpot.distanceToSquared( this.vehicle.position );

			if ( distanceSq < closestDistanceSq )
			{
				// save values
				closestDistanceSq = distanceSq;

				bestHidingSpot = hidingSpot;
			}
		}

		// if no suitable obstacles found then evade the hunter
		if ( closestDistanceSq === Infinity )
		{
			this._evade( force, hunter );
		}
		else
		{
			this._arrive( force, bestHidingSpot, SteeringBehaviors.DECELERATION.VERY_FAST );
		}
	};

}() );

/**
 * This behavior makes the agent wander about randomly on a planar surface.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 * @param {number} delta - The time delta value.
 */
SteeringBehaviors.prototype._wander = ( function() {

	var target, randomDisplacement, distanceVector;

	return function( force, delta ) {

		var jitterThisTimeSlice;

		if ( target === undefined )
		{
			target = new THREE.Vector3();
			randomDisplacement = new THREE.Vector3();
			distanceVector = new THREE.Vector3();
		}

		// this behavior is dependent on the update rate, so this line must be
		// included when using time independent frame rate.
		jitterThisTimeSlice = this.wanderJitter * delta;

		// prepare random vector
		randomDisplacement.x = THREE.Math.randFloat( -1, 1 ) * jitterThisTimeSlice;
		randomDisplacement.y = 0;
		randomDisplacement.z = THREE.Math.randFloat( -1, 1 ) * jitterThisTimeSlice;

		// add random vector to the target's position
		this._wanderTarget.add( randomDisplacement );

		// re-project this new vector back onto a unit sphere
		this._wanderTarget.normalize();

		// increase the length of the vector to the same as the radius of the
		// wander sphere
		this._wanderTarget.multiplyScalar( this.wanderRadius );

		// move the target into a position wanderDist in front of the agent
		distanceVector.z = this.wanderDistance;
		target.addVectors( this._wanderTarget, distanceVector );

		// project the target into world space
		target.applyMatrix4( this.vehicle.object3D.matrixWorld );

		// and steer towards it
		force.subVectors( target, this.vehicle.position );
	};

}() );

/**
 * Given an array of obstacles, this method returns a steering force that will
 * prevent the agent colliding with the closest obstacle.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 */
SteeringBehaviors.prototype._obstacleAvoidance = ( function() {

	var boundingBox, boundingSphere, inverseMatrix, ray;

	var vehicleSize, localPositionOfObstacle, localPositionOfClosestObstacle, intersectionPoint;

	return function( force ) {

		if ( boundingBox === undefined )
		{
			boundingBox = new THREE.Box3();
			boundingSphere = new THREE.Sphere();

			vehicleSize = new THREE.Vector3();
			localPositionOfObstacle = new THREE.Vector3();
			localPositionOfClosestObstacle = new THREE.Vector3();
			intersectionPoint = new THREE.Vector3();

			inverseMatrix = new THREE.Matrix4();

			// this will be used for ray/sphere intersection test
			ray = new THREE.Ray( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1 ) );
		}

		var index, obstacle, expandedRadius, multiplier;

		// the amount of force that leads the object away from the obsacle
		var brakingWeight = 0.2;

		// this will keep track of the closest intersecting obstacle
		var closestObstacle = null;

		// this will be used to track the distance to the closest obstacle
		var distanceToClosestObstacle = Infinity;

		// the detection box length is proportional to the agent's velocity
		var detectionBoxLength = this.vehicle.getSpeed() + this.vehicle.maxSpeed + vehicleSize.z * 0.5;

		// calculate bounding box of vehicle
		boundingBox.setFromObject( this.vehicle.object3D );

		// get size of bounding box
		boundingBox.size( vehicleSize );

		// this matrix will transform points to the local space of the vehicle
		inverseMatrix.getInverse( this.vehicle.object3D.matrixWorld );

		for ( index = 0; index < this.vehicle.world.actionObjects; index++ )
		{
			obstacle = this.vehicle.world.actionObjects[ index ];

			// calculate this obstacle's position in local space
			localPositionOfObstacle.copy( obstacle.boundingSphere.center ).applyMatrix4( inverseMatrix );

			// if the local position has a positive z value then it must lay
			// behind the agent. besides the absolute z value must be smaller
			// than the length of the detection box
			if ( localPositionOfObstacle.z > 0 && Math.abs( localPositionOfObstacle.z ) < detectionBoxLength )
			{
				// if the distance from the x axis to the object's position is
				// less
				// than its radius + half the width of the detection box then
				// there is a potential intersection.
				expandedRadius = obstacle.boundingSphere.radius + vehicleSize.x * 0.5;

				if ( Math.abs( localPositionOfObstacle.x ) < expandedRadius )
				{
					// prepare intersection test
					boundingSphere.center = localPositionOfObstacle;
					boundingSphere.radius = expandedRadius;

					// do intersection test in local space of the vehicle
					ray.intersectSphere( boundingSphere, intersectionPoint );

					// compare distances
					if ( intersectionPoint.z < distanceToClosestObstacle )
					{
						// save new minimum distance
						distanceToClosestObstacle = intersectionPoint.z;

						// save closest obstacle
						closestObstacle = obstacle;

						// save local position for force calculation
						localPositionOfClosestObstacle.copy( localPositionOfObstacle );
					}
				}
			}
		}

		// if we have found an intersecting obstacle, calculate a steering force
		// away from it
		if ( closestObstacle !== null )
		{
			// the closer the agent is to an object, the stronger the steering
			// force should be
			multiplier = 1 + ( detectionBoxLength - localPositionOfClosestObstacle.z ) / detectionBoxLength;

			// calculate the lateral force
			force.x = ( closestObstacle.boundingSphere.radius - localPositionOfClosestObstacle.x ) * multiplier;

			// apply a braking force proportional to the obstacles distance from
			// the vehicle
			force.z = ( closestObstacle.boundingSphere.radius - localPositionOfClosestObstacle.z ) * brakingWeight;

			// finally, convert the steering vector from local to world space
			force.transformDirection( this.vehicle.object3D.matrixWorld );
		}

	};

}() );

/**
 * This returns a steering force that will keep the agent away from any walls it
 * may encounter.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 */
SteeringBehaviors.prototype._wallAvoidance = ( function() {

	var overShoot, closestPoint, normal;

	return function( force ) {

		if ( overShoot === undefined )
		{
			overShoot = new THREE.Vector3();
			closestPoint = new THREE.Vector3();
			normal = new THREE.Vector3();
		}

		var indexFeeler, indexWall, feeler, intersects;

		// this will be used to track the distance to the closest wall
		var distanceToClosestWall = Infinity;

		// this will keep track of the closest wall
		var closestWall = null;

		// this will keep track of the feeler that caused an intersection
		var intersectionFeeler = null;

		// this will keep track of the closes point
		closestPoint.set( 0, 0, 0 );

		// this will keep track of the wall normal
		normal.set( 0, 0, 0 );

		// create feelers for test
		this._createFeelers();

		// examine each feeler in turn
		for ( indexFeeler = 0; indexFeeler < this._feelers.length; indexFeeler++ )
		{
			// run through each wall checking for any intersection points
			for ( indexWall = 0; indexWall < this.vehicle.world.walls.length; indexWall++ )
			{
				feeler = this._feelers[ indexFeeler ];

				// do intersection test
				intersects = feeler.intersectObject( this.vehicle.world.walls[ indexWall ] );

				if ( intersects.length > 0 )
				{
					// if the distance of the intersection point is smaller
					// than the current distanceToClosestWall, continue
					if ( intersects[ 0 ].distance < distanceToClosestWall )
					{
						distanceToClosestWall = intersects[ 0 ].distance;

						closestWall = this.vehicle.world.walls[ indexWall ];

						closestPoint.copy( intersects[ 0 ].point );

						normal.copy( intersects[ 0 ].face.normal );

						intersectionFeeler = feeler;
					}
					
				}
				
			} // next wall
			
		} // next feeler

		// if a wall was found, calculate a force that will direct the agent
		// away
		if ( closestWall !== null )
		{
			// calculate by what distance the projected position of the agent
			// will overshoot the wall
			overShoot.copy( intersectionFeeler.ray.direction ).multiplyScalar( intersectionFeeler.far ).add( intersectionFeeler.ray.origin );
			overShoot.sub( closestPoint );

			// transform the normal with the world matrix of the wall
			// on this way you get the true orientation of the normal
			normal.transformDirection( closestWall.matrixWorld );

			// create a force in the direction of the wall normal, with a
			// magnitude of the overshoot
			force.copy( normal ).multiplyScalar( overShoot.length() );
		}
		
	};

}() );

/**
 * Given a series of Vector2Ds, this method produces a force that will move the
 * agent along the waypoints in order. The agent uses the "seek" behavior to
 * move to the next waypoint - unless it is the last waypoint, in which case it
 * "arrives".
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 */
SteeringBehaviors.prototype._followPath = function( force ) {

	// calculate distance in square space from current waypoint to vehicle
	var distanceSq = this.path.getCurrentWaypoint().distanceToSquared( this.vehicle.position );

	// move to next waypoint if close enough to current target
	if ( distanceSq < ( this.waypointSeekDist * this.waypointSeekDist ) )
	{
		this.path.setNextWaypoint();
	}

	if ( !this.path.isFinished() )
	{
		this._seek( force, this.path.getCurrentWaypoint() );
	}
	else
	{
		this._arrive( force, this.path.getCurrentWaypoint(), SteeringBehaviors.DECELERATION.MIDDLE );
	}
};

/**
 * This calculates a force repelling from the other neighbors
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 */
SteeringBehaviors.prototype._separation = ( function() {

	var toAgent;

	return function( force ) {

		var index, neighbor, length;

		if ( toAgent === undefined )
		{
			toAgent = new THREE.Vector3();
		}

		for ( index = 0; index < this._neighbors.length; index++ )
		{
			neighbor = this._neighbors[ index ];

			// make sure this agent isn't included in the calculations
			// also make sure it doesn't include the evade target
			if ( neighbor !== this.vehicle && neighbor !== this.targetAgent1 )
			{
				// calculate displacement vector
				toAgent.subVectors( this.vehicle.position, neighbor.position );

				// get length
				length = toAgent.length();

				// handle zero length. this is necessary if both vehicles have
				// the same position
				if ( length === 0 )
				{
					length = 0.0001;
				}

				// scale the force inversely proportional to the agents distance
				// from its neighbor
				toAgent.normalize().divideScalar( length );

				// add force
				force.add( toAgent );
			}

		}// next neighbor

	};

}() );

/**
 * Returns a force that attempts to align this agents heading with that of its
 * neighbors.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 */
SteeringBehaviors.prototype._alignment = ( function() {

	// used to record the average heading of the neighbors
	var averageHeading, direction;

	return function( force ) {

		var index, neighbor, neighborCount = 0;

		if ( averageHeading === undefined )
		{
			averageHeading = new THREE.Vector3();
			direction = new THREE.Vector3();
		}

		// reset values
		averageHeading.set( 0, 0, 0 );

		// iterate over all neighbors to calculate the average heading
		for ( index = 0; index < this._neighbors.length; index++ )
		{
			neighbor = this._neighbors[ index ];

			neighbor.getDirection( direction );

			// make sure this agent isn't included in the calculations
			// also make sure it doesn't include the evade target
			if ( neighbor !== this.vehicle && neighbor !== this.targetAgent1 )
			{
				averageHeading.add( direction );

				neighborCount++;
			}
			
		}  // next neighbor

		// if the neighborhood contained one or more vehicles, average their
		// heading vectors
		if ( neighborCount > 0 )
		{
			averageHeading.divideScalar( neighborCount );

			this.vehicle.getDirection( direction );

			force.subVectors( averageHeading, direction );
		}

	};

}() );

/**
 * Returns a steering force that attempts to move the agent towards the center
 * of mass of the agents in its immediate area.
 * 
 * @param {THREE.Vector3} force - The force to calculate.
 */
SteeringBehaviors.prototype._cohesion = ( function() {

	var centerOfMass;

	return function( force ) {

		var index, neighbor, neighborCount = 0;

		if ( centerOfMass === undefined )
		{
			// center of mass of all the agents
			centerOfMass = new THREE.Vector3();
		}

		// reset values
		centerOfMass.set( 0, 0, 0 );

		// iterate over all neighbors to calculate the center of mass
		for ( index = 0; index < this._neighbors.length; index++ )
		{
			neighbor = this._neighbors[ index ];

			// make sure this agent isn't included in the calculations
			// also make sure it doesn't include the evade target
			if ( neighbor !== this.vehicle && neighbor !== this.targetAgent1 )
			{
				centerOfMass.add( neighbor.position );

				neighborCount++;
			}

		} // next neighbor

		if ( neighborCount > 0 )
		{
			// the center of mass is the average of the sum of positions
			centerOfMass.divideScalar( neighborCount );

			// now seek towards that position
			this._seek( force, centerOfMass );

			// the magnitude of cohesion is usually much larger than separation
			// or
			// allignment so it usually helps to normalize it
			force.normalize();
		}

	};

}() );

// /////////////////////////////////////////////////////////////////////////////
// END OF BEHAVIORS

// /////////////////////////////////////////////////////////////////////////////
// START OF CONTROL METHODS

/* jshint ignore:start */

SteeringBehaviors.prototype.seekOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.SEEK; };
SteeringBehaviors.prototype.fleeOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.FLEE; };
SteeringBehaviors.prototype.arriveOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.ARRIVE; };
SteeringBehaviors.prototype.pursuitOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.PURSUIT; };
SteeringBehaviors.prototype.offsetPursuitOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.OFFSETPURSUIT; };
SteeringBehaviors.prototype.evadeOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.EVADE; };
SteeringBehaviors.prototype.interposeOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.INTERPOSE; };
SteeringBehaviors.prototype.hideOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.HIDE; };
SteeringBehaviors.prototype.wanderOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.WANDER; };
SteeringBehaviors.prototype.obstacleAvoidanceOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.OBSTACLEAVOIDANCE; };
SteeringBehaviors.prototype.wallAvoidanceOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.WALLAVOIDANCE; };
SteeringBehaviors.prototype.followPathOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.FOLLOWPATH; };
SteeringBehaviors.prototype.cohesionOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.COHESION; };
SteeringBehaviors.prototype.separationOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.SEPARATION; };
SteeringBehaviors.prototype.alignmentOn = function() { this._behaviorFlag |= SteeringBehaviors.TYPES.ALIGNMENT; };
SteeringBehaviors.prototype.flockingOn = function() { this.cohesionOn(); this.separationOn(); this.alignmentOn(); this.wanderOn(); };

SteeringBehaviors.prototype.seekOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.SEEK ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.SEEK; };
SteeringBehaviors.prototype.fleeOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.FLEE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.FLEE; };
SteeringBehaviors.prototype.arriveOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.ARRIVE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.ARRIVE; };
SteeringBehaviors.prototype.pursuitOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.PURSUIT ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.PURSUIT; };
SteeringBehaviors.prototype.offsetPursuitOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.OFFSETPURSUIT ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.OFFSETPURSUIT; };
SteeringBehaviors.prototype.evadeOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.EVADE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.EVADE; };
SteeringBehaviors.prototype.interposeOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.INTERPOSE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.INTERPOSE; };
SteeringBehaviors.prototype.hideOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.HIDE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.HIDE; };
SteeringBehaviors.prototype.wanderOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.WANDER ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.WANDER; };
SteeringBehaviors.prototype.obstacleAvoidanceOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.OBSTACLEAVOIDANCE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.OBSTACLEAVOIDANCE; };
SteeringBehaviors.prototype.wallAvoidanceOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.WALLAVOIDANCE ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.WALLAVOIDANCE; };
SteeringBehaviors.prototype.followPathOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.FOLLOWPATH ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.FOLLOWPATH; };
SteeringBehaviors.prototype.cohesionOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.COHESION ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.COHESION; };
SteeringBehaviors.prototype.separationOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.SEPARATION ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.SEPARATION; };
SteeringBehaviors.prototype.alignmentOff = function() { if ( this._isOn( SteeringBehaviors.TYPES.ALIGNMENT ) ) this._behaviorFlag ^= SteeringBehaviors.TYPES.ALIGNMENT; };
SteeringBehaviors.prototype.flockingOff = function() { this.cohesionOff(); this.separationOff(); this.alignmentOff(); this.wanderOff(); };

/* jshint ignore:end */

// /////////////////////////////////////////////////////////////////////////////
// END OF CONTROL METHODS
// types of behavior as flags
SteeringBehaviors.TYPES = {
	NONE : 0x00000,
	SEEK : 0x00002,
	FLEE : 0x00004,
	ARRIVE : 0x00008,
	WANDER : 0x00010,
	COHESION : 0x00020,
	SEPARATION : 0x00040,
	ALIGNMENT : 0x00080,
	OBSTACLEAVOIDANCE : 0x00100,
	WALLAVOIDANCE : 0x00200,
	FOLLOWPATH : 0x00400,
	PURSUIT : 0x00800,
	EVADE : 0x01000,
	INTERPOSE : 0x02000,
	HIDE : 0x04000,
	FLOCK : 0x08000,
	OFFSETPURSUIT : 0x10000
};

// amounts of deceleration
SteeringBehaviors.DECELERATION = {
	VERY_FAST : 1.5,
	FAST : 3,
	MIDDLE : 4,
	SLOW : 5,
	VERY_SLOW : 6
};

module.exports = SteeringBehaviors;
},{"../../core/Logger":21,"three":1}],69:[function(require,module,exports){
/**
 * @file This prototype provides topic-based publish/subscribe messaging and
 * enables communication between game entities.
 * 
 * see: https://github.com/mroderick/PubSubJS
 * see: Programming Game AI by Example by Mat Buckland: Messaging in State-Driven Agent Design
 * 
 * @author Human Interactive
 */

"use strict";

var Telegram = require( "./Telegram" );
var logger = require( "../core/Logger" );
var GameEntity = require( "../game/entity/GameEntity" );

/**
 * Creates the event manager.
 * 
 * @constructor
 */
function EventManager() {

	Object.defineProperties( this, {

		isImmediateExceptions : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}

	} );
}

/**
 * Publishes the the message, passing the data to it's subscribers.
 * 
 * @param {string} message - The message to publish.
 * @param {object} data - The data to pass to subscribers.
 * 
 * @returns {boolean} Is the message published successfully?
 */
EventManager.prototype.publish = function( message, data ) {

	return publish( message, data, false, this.isImmediateExceptions );
};

/**
 * Publishes the the message synchronously, passing the data to it's subscribers
 * 
 * @param {string} message - The message to publish.
 * @param {object} data - The data to pass to subscribers.
 * 
 * @returns {boolean} Is the message published successfully?
 */
EventManager.prototype.publishSync = function( message, data ) {

	return publish( message, data, true, this.isImmediateExceptions );
};

/**
 * Subscribes the passed function to the passed message. Every returned token is
 * unique and should be stored if you need to unsubscribe.
 * 
 * @param {string} message - The message to subscribe to.
 * @param {function} callback - The function to call when a new message is published.
 * 
 * @returns {string} Token for unsubscribing.
 */
EventManager.prototype.subscribe = function( message, callback ) {

	var token;

	// ensure, the callback parameter is a function
	if ( typeof callback !== "function" )
	{
		throw "ERROR: EventManager: No callback function for subscription assigned.";
	}

	// register message if necessary
	if ( messages.hasOwnProperty( message ) === false )
	{
		messages[ message ] = {};
	}

	// forcing token as string, to allow for future expansions without
	// breaking usage and allow for easy use as key names for the "messages"
	// object
	token = "uid_" + String( ++lastUid );
	messages[ message ][ token ] = callback;

	return token;

};

/**
 * Clears all subscriptions
 */
EventManager.prototype.clearAllSubscriptions = function() {

	messages = {};
};

/**
 * Clears subscriptions by the topic.
 * 
 * @param {string} topic - The corresponding topic of the subscriptions to clear.
 */
EventManager.prototype.clearSubscriptions = function( topic ) {

	var m;

	for ( m in messages ) // jshint ignore:line
	{
		if ( messages.hasOwnProperty( m ) === true && m.indexOf( topic ) === 0 )
		{
			delete messages[ m ];
		}
	}
};

/**
 * Removes subscriptions.
 * 
 * When passed a token, removes a specific subscription. When passed a function,
 * removes all subscriptions for that function. When passed a topic, removes all
 * subscriptions for that topic (hierarchy).
 * 
 * @param {any} value - A token, function or topic to unsubscribe.
 * 
 * @returns {any} The return value depends on the type of parameter "value".
 */
EventManager.prototype.unsubscribe = function( value ) {

	var isTopic, isToken, isFunction;
	var message, m, t;
	var result = false;

	isTopic = ( typeof value === "string" ) && ( messages.hasOwnProperty( value ) === true );
	isToken = ( isTopic === false ) && ( typeof value === "string" );
	isFunction = typeof value === "function";

	// this handles the case if "value" is a topic
	if ( isTopic === true )
	{
		delete messages[ value ];
		return;
	}

	// iterate over all messages/topics
	for ( m in messages ) // jshint ignore:line
	{
		if ( messages.hasOwnProperty( m ) === true )
		{
			// buffer message
			message = messages[ m ];

			// this handles the case if "value" is a token
			if ( isToken === true && message[ value ] )
			{
				// delete the token of the corresponding topic
				delete message[ value ];

				// return the token to the caller
				result = value;

				// because tokens are unique, we can just stop here
				break;
			}

			// this handles the case if "value" is a function
			if ( isFunction === true )
			{
				// iterate over all subscriptions of a topic
				for ( t in message ) // jshint ignore:line
				{
					// check the value (callback) of the token
					if ( message.hasOwnProperty( t ) === true && message[ t ] === value )
					{
						// delete the token
						delete message[ t ];

						result = true;
					}
				}// next token
			}
		}
	}// next topic

	return result;

};

/**
 * Sends a message to a game entity.
 * 
 * @param {number} sender - The ID of the sender of the message.
 * @param {number} receiver - The ID of the receiver of the message.
 * @param {string} message - The message to send.
 * @param {object} data - The data to pass to receiver.
 * @param {number} delay - The delay of the message.
 */
EventManager.prototype.sendMessageToEntity = function( sender, receiver, message, data, delay ) {

	sendMessageToEntity( sender, receiver, message, data, false, delay );
};

/**
 * Sends a message synchronously to a game entity.
 * 
 * @param {number} sender - The ID of the sender of the message.
 * @param {number} receiver - The ID of the receiver of the message.
 * @param {string} message - The message to send.
 * @param {object} data - The data to pass to receiver.
 */
EventManager.prototype.sendMessageToEntitySync = function( sender, receiver, message, data ) {

	sendMessageToEntity( sender, receiver, message, data, true, 0 );
};

/**
 * Registers a game entity for messaging.
 * 
 * @param {GameEntity} entity - The game entity to register.
 */
EventManager.prototype.registerEntity = function( entity ) {

	if ( entity instanceof GameEntity )
	{
		// register game entity if necessary
		if ( entities.hasOwnProperty( entity.id ) === false )
		{
			entities[ entity.id ] = entity;
		}
	}
	else
	{
		throw "ERROR: EventManager: Entity no instance of \"GameEntity\".";
	}

};

/**
 * Removes a game entity.
 * 
 * @param {GameEntity} entity - The game entity to remove.
 */
EventManager.prototype.removeEntity = function( entity ) {

	if ( entity instanceof GameEntity )
	{
		// remove game entity if necessary
		if ( entities.hasOwnProperty( entity.id ) === true )
		{
			delete entities[ entity.id ];
		}
	}
	else
	{
		throw "ERROR: EventManager: Entity no instance of \"GameEntity\".";
	}
};

/**
 * Clears the entity list for messaging.
 */
EventManager.prototype.clearEntites = function( entity ) {

	entities = {};
};

// private functions and attributes
var messages = {};
var entities = {};
var lastUid = -1;

/**
 * Checks if the given object has keys.
 * 
 * @param {object} function - The function to test.
 * 
 * @returns {boolean} Does the object has keys?
 */
function hasKeys( object ) {

	for ( var key in object )
	{
		if ( object.hasOwnProperty( key ) === true )
		{
			return true;
		}
	}
	
	return false;
}

/**
 * This returns a functions that just throws the given exception. Used for
 * delayed exception handling.
 * 
 * @param {object} exception - The exception to throw.
 */
function throwException( exception ) {

	return function reThrowException() {

		throw exception;
	};
}

/**
 * This function calls the subscriber function with delayed exceptions. This
 * ensures, that the logic delivers messages to all subscribers, even when some
 * fail.
 * 
 * @param {function} subscriber - The callback function of the subscriber.
 * @param {string} message - The message to publish.
 * @param {object} data - The data to pass to subscribers.
 */
function callSubscriberWithDelayedExceptions( subscriber, message, data ) {

	try
	{
		// we call the function within try/catch
		subscriber( message, data );
	}
	catch ( exception )
	{
		// catch the exception an throw it via an asynchronous wrapper function
		setTimeout( throwException( exception ), 0 );
	}
}

/**
 * This function calls the subscriber function with immediate exceptions. If an
 * exception is thrown, the delivery of message will automatically stop.
 * 
 * @param {function} subscriber - The callback function of the subscriber.
 * @param {string} message - The message to publish.
 * @param {object} data - The data to pass to subscribers.
 */
function callSubscriberWithImmediateExceptions( subscriber, message, data ) {

	// we call the function without try/catch
	subscriber( message, data );
}

/**
 * This function delivers the message to the subscribers.
 * 
 * @param {string} originalMessage - The original message of publish e.g.
 * "a.b.c".
 * @param {string} matchedMessage - The current message to publish e.g. "a.b".
 * @param {object} data - The data to pass to subscribers.
 * @param {object} isImmediateExceptions - Force immediate exceptions?
 */
function deliverMessage( originalMessage, matchedMessage, data, isImmediateExceptions ) {

	// get the subscribers of the topic.
	// thats a object with the structure token -> callback.
	var subscribers = messages[ matchedMessage ];

	// determine the type of function call
	var callSubscriber = isImmediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions;

	// ensure the matchedMessage is an existing topic
	if ( messages.hasOwnProperty( matchedMessage ) === false )
	{
		return;
	}
	
	// call for each subscriber the callback function
	for ( var s in subscribers )
	{
		if ( subscribers.hasOwnProperty( s ) === true )
		{
			callSubscriber( subscribers[ s ], originalMessage, data );
		}
	}
}

/**
 * This function creates a delivery function for the publish of a message.
 * 
 * @param {string} message - The message to publish.
 * @param {object} data - The data to pass to subscribers.
 * @param {object} isImmediateExceptions - Force immediate exceptions?
 * 
 * @returns {function} The delivery function.
 */
function createDeliveryFunction( message, data, immediateExceptions ) {

	return function deliverNamespaced() {

		// ensure, we have a string object
		var topic = String( message );

		// index to the last appearance of a dot char
		// used for hierarchical addressing e.g. "a.b.c"
		var position = topic.lastIndexOf( '.' );

		// deliver the message as it is now
		deliverMessage( message, message, data, immediateExceptions );

		// trim the hierarchy and deliver message to each level
		while ( position !== -1 )
		{
			// update topic e.b. "a.b.c" => "a.b"
			topic = topic.substr( 0, position );

			// update the position index of the next "dot" char
			position = topic.lastIndexOf( '.' );

			// deliver message
			deliverMessage( message, topic, data, immediateExceptions );
		}
	};
}

/**
 * Checks, if a message has subscribers.
 * 
 * @param {string} message - The message to check.
 * 
 * @returns {boolean} Does the message has subscribers?
 */
function hasMessageSubscribers( message ) {

	// ensure, we have a string object
	var topic = String( message );

	// check, if the message exists AND if the message has subscriptions
	var isFound = Boolean( messages.hasOwnProperty( topic ) === true && hasKeys( messages[ topic ] ) === true );

	// index to the last appearance of a dot char. used for hierarchical
	// addressing e.g. "a.b.c"
	var position = topic.lastIndexOf( "." );

	// if no subscribers were found in the current level of the hierarchy AND the
	// message contains at least a "dot", check the next level e.g. "a.b"
	while ( isFound === false && position !== -1 )
	{
		// update topic e.b. "a.b.c" => "a.b"
		topic = topic.substr( 0, position );

		// update the position index of the next "dot" char
		position = topic.lastIndexOf( "." );

		// repeat check
		isFound = Boolean( messages.hasOwnProperty( topic ) === true && hasKeys( messages[ topic ] ) === true );
	}

	return isFound;
}

/**
 * Does the publish of a message.
 * 
 * @param {string} message - The message to publish.
 * @param {object} data - The data to pass to subscribers.
 * @param {boolean} isSync - Should the message be published synchronously?
 * @param {object} isImmediateExceptions - Force immediate exceptions?
 * 
 * @returns {boolean} Is the message published successfully?
 */
function publish( message, data, isSync, isImmediateExceptions ) {

	// first, check if the topic has subscribers
	if ( hasMessageSubscribers( message ) === false )
	{
		return false;
	}

	// wrap the data into a function
	var deliver = createDeliveryFunction( message, data, isImmediateExceptions );

	// if we have a sync publish, call it immediately
	if ( isSync === true )
	{
		deliver();
	}
	// if not, call it asynchronously
	else
	{
		setTimeout( deliver, 0 );
	}

	return true;
}

/**
 * Sends a message to an entity.
 * 
 * @param {number} sender - The ID of the sender of the message.
 * @param {number} receiver - The ID of the receiver of the message.
 * @param {string} message - The message to send.
 * @param {object} data - The data to pass to receiver.
 * @param {boolean} isSync - Should the message be send synchronously?
 * @param {number} delay - The delay of the message.
 */
function sendMessageToEntity( sender, receiver, message, data, isSync, delay ) {

	var telegram;

	// first, check if the sender AND receiver are registered
	if ( entities.hasOwnProperty( sender ) === false || entities.hasOwnProperty( receiver ) === false )
	{
		logger.warn( "WARN: EventManager: Message not sent. Entities not correctly registered." );
		
		return;
	}

	// create telegram
	telegram = new Telegram( sender, receiver, message, data, delay );

	// check the type of message delivery
	if ( isSync === true )
	{
		// call the "handleMessage" method of the game entity
		if ( entities[ receiver ].handleMessage( telegram ) === false )
		{
			logger.warn( "WARN: EventManager: Message not handled by receiver with ID: %i.", receiver );
		}
	}
	else
	{
		setTimeout( function() {

			// call the "handleMessage" method of the game entity with a delay
			if ( entities[ receiver ].handleMessage( telegram ) === false )
			{
				logger.warn( "WARN: EventManager: Message not handled by receiver with ID: %i.", receiver );
			}

		}, delay );
	}
}

module.exports = new EventManager();
},{"../core/Logger":21,"../game/entity/GameEntity":48,"./Telegram":70}],70:[function(require,module,exports){
/**
 * @file This defines a telegram. A telegram is a data structure that records
 * information required to dispatch game messages. These messages are used by
 * game entities to communicate with each other.
 * 
 * @author Human Interactive
 */
"use strict";

/**
 * Creates a telegram.
 * 
 * @constructor
 * 
 * @param {number} sender - The entity that sent this telegram
 * @param {number} receiver - The entity that is to receive this telegram
 * @param {string} message - The message itself.
 * @param {object} data - Additional information that may accompany the message.
 * @param {number} delay - Messages can be dispatched immediately or delayed for a specified amount of time.
 */
function Telegram( sender, receiver, message, data, delay ) {

	Object.defineProperties( this, {
		sender : {
			value : sender,
			configurable : false,
			enumerable : true,
			writable : false
		},
		receiver : {
			value : receiver,
			configurable : false,
			enumerable : true,
			writable : false
		},
		message : {
			value : message,
			configurable : false,
			enumerable : true,
			writable : false
		},
		data : {
			value : data,
			configurable : false,
			enumerable : true,
			writable : false
		},
		delay : {
			value : delay,
			configurable : false,
			enumerable : true,
			writable : false
		}
	} );
}

module.exports = Telegram;
},{}],71:[function(require,module,exports){
/**
 * @file This file contains all topics for publish & subscribe. YUME supports a
 * publish/subscribe messaging system with hierarchical addressing, so topics
 * can be organized in a hierarchy.
 * 
 * @author Human Interactive
 */
"use strict";

var TOPIC = {
	ACTION : {
		INTERACTION : "action.interaction"
	},
	APPLICATION : {
		START : "application.start",
		ERROR : {
			MUSIC : "application.error.music"
		},
		RESIZE : "application.resize"
	},
	CONTROLS : {
		CAPTURE : "controls.capture",
		LOCK : "controls.lock"
	},
	MULTIPLAYER : {
		CHAT : "multiplayer.chat",
		PLAYER : "multiplayer.player",
		MESSAGE : "multiplayer.message",
		STATUS : "multiplayer.status",
		UPDATE : "multiplayer.update"
	},
	STAGE : {
		CHANGE : "stage.change",
		LOADING : {
			PROGRESS : "stage.loading.progress",
			START : {
				ALL : "stage.loading.start",
				AUDIO : "stage.loading.start.audio",
				MUSIC : "stage.loading.start.music",
				OBJECT : "stage.loading.start.object",
				TEXT : "stage.loading.start.text"
			},
			COMPLETE : {
				ALL : "stage.loading.complete",
				AUDIO : "stage.loading.complete.audio",
				MUSIC : "stage.loading.complete.music",
				OBJECT : "stage.loading.complete.object",
				TEXT : "stage.loading.complete.text"
			}
		},
		READY : "stage.ready",
		START : "stage.start"
	}
};

module.exports = TOPIC;
},{}],72:[function(require,module,exports){
/**
 * @file Prototype for network-messages.
 * 
 * @author Human Interactive
 */
"use strict";

/**
 * Creates a network message.
 * 
 * @constructor
 * 
 * @param {number} type - The type of the message.
 * @param {string} content - The content of the message.
 */
function Message( type, content ) {

	Object.defineProperties( this, {
		time : {
			value : Date.now(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		type : {
			value : type,
			configurable : false,
			enumerable : true,
			writable : true
		},
		content : {
			value : content,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

Message.TYPES = {
	SYSTEM : 0,
	GAME : 1,
	STATUS : 2,
	CHAT : 3,
	INFO : 4,
	ERROR : 5
};

module.exports = Message;
},{}],73:[function(require,module,exports){
(function (global){
/**
 * @file This prototype contains the entire logic for network-based
 * functionality. The core logic is executed in a separate thread.
 * 
 * @author Human Interactive
 */
"use strict";

var WebSocket = require( "ws" );

var Message = require( "./Message" );
var threadMananger = require( "../core/ThreadManager" );
var logger = require( "../core/Logger" );

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var script;
var self;
/**
 * Creates the network manager.
 * 
 * @constructor
 * 
 */
function NetworkManager() {

	Object.defineProperties( this, {
		_thread : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	self = this;
}

/**
 * Inits the network manager.
 */
NetworkManager.prototype.init = function() {

	// create thread
	this._thread = threadMananger.createThread( "network", script );

	// setup event listener
	this._thread.onMessage( this._onMessageThread );
	this._thread.onError( this._onErrorThread );

	// begin communication to server
	this._startUp();

	// subscriptions
	eventManager.subscribe( TOPIC.MULTIPLAYER.CHAT, this._onMessageChat );
	eventManager.subscribe( TOPIC.MULTIPLAYER.PLAYER, this._onMessagePlayer );
};

/**
 * Starts the communication to the server. It provides information like hostname
 * and port to the thread.
 */
NetworkManager.prototype._startUp = function( event ) {

	var message = new Message( Message.TYPES.SYSTEM, {
		location : global.window.location.hostname,
		port : NetworkManager.SERVER.PORT
	} );
	this._thread.postMessage( message );
};

/**
 * Sends a chat-message to the server.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
NetworkManager.prototype._onMessageChat = function( message, data ) {

	self._thread.postMessage( new Message( Message.TYPES.CHAT, {
		message : data
	} ) );
};

/**
 * Sends a game-message to the server.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
NetworkManager.prototype._onMessagePlayer = function( message, data ) {

	self._thread.postMessage( new Message( Message.TYPES.GAME, {
		player : data
	} ) );
};

/**
 * Handles the onMessage event. This is fired, when the thread posts a received
 * message to the manager.
 * 
 * @param {object} event - The message event.
 */
NetworkManager.prototype._onMessageThread = function( event ) {

	if ( event.data.type === Message.TYPES.CHAT )
	{
		eventManager.publish( TOPIC.MULTIPLAYER.MESSAGE, event.data.content );
	}
	else if ( event.data.type === Message.TYPES.GAME )
	{
		eventManager.publish( TOPIC.MULTIPLAYER.UPDATE, event.data.content );
	}
	else if ( event.data.type === Message.TYPES.STATUS )
	{
		eventManager.publish( TOPIC.MULTIPLAYER.STATUS, event.data.content );
	}
	else if ( event.data.type === Message.TYPES.INFO )
	{
		logger.log( event.data.content.message );
	}
	else if ( event.data.type === Message.TYPES.ERROR )
	{
		logger.error( event.data.content.message );
	}
};

/**
 * Handles the onError event. This is fired, when the thread posts an error
 * message to the manager.
 * 
 * @param {object} event - The message event.
 */
NetworkManager.prototype._onErrorThread = function( event ) {

	logger.log( "ERROR: NetworkManager: Runtime-Error in thread \"NetworkManager\", line %s in %s: %s", event.lineno, event.filename, event.message );

};

/**
 * The script for the thread. It creates and manages a WebSocket for
 * communication with the server.
 */
script = function() {

	var ws = null;

	function init( location, port ) {

		ws = new WebSocket( "ws://" + location + ":" + port );

		ws.onopen = function( event ) {

			self.postMessage( {
				type : 4,
				content : {
					message : "INFO: NetworkManager: Connected to multiplayer-server: " + location + " port: " + port
				}
			} );
		};

		ws.onclose = function( event ) {

			self.postMessage( {
				type : 4,
				content : {
					message : "INFO: NetworkManager: Disconnected from multiplayer-server: " + location + " port: " + port
				}
			} );
		};

		ws.onmessage = function( event ) {

			// convert string to JSON before posting to main-thread
			self.postMessage( JSON.parse( event.data ) );
		};

		ws.onerror = function( error ) {

			self.postMessage( {
				type : 5,
				content : {
					message : "ERROR: NetworkManager: WebSocket Error: " + error
				}
			} );
		};
	}

	function onMessage( event ) {

		// evaluate event data
		if ( event.data !== null && event.data.type !== null )
		{
			// startup
			if ( event.data.type === 0 )
			{
				if ( ws === null )
				{
					init( event.data.content.location, event.data.content.port );
				}
				// message
			}
			else if ( event.data.type === 1 || event.data.type === 2 || event.data.type === 3 )
			{
				if ( ws !== null )
				{
					if ( ws.readyState === WebSocket.OPEN )
					{
						// convert JSON to string before sending to server
						ws.send( JSON.stringify( event.data ) );
					}
					else if ( ws.readyState === WebSocket.CONNECTING )
					{
						self.postMessage( {
							type : 4,
							content : {
								message : "ERROR: NetworkManager: The connection to the server has not yet been established. Please try againg."
							}
						} );
					}
					else if ( ws.readyState === WebSocket.CLOSING && ws.readyState === WebSocket.CLOSED )
					{
						self.postMessage( {
							type : 4,
							content : {
								message : "ERROR: NetworkManager: Messaging not possible. The connection to the server has been closed or could not be opened."
							}
						} );
					}
				}
				else
				{
					self.postMessage( {
						type : 4,
						content : {
							message : "ERROR: NetworkManager: Messaging not possible. No connection to server."
						}
					} );
				}
			}
		}
	}

	self.onmessage = onMessage;
};

NetworkManager.SERVER = {
	PORT : 8000
};

module.exports = new NetworkManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/Logger":21,"../core/ThreadManager":29,"../messaging/EventManager":69,"../messaging/Topic":71,"./Message":72,"ws":2}],74:[function(require,module,exports){
/**
 * @file The particle prototype defines the properties of a single particle that
 * is used to simulate the particle effect.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates a particle.
 * 
 * @constructor
 */
function Particle() {

	Object.defineProperties( this, {
		
		// the position of the particle
		position : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the movement direction of the particle
		direction : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the displacement vector ( direction * speed * time delta )
		displacement : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the color of the particle
		color : {
			value : new THREE.Color(),
			configurable : false,
			enumerable : true,
			writable : false
		},
		// the speed of the particle
		speed : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the size of the particle
		size : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the opacity of the particle
		opacity : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the particles texture will be rotated by this value in the fragment shader
		angle : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this will manipulate how fast the angle of the particle is changed
		angleVelocity : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the duration in seconds since the particle was emitted
		age : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// how long the particle will live for. when the particle’s age has
		// exceeded it’s lifetime, it is considered “dead” and will not be
		// rendered until it is re-emitted
		lifetime : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		}
		
	} );

}

module.exports = Particle;
},{"three":1}],75:[function(require,module,exports){
/**
 * @file This prototype will be used to emit and update particles that share
 * common properties such as texture, interpolated colors, interpolated scale,
 * forces that will be applied to each particle and blending modes, and sorting
 * criteria. Since all the particles in a particle effect will all share the
 * same texture, several particle effects will be required to create a complex
 * particle effect that requires several different texture to look correct (for
 * example, a fire and smoke particle system would require at least two
 * different particle effects – one for the fire and one for the smoke).
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var logger = require( "../core/Logger" );
var world = require( "../core/World" );
var camera = require( "../core/Camera" );

var Particle = require( "./Particle" );
var Interpolator = require( "./operator/Interpolator" );
var Oscillator = require( "./operator/Oscillator" );
var Emitter = require( "./emitter/Emitter" );
var ParticleShader = require( "../shader/ParticleShader" );

/**
 * Creates a particle effect.
 * 
 * @constructor
 * 
 * @param {object} options - The options of the particle effect.
 */
function ParticleEffect( options ) {

	Object.defineProperties( this, {

		// the number of particles in this effect.
		numberOfParticles : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// a reference to a particle emitter
		emitter : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this texture will be used for all particles. if the effect requires
		// more than one texture, you need to create additional instances of
		// this prototype
		texture : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this indicates if the texture should rotate
		rotateTexture : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this indicates if the effect sorts the particles in back-to-front
		// order
		sortParticles : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this indicates if the particles should be transparent
		transparent : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this controls the blending mode
		blending : {
			value : THREE.NormalBlending,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this controls the update of the emitter. static particle effects can
		// set this value to false
		emitterAutoUpdate : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the particles of the effect
		_particles : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the geometry of the particle effect
		_particleGeometry : {
			value : new THREE.BufferGeometry(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the material of the particle effect
		_particleMaterial : {
			value : new THREE.ShaderMaterial( {
				// we can't assign the reference for defines, because particle
				// effects may need different constants in their shader program
				defines : {
					USE_SIZE_ATTENUATION : ParticleShader.defines.USE_SIZE_ATTENUATION,
					USE_TEXTURE : ParticleShader.defines.USE_TEXTURE,
					USE_ROTATION : ParticleShader.defines.USE_ROTATION
				},
				uniforms : THREE.UniformsUtils.clone( ParticleShader.uniforms ),
				vertexShader : ParticleShader.vertexShader,
				fragmentShader : ParticleShader.fragmentShader
			} ),
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the actual 3D object which contains the geometry and material of the
		// particle effect. this property will be created in the initialize
		// method
		_particleSystem : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// this will be used to store all interpolators of the effect
		_interpolators : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this will be used to store all oscillators of the effect
		_oscillators : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the maximum time delta value
		_MAX_TIME_DELTA : {
			value : 0.034,
			configurable : false,
			enumerable : false,
			writable : false
		},

	} );

	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}

	this._init();
}

/**
 * Updates the particle effect.
 * 
 * @param {number} delta - The time delta value.
 */
ParticleEffect.prototype.update = function( delta ) {

	var index, particle, deltaTime, lifeRatio;
	
	// constrain time delta value
	deltaTime = Math.min( delta, this._MAX_TIME_DELTA );

	// update emitter only if the respective flag is set
	if ( this.emitterAutoUpdate === true )
	{
		this.emitter.update();
	}

	// update all particles
	for ( index = 0; index < this._particles.length; index++ )
	{
		// buffer particle
		particle = this._particles[ index ];

		// update the displacement vector
		particle.displacement.copy( particle.direction );

		// update age of the particle
		particle.age += deltaTime;

		// if the particle exceeds its lifetime, just emit it again
		if ( particle.age > particle.lifetime )
		{
			this.emitter.emit( particle );
		}

		// this value will be used for interpolation
		lifeRatio = THREE.Math.clamp( ( particle.age / particle.lifetime ), 0, 1 );

		// execute interpolators
		if ( this._interpolators.length > 0 )
		{
			this._interpolate( particle, lifeRatio );
		}

		// execute oscillators
		if ( this._oscillators.length > 0 )
		{
			this._oscillate( particle, lifeRatio );
		}

		// angle calculation if necessary
		if ( this.rotateTexture === true )
		{
			particle.angle += particle.angleVelocity * deltaTime;
		}

		// update the position by adding the displacement
		particle.displacement.normalize().multiplyScalar( particle.speed * deltaTime );
		particle.position.add( particle.displacement );

	} // next particle

	// update the buffer data for shader program
	this._buildBuffer();

	// finally, sort the particles if necessary
	if ( this.sortParticles === true )
	{
		this._sortParticles();
	}
};

/**
 * Destroys the particle effect.
 */
ParticleEffect.prototype.destroy = function() {

	// remove the particle effect from the world
	world.removeObject3D( this._particleSystem );
};

/**
 * Adds an interpolator to the particle effect.
 * 
 * @param {Interpolator} interpolator - The interpolator object.
 * @param {String} name - The name of a particle property.
 */
ParticleEffect.prototype.addInterpolatorToProperty = function( interpolator, name ) {

	if ( interpolator instanceof Interpolator )
	{
		this._interpolators.push( {
			key : name,
			operator : interpolator
		} );
	}
	else
	{
		throw "ERROR: ParticleEffect: No valid interpolator set.";
	}

};

/**
 * Adds an oscillator to the particle effect.
 * 
 * @param {Oscillator} oscillator - The oscillator object.
 * @param {THREE.Vector3} influence - The amount of influence for a vector component.
 * @param {String} name - The name of a particle property.
 */
ParticleEffect.prototype.addOscillatorToProperty = function( oscillator, influence, name ) {

	if ( oscillator instanceof Oscillator )
	{
		this._oscillators.push( {
			key : name,
			operator : oscillator,
			influence : influence
		} );
	}
	else
	{
		throw "ERROR: ParticleEffect: No valid oscillator set.";
	}

};

/**
 * Removes an interpolator of the particle effect.
 * 
 * @param {String} name - The name of a particle property.
 */
ParticleEffect.prototype.removeInterpolatorFromProperty = function( name ) {

	var index, interpolator;

	for ( index = 0; index < this._interpolators.length; index++ )
	{
		interpolator = this._interpolators[ index ];
		
		if( interpolator.key === name ){
			
			this._interpolators.splice( index, 1 );
			
			return;
		}
	}
};

/**
 * Removes an oscillator of the particle effect.
 * 
 * @param {String} name - The name of a particle property.
 */
ParticleEffect.prototype.removeOscillatorFromProperty = function( name ) {

	var index, oscillator;

	for ( index = 0; index < this._oscillators.length; index++ )
	{
		oscillator = this._oscillators[ index ];
		
		if( oscillator.key === name ){
			
			this._oscillators.splice( index, 1 );
			
			return;
		}
	}
};

/**
 * Initializes the particle effect.
 */
ParticleEffect.prototype._init = function() {

	var index, particle, positionBuffer, colorBuffer, sizeBuffer, angleBuffer, indexBuffer;

	// check existence of a valid particle emitter
	if ( this.emitter instanceof Emitter === false )
	{
		throw "ERROR: ParticleEffect: No valid particle emitter set.";
	}

	// if no texture is set, delete the constants from the shader program that
	// controls texture sampling and rotating
	if ( this.texture === null )
	{
		delete this._particleMaterial.defines.USE_TEXTURE;
		delete this._particleMaterial.defines.USE_ROTATION;
	}
	else
	{
		// if we have a texture, we maybe want no rotation. if so, delete the
		// corresponding shader constant
		if ( this.rotateTexture === false )
		{
			delete this._particleMaterial.defines.USE_ROTATION;
		}
	}

	// set texture, transparent flag and blending mode
	this._particleMaterial.uniforms.texture.value = this.texture;
	this._particleMaterial.transparent = this.transparent;
	this._particleMaterial.blending = this.blending;

	// create buffers
	positionBuffer = new Float32Array( this.numberOfParticles * 3 );
	colorBuffer = new Float32Array( this.numberOfParticles * 4 );
	sizeBuffer = new Float32Array( this.numberOfParticles );
	angleBuffer = new Float32Array( this.numberOfParticles );

	// add buffers to geometry
	this._particleGeometry.addAttribute( "position", new THREE.BufferAttribute( positionBuffer, 3 ) );
	this._particleGeometry.addAttribute( "color", new THREE.BufferAttribute( colorBuffer, 4 ) );
	this._particleGeometry.addAttribute( "size", new THREE.BufferAttribute( sizeBuffer, 1 ) );
	this._particleGeometry.addAttribute( "angle", new THREE.BufferAttribute( angleBuffer, 1 ) );
	
	// then create the particles
	for ( index = 0; index < this.numberOfParticles; index++ )
	{
		// create a new particle
		particle = new Particle();
		
		// provide a first random lifetime.
		// this will ensure, that particles will be emitted evenly
		particle.lifetime = THREE.Math.randFloat( 0, this.emitter.maxLifetime );
		
		// push the particle to the internal array
		this._particles.push( particle );
	}

	// if we need sorted particles, we create an additional index buffer
	if ( this.sortParticles === true )
	{
		indexBuffer = new Uint16Array( this.numberOfParticles );

		for ( index = 0; index < this.numberOfParticles; index++ )
		{
			indexBuffer[ index ] = index;
		}

		this._particleGeometry.setIndex( new THREE.BufferAttribute( indexBuffer, 1 ) );
	}

	// create the particle effect
	this._particleSystem = new THREE.Points( this._particleGeometry, this._particleMaterial );

	// disable view frustum culling. this avoids disappearing particles when
	// moving the camera away from the emitter
	this._particleSystem.frustumCulled = false;

	// add the system to the world
	world.addObject3D( this._particleSystem );
};

/**
 * Builds the buffer for the particle shader program.
 */
ParticleEffect.prototype._buildBuffer = function() {

	var particle, positionBuffer, colorBuffer, sizeBuffer, angleBuffer, i, j, c;

	// shortcut to buffers
	positionBuffer = this._particleGeometry.attributes.position.array;
	colorBuffer = this._particleGeometry.attributes.color.array;
	sizeBuffer = this._particleGeometry.attributes.size.array;
	angleBuffer = this._particleGeometry.attributes.angle.array;

	// iterate over all particles and create the corresponding buffer data
	for ( i = j = c = 0; i < this._particles.length; i += 1, j += 3, c += 4 )
	{
		particle = this._particles[ i ];

		// position
		positionBuffer[ j + 0 ] = particle.position.x;
		positionBuffer[ j + 1 ] = particle.position.y;
		positionBuffer[ j + 2 ] = particle.position.z;

		// color
		colorBuffer[ c + 0 ] = particle.color.r;
		colorBuffer[ c + 1 ] = particle.color.g;
		colorBuffer[ c + 2 ] = particle.color.b;
		colorBuffer[ c + 3 ] = particle.opacity;

		// size
		sizeBuffer[ i ] = particle.size;
		
		// angle
		angleBuffer[ i ] = particle.angle;
	}

	// we need to tell three.js to update the buffers
	this._particleGeometry.attributes.position.needsUpdate = true;
	this._particleGeometry.attributes.color.needsUpdate = true;
	this._particleGeometry.attributes.size.needsUpdate = true;
	this._particleGeometry.attributes.angle.needsUpdate = true;
};

/**
 * Executes all interpolators for a given particle.
 * 
 * @param {Particle} particle - The particle object.
 * @param {number} lifeRatio - The life ratio of the particle.
 */
ParticleEffect.prototype._interpolate = function( particle, lifeRatio ) {

	var index, interpolator;

	for ( index = 0; index < this._interpolators.length; index++ )
	{
		interpolator = this._interpolators[ index ];

		// the method call of "getValue" depends on the interpolated property
		if ( particle[ interpolator.key ] instanceof THREE.Vector3 ||  particle[ interpolator.key ] instanceof THREE.Color )
		{
			interpolator.operator.getValue( lifeRatio, particle[ interpolator.key ] );
		}
		else
		{
			particle[ interpolator.key ] = interpolator.operator.getValue( lifeRatio );
		}
	}
};

/**
 * Executes all oscillators for a given particle.
 * 
 * @param {Particle} particle - The particle object.
 * @param {number} lifeRatio - The life ratio of the particle.
 */
ParticleEffect.prototype._oscillate = function( particle, lifeRatio ) {

	var index, oscillator, value;

	for ( index = 0; index < this._oscillators.length; index++ )
	{
		oscillator = this._oscillators[ index ];

		if ( particle[ oscillator.key ] instanceof THREE.Vector3 )
		{
			// first get the value of the oscillator
			value = oscillator.operator.getValue( lifeRatio );

			// the influence vector determines the amount of manipulation per
			// vector component
			particle[ oscillator.key ].x += value * oscillator.influence.x;
			particle[ oscillator.key ].y += value * oscillator.influence.y;
			particle[ oscillator.key ].z += value * oscillator.influence.z;
		}
		else
		{
			// there is no need for an influence vector if we manipulate a
			// primitive value
			particle[ oscillator.key ] += oscillator.operator.getValue( lifeRatio );
		}
	}
};

/**
 * The method sorts all particles in back-to-front order. This is sometimes
 * necessary for particles with transparency.
 */
ParticleEffect.prototype._sortParticles = ( function() {

	var vector = new THREE.Vector3();
	var mvpMatrix = new THREE.Matrix4();

	var sortArray = [];

	return function() {

		var index, positionBuffer, indexBuffer;

		// reset array
		sortArray.length = 0;

		// shortcut to buffers
		positionBuffer = this._particleGeometry.attributes.position.array;
		indexBuffer = this._particleGeometry.index.array;

		// calculate model view projection matrix
		mvpMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		mvpMatrix.multiply( this._particleSystem.matrixWorld );

		// calculate for all particles the depth an store this value along with
		// its index
		for ( index = 0; index < this._particles.length; index++ )
		{
			// transform the position vector to clip-space to get its depth
			// value
			vector.fromArray( positionBuffer, index * 3 );
			vector.applyProjection( mvpMatrix );

			// push the entry to the sort array
			sortArray.push( [ vector.z, index ] );
		}

		// execute the sort ( back-to-front )
		sortArray.sort( compareNumbers );

		// update the index buffer with the sorted values
		for ( index = 0; index < this._particles.length; index++ )
		{
			indexBuffer[ index ] = sortArray[ index ][ 1 ];
		}

		// we need to tell three.js to update the buffer
		this._particleGeometry.index.needsUpdate = true;
	};

}() );

module.exports = ParticleEffect;

/**
 * Compare function for array.sort().
 */
function compareNumbers( a, b ) {

	return b[ 0 ] - a[ 0 ];
}
},{"../core/Camera":19,"../core/Logger":21,"../core/World":31,"../shader/ParticleShader":90,"./Particle":74,"./emitter/Emitter":77,"./operator/Interpolator":80,"./operator/Oscillator":81,"three":1}],76:[function(require,module,exports){
/**
 * @file The box emitter uses an AABB to determine the position particles will
 * be emitted.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var Emitter = require( "./Emitter" );

/**
 * Creates a box emitter.
 * 
 * @constructor
 * @augments Emitter
 * 
 * @param {object} options - The options of the emitter.
 */
function BoxEmitter( options ) {
	
	Emitter.call( this );

	Object.defineProperties( this, {
		
		// the origin of the emitter
		origin : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the size of the emitter
		size : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		_boundingVolume : {
			value : new THREE.Box3(),
			configurable : false,
			enumerable : false,
			writable : true
		}
		
	} );

	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}
	
	// ensure the update method is called at least once
	this.update();
}

BoxEmitter.prototype = Object.create( Emitter.prototype );
BoxEmitter.prototype.constructor = BoxEmitter;

/**
 * Emits the particle within a predefined bounding volume.
 * 
 * @param {Particle} particle - The particle to emit.
 */
BoxEmitter.prototype.emit = ( function() {

	var position;

	return function( particle ) {
		
		if ( position === undefined )
		{
			position = new THREE.Vector3();
		}
		
		// first, call method of base prototype
		Emitter.prototype.emit.call( this, particle );

		// determine random values for position
		position.x = THREE.Math.randFloat( this._boundingVolume.min.x, this._boundingVolume.max.x );
		position.y = THREE.Math.randFloat( this._boundingVolume.min.y, this._boundingVolume.max.y );
		position.z = THREE.Math.randFloat( this._boundingVolume.min.z, this._boundingVolume.max.z );

		// add the origin of the emitter to the relative position of the
		// particle to get world coordinates
		particle.position.copy( position ).add( this.origin );

		if ( this.defaultDirection === true )
		{
			// calculate default movement direction
			particle.direction.copy( position ).normalize();
		}
		
	};

}() );

/**
 * Updates the internal state of the emitter.
 */
BoxEmitter.prototype.update = ( function() {

	var center;

	return function() {

		if ( center === undefined )
		{
			center = new THREE.Vector3();
		}

		// calculate bounding volume
		this._boundingVolume.setFromCenterAndSize( center, this.size );
	};

}() );

module.exports = BoxEmitter;
},{"./Emitter":77,"three":1}],77:[function(require,module,exports){
/**
 * @file Base prototype for all emitters.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates an emitter.
 * 
 * @constructor
 */
function Emitter() {

	Object.defineProperties( this, {
		
		// the color of a particle
		color : {
			value : new THREE.Color(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the basis movement direction vector
		directionBasis : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true		
		},
		// the spread of the movement direction
		directionSpread : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the minimum size of a particle
		minSize : {
			value : 3,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum size of a particle
		maxSize : {
			value : 5,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the minimum opacity of a particle
		minOpacity : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum opacity of a particle
		maxOpacity : {
			value : 1,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the minimum lifetime of a particle
		minLifetime : {
			value : 5,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum lifetime of a particle
		maxLifetime : {
			value : 10,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the minimum speed of a particle
		minSpeed : {
			value : 5,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum speed of a particle
		maxSpeed : {
			value : 10,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the minimum rotation speed of a particle
		minAngleSpeed : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum rotation speed of a particle
		maxAngleSpeed : {
			value : Math.PI * 0.5, // 90 degrees per second
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this controls the usage of the default particle movement direction
		// calculation of the emitter. if this is set to false, you need to
		// specify manually values for the direction
		defaultDirection : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
		
	} );

}

/**
 * Emits the particle within a predefined bounding volume.
 * 
 * @param {Particle} particle - The particle to emit.
 */
Emitter.prototype.emit = function( particle ) {

	// set color
	particle.color.copy( this.color );
	
	// set speed
	particle.speed = THREE.Math.randFloat( this.minSpeed, this.maxSpeed );

	// set particle movement direction
	particle.direction.copy( this.directionBasis );

	particle.direction.x += THREE.Math.randFloat( this.directionSpread.x * -0.5, this.directionSpread.x * 0.5 );
	particle.direction.y += THREE.Math.randFloat( this.directionSpread.y * -0.5, this.directionSpread.y * 0.5 );
	particle.direction.z += THREE.Math.randFloat( this.directionSpread.z * -0.5, this.directionSpread.z * 0.5 );

	particle.direction.normalize();
	
	// set time properties
	particle.lifetime = THREE.Math.randFloat( this.minLifetime, this.maxLifetime );
	particle.age = 0;

	// set size and opacity
	particle.size = THREE.Math.randFloat( this.minSize, this.maxSize );
	particle.opacity = THREE.Math.randFloat( this.minOpacity, this.maxOpacity );

	// set angle properties
	particle.angleVelocity = THREE.Math.randFloat( this.minAngleSpeed, this.maxAngleSpeed );
	particle.angle = 0;

};

/**
 * Updates the internal state of the emitter.
 */
Emitter.prototype.update = function() {

	throw "ERROR: Emitter: This method must be implemented in a derived emitter prototype.";
};

module.exports = Emitter;
},{"three":1}],78:[function(require,module,exports){
/**
 * @file The mesh emitter uses an arbitrary mesh to determine the position
 * particles will be emitted.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var Emitter = require( "./Emitter" );

/**
 * Creates a mesh emitter.
 * 
 * @constructor
 * @augments Emitter
 * 
 * @param {object} options - The options of the emitter.
 */
function MeshEmitter( options ) {

	Emitter.call( this );

	Object.defineProperties( this, {

		// the mesh of the emitter
		mesh : {
			value : null,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// this will be used to store the vertex normals. access via vertex
		// index
		_vertexNormals : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : false
		},
		// this will be used to calculate the vertex normal in world space
		_normalMatrix : {
			value : new THREE.Matrix3(),
			configurable : false,
			enumerable : false,
			writable : false
		}

	} );

	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}

	// retrieve the vertex normals for velocity calculation
	this._getVertexNormals();

	// ensure the update method is called at least once
	this.update();
}

MeshEmitter.prototype = Object.create( Emitter.prototype );
MeshEmitter.prototype.constructor = MeshEmitter;

/**
 * Emits the particle within a predefined bounding volume.
 * 
 * @param {Particle} particle - The particle to emit.
 */
MeshEmitter.prototype.emit = ( function() {

	var position;

	return function( particle ) {

		var vertexIndex;

		if ( position === undefined )
		{
			position = new THREE.Vector3();
		}
		
		// first, call method of base prototype
		Emitter.prototype.emit.call( this, particle );

		// determine randomly a vertex from the geometry
		vertexIndex = THREE.Math.randInt( 0, this.mesh.geometry.vertices.length - 1 );

		// copy the vertex data to the position vector of the particle
		particle.position.copy( this.mesh.geometry.vertices[ vertexIndex ] );

		// finally, we need to apply the world matrix of the mesh to calculate
		// the world position of the particle
		particle.position.applyMatrix4( this.mesh.matrixWorld );
		
		// calculate default movement direction
		if ( this.defaultDirection === true ){
			
			// the vertex normal determines the movement direction of the particle
			particle.direction.copy( this._vertexNormals[ vertexIndex ] );

			// transform the direction/normal to world space
			particle.direction.applyMatrix3( this._normalMatrix ).normalize();
		}
		
	};

}() );

/**
 * Updates the internal state of the emitter.
 */
MeshEmitter.prototype.update = function() {

	// update the world matrix of the mesh
	this.mesh.updateMatrixWorld( true );

	// update the normal matrix. used for velocity calculation
	this._normalMatrix.getNormalMatrix( this.mesh.matrixWorld );
};

/**
 * This method creates a simple map for fast access to the vertex normal via the
 * index of a vertex.
 */
MeshEmitter.prototype._getVertexNormals = function() {

	var index;

	// first, calculate face and vertex normals
	this.mesh.geometry.computeFaceNormals();
	this.mesh.geometry.computeVertexNormals( true );

	// then create the map. save the vertex normal along with the vertex index
	for ( index = 0; index < this.mesh.geometry.vertices.length; index++ )
	{
		this._vertexNormals[ index ] = this._getVertexNormal( index );
	}

};

/**
 * Returns the normal of a given vertex.
 * 
 * @param {number} vertexIndex - The index of the vertex.
 */
MeshEmitter.prototype._getVertexNormal = ( function() {

	var keys;

	return function( vertexIndex ) {

		var face, i, j;

		if ( keys === undefined )
		{
			keys = [ "a", "b", "c" ];
		}

		// iterate over all faces to retrieve the vertex normal
		for ( i = 0; i < this.mesh.geometry.faces.length; i++ )
		{
			face = this.mesh.geometry.faces[ i ];

			for ( j = 0; j < face.vertexNormals.length; j++ )
			{
				// if the index of the current face vertex is equal with the
				// given index, we can return the vertex normal
				if ( face[ keys[ j ] ] === vertexIndex )
				{
					return face.vertexNormals[ j ];
				}

			} // next vertex normal

		} // next face
	};

}() );

module.exports = MeshEmitter;
},{"./Emitter":77,"three":1}],79:[function(require,module,exports){
/**
 * @file The sphere emitter will randomly emit a particle somewhere about a
 * sphere within some range. The emitter uses spherical coordinates to determine
 * the range in which particles will be emitted in. The spherical coordinates
 * are converted to Cartesian coordinates to determine the position and velocity
 * that the particle is emitted in 3D space.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

var Emitter = require( "./Emitter" );

/**
 * Creates a sphere emitter.
 * 
 * @constructor
 * @augments Emitter
 * 
 * @param {object} options - The options of the emitter.
 */
function SphereEmitter( options ) {
	
	Emitter.call( this );

	Object.defineProperties( this, {
		
		// the origin of the emitter
		origin : {
			value : new THREE.Vector3(),
			configurable : false,
			enumerable : true,
			writable : true
		},
		// radius must be in range: [ 0, ∞ )
		// the minimum radius
		minRadius : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum radius
		maxRadius : {
			value : 10,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// azimuth must be in range: [ 0, 2π )
		// the minimum azimuth
		minAzimuth : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum azimuth
		maxAzimuth : {
			value : Math.PI * 1.999,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// inclination must be in range: [ 0, π ]
		// the minimum inclination
		minInclination : {
			value : 0,
			configurable : false,
			enumerable : true,
			writable : true
		},
		// the maximum inclination
		maxInclination : {
			value : Math.PI,
			configurable : false,
			enumerable : true,
			writable : true
		}

	} );

	// transfer the options values to the object
	for ( var property in options )
	{
		if ( options.hasOwnProperty( property ) )
		{
			this[ property ] = options[ property ];
		}
	}
	
	// ensure the update method is called at least once
	this.update();
}

SphereEmitter.prototype = Object.create( Emitter.prototype );
SphereEmitter.prototype.constructor = SphereEmitter;

/**
 * Emits the particle within a predefined bounding volume.
 * 
 * @param {Particle} particle - The particle to emit.
 */
SphereEmitter.prototype.emit = ( function() {

	var position;

	return function( particle ) {

		var azimuth, inclination, sinusInclination, radius;

		if ( position === undefined )
		{
			position = new THREE.Vector3();
		}

		// first, call method of base prototype
		Emitter.prototype.emit.call( this, particle );

		// calculate components of polar coordinates
		azimuth = THREE.Math.randFloat( this.minAzimuth, this.maxAzimuth );
		inclination = THREE.Math.randFloat( this.minInclination, this.maxInclination );

		// determine random values for radius, speed, lifetime, size and angle
		// velocity
		radius = THREE.Math.randFloat( this.minRadius, this.maxRadius );

		// determine the relative position of the particle by converting Polar
		// coordinates to Cartesian coordinates
		sinusInclination = Math.sin( inclination );

		position.x = sinusInclination * Math.cos( azimuth );
		position.y = sinusInclination * Math.sin( azimuth );
		position.z = Math.cos( inclination );

		particle.position.copy( position ).multiplyScalar( radius );

		// add the origin of the emitter to the relative position of the
		// particle to get world coordinates
		particle.position.add( this.origin );
		
		if ( this.defaultDirection === true )
		{
			// calculate default movement direction
			particle.direction.copy( position ).normalize();
		}
	};

}() );

/**
 * Updates the internal state of the emitter.
 */
SphereEmitter.prototype.update = function() {

	// nothing to do here
};

module.exports = SphereEmitter;
},{"./Emitter":77,"three":1}],80:[function(require,module,exports){
/**
 * @file This prototype will be used to interpolate within a predefined set of
 * values. There must be added at least two values for interpolation. Can be
 * used to execute a linear interpolation of particle properties.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates an interpolator.
 * 
 * @constructor
 */
function Interpolator() {

	Object.defineProperties( this, {

		// alpha values are stored in a sortable array
		_alpha : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		// the actual values are stored in an object. access via respective
		// alpha value
		_values : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : false
		}

	} );

}

/**
 * Adds a value to the internal map.
 * 
 * @param {number} alpha - This value determines the interpolation.
 * @param {object} value - The actual value. Can be a number, THREE.Vector or
 * THREE.Color.
 */
Interpolator.prototype.addValue = function( alpha, value ) {

	// store the alpha value and sort the array
	this._alpha.push( alpha );
	this._alpha.sort();

	// store the value
	this._values[ alpha ] = value;
};

/**
 * Returns an interpolated value at a given alpha value. If the internal values
 * are objects, the "target" parameter must be used to obtain a result, because
 * the method won't create new objects for performance reasons.
 * 
 * @param {number} alpha - This value determines the interpolation.
 * @param {object} target - The target object. Not used for primitive values.
 */
Interpolator.prototype.getValue = function( alpha, target ) {

	var result, index, alphaStart, alphaEnd, ratio, valueStart, valueEnd;

	// iterate over all map entries to determine the closest values for the
	// given alpha value (in other words: start and end value for interpolation)
	for ( index = 0; index < this._alpha.length; index++ )
	{
		if ( this._alpha[ index ] <= alpha )
		{
			alphaStart = this._alpha[ index ];
		}

		if ( this._alpha[ index ] > alpha )
		{
			alphaEnd = this._alpha[ index ];
			break;
		}
	}

	// case 1: the given alpha value is smaller than all alpha values in the
	// map
	if ( alphaStart === undefined )
	{
		// no interpolation, just return the first value of the map
		result = this._values[ this._alpha[ 0 ] ];

		if ( target !== undefined )
		{
			target.copy( result );
			return;
		}
		else
		{
			return result;
		}
	}

	// case 2: the given alpha value is greater than all alpha values in the
	// map
	if ( alphaEnd === undefined )
	{
		// no interpolation, just return the last value of the map
		result = this._values[ this._alpha[ this._alpha.length - 1 ] ];

		if ( target !== undefined )
		{
			target.copy( result );
			return;
		}
		else
		{
			return result;
		}
	}

	// case 3: the given alpha value lies between two values of the map.
	// interpolation required
	ratio = ( alpha - alphaStart ) / ( alphaEnd - alphaStart );

	valueStart = this._values[ alphaStart ];
	valueEnd = this._values[ alphaEnd ];

	if ( target !== undefined )
	{
		target.copy( valueStart ).lerp( valueEnd, ratio );
		return;
	}
	else
	{
		return valueStart * ( 1 - ratio ) + ( valueEnd * ratio );
	}

};

module.exports = Interpolator;
},{"three":1}],81:[function(require,module,exports){
/**
 * @file This prototype will be used to manipulate vectors with an oscillation
 * animation. This operator can be used to create a wavy particle effects.
 * 
 * @author Human Interactive
 */

"use strict";

var utils = require( "../../etc/Utils" );

/**
 * Creates an oscillator.
 * 
 * @constructor
 * 
 * @param {number} amplitude - The amplitude of the oscillator.
 * @param {number} period - The time period of a single wave in seconds.
 * @param {number} offset - The offset of the oscillator curve.
 */
function Oscillator( amplitude, period, offset ) {

	Object.defineProperties( this, {

		amplitude : {
			value : amplitude || 1,
			configurable : false,
			enumerable : false,
			writable : false
		},
		period : {
			value : period || 1,
			configurable : false,
			enumerable : false,
			writable : false
		},
		offset : {
			value : offset || 0,
			configurable : false,
			enumerable : false,
			writable : false
		}

	} );

}

/**
 * Calculates the value of the oscillation animation.
 * 
 * @param {number} alpha - The alpha value of the function.
 *  
 * @returns {number} The calculated value.
 */
Oscillator.prototype.getValue = function( alpha ){
	
	return ( this.amplitude * Math.sin( ( alpha * utils.TWO_PI ) / this.period ) ) + this.offset;
};

module.exports = Oscillator;
},{"../../etc/Utils":45}],82:[function(require,module,exports){
/**
 * @file This prototype manages effects for post-processing.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates the effect composer.
 * 
 * @constructor
 * 
 * @param {THREE.WebGLRenderer} renderer - The WebGL renderer.
 * @param {THREE.WebGLRenderTarget} renderTarget - The render target.
 */
function EffectComposer( renderer, renderTarget ) {

	Object.defineProperties( this, {
		_passes : {
			value : [],
			configurable : false,
			enumerable : false,
			writable : false
		},
		_renderer : {
			value : renderer,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_renderTarget : {
			value : renderTarget,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_readBuffer : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_writeBuffer : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	// if no render target is assigned, let's create a new one
	if ( this._renderTarget === undefined )
	{
		var width = this._renderer.context.drawingBufferWidth;
		var height = this._renderer.context.drawingBufferHeight;
		var parameters = {
			minFilter : THREE.LinearFilter,
			magFilter : THREE.LinearFilter,
			format : THREE.RGBFormat,
			stencilBuffer : false
		};

		this._renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	}

	// create read/write buffers based on the render target
	this._readBuffer = this._renderTarget;
	this._writeBuffer = this._renderTarget.clone();
}

/**
 * Adds a pass to the internal array.
 * 
 * @param {object} pass - Render or shader pass.
 */
EffectComposer.prototype.addPass = function( pass ) {

	this._passes.push( pass );
};

/**
 * Removes a pass from the internal array.
 * 
 * @param {object} pass - Render or shader pass.
 */
EffectComposer.prototype.removePass = function( pass ) {

	var index = this._passes.indexOf( pass );
	this._passes.splice( index, 1 );
};

/**
 * Removes all Shader Passes from the internal array.
 */
EffectComposer.prototype.removePasses = function() {

	this._passes.length = 0;
};

/**
 * Does the actual post processing.
 */
EffectComposer.prototype.render = function() {

	var pass, index;

	// process all assigned passes and call their render method
	for ( index = 0; index < this._passes.length; index++ )
	{
		pass = this._passes[ index ];

		if ( pass.enabled === true )
		{
			pass.render( this._renderer, this._writeBuffer, this._readBuffer );

			if ( pass.needsSwap === true )
			{
				this._swapBuffers();
			}
		}
	}
	
};

/**
 * Sets the size of the render target.
 * 
 * @param {number} width - The width of render target.
 * @param {number} height - The height of render target.
 */
EffectComposer.prototype.setSize = function( width, height ) {

	var renderTarget = this._renderTarget.clone();

	renderTarget.width = width * this._renderer.getPixelRatio();
	renderTarget.height = height * this._renderer.getPixelRatio();

	this._reset( renderTarget );
};

/**
 * Swaps the internal framebuffers.
 */
EffectComposer.prototype._swapBuffers = function() {

	var temp = this._readBuffer;
	this._readBuffer = this._writeBuffer;
	this._writeBuffer = temp;

};

/**
 * Resets the internal render targets/framebuffers.
 * 
 * @param {THREE.WebGLRenderTarget} renderTarget - The render target.
 */
EffectComposer.prototype._reset = function( renderTarget ) {

	if ( renderTarget === undefined )
	{
		renderTarget = this._renderTarget.clone();

		renderTarget.width = this._renderer.context.drawingBufferWidth;
		renderTarget.height = this._renderer.context.drawingBufferHeight;

	}

	this._renderTarget = renderTarget;

	this._readBuffer = this._renderTarget;
	this._writeBuffer = this._renderTarget.clone();

};

module.exports = EffectComposer;
},{"three":1}],83:[function(require,module,exports){
/**
 * @file This prototype provides a render pass for post-processing.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates a render pass.
 * 
 * @constructor
 * 
 * @param {Scene} scene - The scene object.
 * @param {Camera} camera - The camera object.
 */
function RenderPass( scene, camera ) {

	Object.defineProperties( this, {
		_scene : {
			value : scene,
			configurable : false,
			enumerable : false,
			writable : false
		},
		_camera : {
			value : camera,
			configurable : false,
			enumerable : false,
			writable : false
		},
		enabled : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		},
		needsSwap : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : false
		}
	} );
}

/**
 * Renders the scene to a custom framebuffer for further processing.
 * 
 * @param {THREE.WebGLRenderer} renderer - The WebGL renderer.
 * @param {THREE.WebGLRenderTarget} writeBuffer - The target framebuffer.
 * @param {THREE.WebGLRenderTarget} readBuffer - The source framebuffer.
 */
RenderPass.prototype.render = function( renderer, writeBuffer, readBuffer ) {

	renderer.render( this._scene, this._camera, readBuffer, true );
};

module.exports = RenderPass;
},{"three":1}],84:[function(require,module,exports){
/**
 * @file This prototype provides a shader pass for post-processing.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

/**
 * Creates a shader pass.
 * 
 * @constructor
 * 
 * @param {object} shader - The shader source code.
 * @param {string} textureID - The name of the texture, which represents the
 * readBuffer.
 */
function ShaderPass( shader, textureID ) {

	Object.defineProperties( this, {
		_textureID : {
			value : ( textureID !== undefined ) ? textureID : "tDiffuse",
			configurable : false,
			enumerable : false,
			writable : false
		},
		_scene : {
			value : new THREE.Scene(),
			configurable : false,
			enumerable : false,
			writable : false
		},
		_camera : {
			value : new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 ),
			configurable : false,
			enumerable : false,
			writable : false
		},
		uniforms : {
			value : THREE.UniformsUtils.clone( shader.uniforms ),
			configurable : false,
			enumerable : true,
			writable : false
		},
		enabled : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		},
		needsSwap : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : false
		},
		renderToScreen : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	var quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	quad.material = new THREE.ShaderMaterial( {

		defines : shader.defines || {},
		uniforms : this.uniforms,
		vertexShader : shader.vertexShader,
		fragmentShader : shader.fragmentShader

	} );

	this._scene.add( quad );
}

/**
 * Renders a post processing effect.
 * 
 * @param {THREE.WebGLRenderer} renderer - The WebGL renderer.
 * @param {THREE.WebGLRenderTarget} writeBuffer - The target framebuffer.
 * @param {THREE.WebGLRenderTarget} readBuffer - The source framebuffer.
 */
ShaderPass.prototype.render = function( renderer, writeBuffer, readBuffer ) {

	if ( this.uniforms[ this._textureID ] !== undefined )
	{
		this.uniforms[ this._textureID ].value = readBuffer;
	}

	// determine screen/ off-screen rendering
	if ( this.renderToScreen === true )
	{
		renderer.render( this._scene, this._camera );
	}
	else
	{
		renderer.render( this._scene, this._camera, writeBuffer, false );
	}
};

module.exports = ShaderPass;
},{"three":1}],85:[function(require,module,exports){
/**
 * @file This shader can be used for vertex displacement to create water or
 * fabric materials. It implements an exemplary diffuse lighting equation, which
 * uses ambient and directional lights.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {
		
	defines: {
		NUM_OCTAVES: 5
	},

	uniforms : THREE.UniformsUtils.merge( [ THREE.UniformsLib.lights, {
		"fTime" : {
			type : "f",
			value : 0
		}
	} ] ),

	lights : true, // use lights of stage in this shader

	vertexShader : [

	"uniform float fTime;",

	"varying vec3 vNormalWorld;",

	// 1D random function
	"float random( float x ) {", 
	
		"return fract( sin( x ) * 1e4 );",
		
	"}",

	// 3D value noise function
	"float noise( vec3 x ) {",

		"const vec3 step = vec3( 110, 241, 171 );",

		"vec3 i = floor( x );", 
		"vec3 f = fract( x );",

		"float n = dot( i, step );",

		"vec3 u = f * f * ( 3.0 - 2.0 * f );",

		"return mix( mix( mix( random( n + dot( step, vec3( 0, 0, 0 ) ) ), random( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ),", 
						 "mix( random( n + dot( step, vec3( 0, 1, 0 ) ) ), random( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ),", 
					"mix( mix( random( n + dot( step, vec3( 0, 0, 1 ) ) ), random( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ),", 
						 "mix( random( n + dot( step, vec3( 0, 1, 1 ) ) ), random( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z );", 
						 
	"}",

	// 3D fbm-noise function
	"float fbm( in vec3 x ) {",

		"float v = 0.0;", 
		"float a = 0.5;",

		"vec3 shift = vec3( 100 );",

		"for ( int i = 0; i < NUM_OCTAVES; ++i ) {",

			// sum noise functions
			"v += a * noise( x );", "x = x * 2.0 + shift;", "a *= 0.5;",
			
		"}",

		"return v;",

	"}",

	"void main(){",

		// calculate new vertex position (displacement)
		"vec3 newPosition = position + 10.0 * normal * fbm( position * 0.05 + 0.05 * fTime );",

		// calculate normal in world space
		"vNormalWorld = normalize( modelMatrix * vec4( normal, 0.0 ) ).xyz;",

		"gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );",

	"}"

	].join( "\n" ),

	fragmentShader : [

	"uniform vec3 ambientLightColor;", 
	"uniform vec3 directionalLightDirection[MAX_DIR_LIGHTS];", 
	"uniform vec3 directionalLightColor[MAX_DIR_LIGHTS];",

	"varying vec3 vNormalWorld;",

	"void main() {",

		"vec4 color = vec4( 0.0, 0.0, 1.0, 1.0 );", "vec3 diffuseLightColor = vec3( 0.0, 0.0, 0.0 );",

		// calculate for each directional light the diffuse light color
		"for( int l = 0; l < MAX_DIR_LIGHTS; l++ ) {",

			"diffuseLightColor += max( dot ( vNormalWorld, directionalLightDirection[ l ] ), 0.0 ) * directionalLightColor[ l ];",

		"}",

		"vec3 lightWeighting = ambientLightColor + diffuseLightColor;",

		"gl_FragColor = vec4( color.rgb * lightWeighting, color.a );",

	"}"

	].join( "\n" )
};
},{"three":1}],86:[function(require,module,exports){
/**
 * @file This shader creates a 2D flame. Use it as a material along with
 * a view-oriented billboard to simulate candles or other fire effects. If you
 * have performance issues with this shader, use sprite animations instead.
 * 
 * @author Human Interactive
 */

"use strict";

module.exports = {
		
	defines: {
		NUM_OCTAVES: 5
	},

	uniforms : {

		// use this to control the motion speed of the flame
		"speed" : {
			type : "f",
			value : 0.3
		},
		// use this to control the disturbance of the flame. a higher value
		// means more scattering
		"scattering" : {
			type : "f",
			value : 1.0
		},
		// use this to control the sharpness of the flame's border
		"sharpness" : {
			type : "f",
			value : 64
		},
		// use this to control the general intensity of the flame. lower values
		// will dim the light
		"intensity" : {
			type : "f",
			value : 1.5
		},
		// the elapsed time
		"time" : {
			type : "f",
			value : 0.0
		}

	},

	vertexShader : [
	                
	    "varying vec2 vUv;",

		"void main(){",
	
			"vUv = uv;",
	
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
		"}"

	].join( "\n" ),

	fragmentShader : [

		"uniform float speed;",
		"uniform float scattering;",
		"uniform float sharpness;",
		"uniform float intensity;",
		"uniform float time;",
		
		"varying vec2 vUv;",
	                  
		"float random( in float x ) {",
		
		    "return fract( sin( x ) * 1e4 );",
		"}",
		
		"float random( in vec2 uv ) {",
		    
		    "return fract( 1e4 * sin( 17.0 * uv.x + uv.y * 0.1 ) * ( 0.1 + abs( sin( uv.y * 13.0 + uv.x ) ) ) );",
		"}",
		
		"float noise( in vec2 x ) {",
		    
		    "vec2 i = floor( x );",
		    "vec2 f = fract( x );",
		    
		    // these four points are used for interpolation in 2D
		    "float a = random( i );",
		    "float b = random( i + vec2( 1.0, 0.0 ) );",
		    "float c = random( i + vec2( 0.0, 1.0 ) );",
		    "float d = random( i + vec2( 1.0, 1.0 ) );",
		    
		    // cubic curve for interpolation
		    "vec2 u = f * f * ( 3.0 - 2.0 * f );",
		    
		    "return mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;",
		"}",
		
		"float fbm( in vec2 x ) {",
		    
		    "float v = 0.0;",
		    "float a = 0.5;",
		    
		    "vec2 shift = vec2( 100 );",
		    
		    // rotate to reduce axial bias
		    "mat2 rot = mat2( cos( 0.5 ), sin( 0.5 ), -sin( 0.5 ), cos( 0.5 ) );",
		    
		    "for ( int i = 0; i < NUM_OCTAVES; ++i ) {",
		        
		        // sum noise functions
		        "v += a * noise( x );",
		        "x = rot * x * 2.0 + shift;",
		        "a *= 0.5;",
		    "}",
		    
		    "return v;",
		"}",
		
		"void main(){",
			
		    "vec2 position = vUv;",
		    
		    // position the flame in the center of the screen
		    "position.x -= 0.5;",
		    "position.y -= 0.25;",
		    
		    // the default color of the background/border
		    "vec4 defaultColor = vec4( 0.5, 0.5, 0.5, 0.0 );",
		    
		    // this will calculate the motions and structure of the flame
		    "float n = fbm( vUv * scattering - vec2( 0.0, time * speed ) );",
		    
		    // this will compute the form of the flame
		    "float c = 1.0 - sharpness * pow( max( 0.0, length( position * vec2( 4.0 + position.y, 1.0 ) ) - n * max( 0.0, position.y + 0.25 ) ), 1.2 );",
		    "float c1 = n * c * ( 1.5 - pow( 1.2 * vUv.y, 4.0 ) );",
		    
		    // ensure the value is between zero and one
		    "c1 = clamp( c1, 0.0 ,1.0 );",
		    
		    // the color of the flame
		    "vec4 flameColor = vec4( 1.5 * c1, 1.5 * c1 * c1 * c1, c1 * c1 * c1 * c1 * c1 * c1, 1.0 );",
		    
		    // this will determine the final shape of the flame
		    "float a =  c * ( 1.0 - pow( vUv.y, intensity ) );",
		    
		    // mix the background and flame shape
		    "gl_FragColor = vec4( mix( defaultColor, flameColor, a ) );",
		    
		"}",

	].join( "\n" )
};
},{}],87:[function(require,module,exports){
/**
 * @file This shader applies a gaussian blur effect. Used in post-processing.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {

	uniforms : {

		"tDiffuse" : {
			type : "t",
			value : null
		},
		// the direction of the blur: (1.0, 0.0) -> x-axis blur, (0.0, 1.0) -> y-axis blur
		"direction" : {
			type : "v2",
			value : new THREE.Vector2()
		},
		// the size of a pixel
		"size" : {
			type : "f",
			value : 0.0
		},

	},

	vertexShader : [

	"varying vec2 vUv;",

	"void main(){",

		"vUv = uv;",

		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

	"}"

	].join( "\n" ),

	fragmentShader : [

	"uniform sampler2D tDiffuse;", 
	"uniform vec2 direction;", 
	"uniform float size;",

	"varying vec2 vUv;",

	"void main() {",

		// the result color
		"vec4 result = vec4( 0.0 );", 

		// sample the texture 9 times for every fragment (9-tap filter)
		"result += texture2D( tDiffuse, vec2( vUv.x - 4.0 * size * direction.x, vUv.y - 4.0 * size * direction.y ) ) * 0.0162162162;", 
		"result += texture2D( tDiffuse, vec2( vUv.x - 3.0 * size * direction.x, vUv.y - 3.0 * size * direction.y ) ) * 0.0540540541;", 
		"result += texture2D( tDiffuse, vec2( vUv.x - 2.0 * size * direction.x, vUv.y - 2.0 * size * direction.y ) ) * 0.1216216216;", 
		"result += texture2D( tDiffuse, vec2( vUv.x - 1.0 * size * direction.x, vUv.y - 1.0 * size * direction.y ) ) * 0.1945945946;",

		"result += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.2270270270;",

		"result += texture2D( tDiffuse, vec2( vUv.x + 1.0 * size * direction.x, vUv.y + 1.0 * size * direction.y ) ) * 0.1945945946;", 
		"result += texture2D( tDiffuse, vec2( vUv.x + 2.0 * size * direction.x, vUv.y + 2.0 * size * direction.y ) ) * 0.1216216216;", 
		"result += texture2D( tDiffuse, vec2( vUv.x + 3.0 * size * direction.x, vUv.y + 3.0 * size * direction.y ) ) * 0.0540540541;", 
		"result += texture2D( tDiffuse, vec2( vUv.x + 4.0 * size * direction.x, vUv.y + 4.0 * size * direction.y ) ) * 0.0162162162;",

		"gl_FragColor = result;",

	"}"

	].join( "\n" )
};
},{"three":1}],88:[function(require,module,exports){
/**
 * @file This shader transforms all colors to grayscale. Used in
 * post-processing.
 * 
 * @author Human Interactive
 */

"use strict";

module.exports = {

	uniforms : {

		"tDiffuse" : {
			type : "t",
			value : null
		}

	},

	vertexShader : [

	"varying vec2 vUv;",

	"void main(){",

		"vUv = uv;",

		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

	"}"

	].join( "\n" ),

	fragmentShader : [

	"uniform sampler2D tDiffuse;",

	"varying vec2 vUv;",

	"void main() {",

		// sample the texture
		"vec4 texelColor = texture2D( tDiffuse, vUv );",

		// NTSC conversion weights
		"float grayscale = dot( texelColor.rgb, vec3( 0.299, 0.587, 0.114 ) );",

		// apply grayscale to the each rgb channel
		"gl_FragColor = vec4( vec3( grayscale ), texelColor.a );",

	"}"

	].join( "\n" )
};
},{}],89:[function(require,module,exports){
/**
 * @file This shader creates a simple horizon. Use this shader as a material on
 * a sphere.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {

	uniforms : {

		"colorTop" : {
			type : "c",
			value : new THREE.Color( 0x000000 )
		},
		"colorBottom" : {
			type : "c",
			value : new THREE.Color( 0xff0000 )
		},
		// use this to change the vertical position of the horizon
		"offset" : {
			type : "f",
			value : 0
		},
		// use this to manipulate the gradient. value must be positive
		// high values: more bottom color
		// low values: more top color
		"exponent" : {
			type : "f",
			value : 0.6
		}

	},

	vertexShader : [

		"varying vec3 vWorldPosition;",
	
		"void main(){",
	
			// calculate the world position of the vertex. used in fragment shader to
			// determine the relative height and distance of the fragment to the horizon.
			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
	
			"vWorldPosition = worldPosition.xyz;",
	
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
		"}"

	].join( "\n" ),

	fragmentShader : [
	                  
		"uniform vec3 colorTop;",
		"uniform vec3 colorBottom;",
		"uniform float offset;",
		"uniform float exponent;",
	
		"varying vec3 vWorldPosition;",
	
		"void main() {",
	
			// this indicates the relative height and distance of the current fragment to the horizon ( default: y = 0 plane ).
			// a negative value means full bottom color. a positive value means a gradient value from bottom to top color.
			"float h = normalize( vWorldPosition + offset ).y;",
	
			"gl_FragColor = vec4( mix( colorBottom, colorTop, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );",
	
		"}"

	].join( "\n" )
};
},{"three":1}],90:[function(require,module,exports){
/**
 * @file This shader will be used as a material for particles.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {

	defines : {

		// this activates size attenuation for particles. if you don't need
		// this, just delete this entry in the particle effect
		SIZE_ATTENUATION : "",

		// this activates texture sampling. delete this constant in the particle
		// effect if you don't use a texture, otherwise you will get a black particle
		USE_TEXTURE : "",

		// this activates texture rotating. delete this constant in the particle
		// effect if you want static textures
		USE_ROTATION : ""
	},

	uniforms : {

		// the texture of the particles
		"texture" : {
			type : "t",
			value : null
		}

	},

	vertexShader : [

		// the size of a particle
		"attribute float size;",
		
		// the angle of a particle
		"attribute float angle;",
	
		// the color of a particle
		"attribute vec4 color;",
	
		// and it is used by the fragment shader
		"varying vec4 vColor;",
		
		// angle is only used by the fragment shader if we want to rotate the texture
		"#ifdef USE_ROTATION",
		
			"varying float vAngle;",
			
		"#endif",
	
		"void main(){",

			// assign attributes to varyings
			"vColor = color;",
			
			"#ifdef USE_ROTATION",
			
				"vAngle = angle;",
				
			"#endif",
			
			// calculate the position in eye/camera space
			"vec4 positionEye = modelViewMatrix * vec4( position, 1.0 );",
	
			// check symbolic constant to control size attenuation
			"#ifdef USE_SIZE_ATTENUATION",
	
				// to create a realistic effect we need to ensure that particles
				// receive a greater point size if they are close to the camera
				"gl_PointSize = size * ( 300.0 / length( positionEye.xyz ) );",
	
			"#else",
	
				"gl_PointSize = size;",
	
			"#endif",
	
			"gl_Position = projectionMatrix * positionEye;",
	
		"}"

	].join( "\n" ),

	fragmentShader : [

		"uniform sampler2D texture;",
	
		"varying vec4 vColor;",
		
		"#ifdef USE_ROTATION",
		
			"varying float vAngle;",
			
		"#endif",
	
		"void main() {",
		
			"vec4 color = vColor;",
					
			"#ifdef USE_TEXTURE",
			
				"vec2 uv = gl_PointCoord;",
			
				"#ifdef USE_ROTATION",
			
					"float c = cos( vAngle );",	
					"float s = sin( vAngle );",
				
					// this will rotate the UV coordinate by the given angle. 
					// rotating the texture will look like rotating the entire particle
					"uv = vec2( c * ( uv.x - 0.5 ) + s * ( uv.y - 0.5 ) + 0.5, c * ( uv.y - 0.5 ) - s * ( uv.x - 0.5 ) + 0.5 );",
				
				"#endif",

				"color *= texture2D( texture, uv );",
			
			"#endif",
	
			"gl_FragColor = color;",
	
		"}"

	].join( "\n" )
};
},{"three":1}],91:[function(require,module,exports){
/**
 * @file This shader is used as a material for reflectors.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {

	uniforms : {

		// this texture contains the reflection
		"reflectionMap" : {
			type : "t",
			value : null
		},
		
		// this matrix is used for projective texture mapping
		"textureMatrix" : {
			type : "m4",
			value : null
		}

	},

	vertexShader : [

		"uniform mat4 textureMatrix;",
	
		"varying vec4 vUv;",
	
		"void main() {",
	
			// uv coordinates for texture projection
			"vUv = textureMatrix * vec4( position, 1.0 );",
	
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
		"}"

	].join( "\n" ),

	fragmentShader : [

		"uniform sampler2D reflectionMap;",
		
		"varying vec4 vUv;",
		
		"void main() {",

			"gl_FragColor = texture2DProj( reflectionMap, vUv );",
		
		"}"

	].join( "\n" )
};
},{"three":1}],92:[function(require,module,exports){
/**
 * @file This shader is used as a material for refractors.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {

	uniforms : {

		// this texture contains the refraction
		"refractionMap" : {
			type : "t",
			value : null
		},
		
		// this matrix is used for projective texture mapping
		"textureMatrix" : {
			type : "m4",
			value : null
		}

	},

	vertexShader : [

		"uniform mat4 textureMatrix;",
	
		"varying vec4 vUv;",
	
		"void main() {",
	
			// uv coordinates for texture projection
			"vUv = textureMatrix * vec4( position, 1.0 );",
	
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
		"}"

	].join( "\n" ),

	fragmentShader : [

		"uniform sampler2D refractionMap;",
		
		"varying vec4 vUv;",
		
		"void main() {",

			"gl_FragColor = texture2DProj( refractionMap, vUv );",
		
		"}"

	].join( "\n" )
};
},{"three":1}],93:[function(require,module,exports){
/**
 * @file This shader creates a vignette effect. Used in post-processing.
 * 
 * @author Human Interactive
 */

"use strict";

module.exports = {

	uniforms : {

		"tDiffuse" : {
			type : "t",
			value : null
		},
		// radius of the vignette, where 0.5 results in a circle fitting the
		// screen, between 0.0 and 1.0
		"radius" : {
			type : "f",
			value : 0.75
		},
		// strength of the vignette, between 0.0 and 1.0
		"strength" : {
			type : "f",
			value : 0.8
		},
		// softness of the vignette, between 0.0 and 1.0
		"softness" : {
			type : "f",
			value : 0.45
		}
	},

	vertexShader : [

	"varying vec2 vUv;",

	"void main(){",

		"vUv = uv;",

		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

	"}"

	].join( "\n" ),

	fragmentShader : [

	"uniform sampler2D tDiffuse;",
	"uniform float radius;",
	"uniform float strength;",
	"uniform float softness;",

	"varying vec2 vUv;",

	"void main() {",

		// sample the texture
		"vec4 texelColor = texture2D ( tDiffuse, vUv );",
		
		// determine the position from center, rather than lower-left (the origin)
		"vec2 position = vUv - vec2( 0.5 );",

		// determine the vector length of the center position
		"float length = length( position );",

		// the vignette effect, using smoothstep
		"float vignette = 1.0 - smoothstep( radius - softness, radius, length );",

		"texelColor.rgb = mix( texelColor.rgb, texelColor.rgb * vignette, strength );",

		"gl_FragColor = texelColor;",

	"}"

	].join( "\n" )
};
},{}],94:[function(require,module,exports){
/**
 * @file This shader is used as a material for a water mesh.
 * 
 * @author Human Interactive
 */

"use strict";

var THREE = require( "three" );

module.exports = {

	uniforms : {

		// this texture contains the reflection of the water
		"reflectionMap" : {
			type : "t",
			value : null
		},
		
		// this texture contains the refraction of the water
		"refractionMap" : {
			type : "t",
			value : null
		},
		
		// this texture will be used to distort uv coordinates
		"dudvMap" : {
			type : "t",
			value : null
		},
		
		// this texture will be used to retrieve normals
		"normalMap" : {
			type : "t",
			value : null
		},

		// this matrix is used for projective texture mapping
		"textureMatrixReflection" : {
			type : "m4",
			value : null
		},
		
		// this matrix is used for projective texture mapping
		"textureMatrixRefraction" : {
			type : "m4",
			value : null
		},

		// elapsed time value
		"time" : {
			type : "f",
			value : 0.0
		},
		
		// strength of the waves
		"waveStrength" : {
			type : "f",
			value : 0.1
		},
		
		// speed of the waves
		"waveSpeed" : {
			type : "f",
			value : 0.03
		},
		
		// the reflectivity of the water
		"waterReflectivity" : {
			type : "f",
			value : 0.02
		},
		
		// the direction of the light
		"lightDirection" : {
			type : "v3",
			value : null
		},
		
		// the color of the light
		"lightColor" : {
			type : "c",
			value : null
		},
		
		// the shininess of the water
		"shininess" : {
			type : "f",
			value : 20.0
		},
		
		// the segments of the water
		"segments" : {
			type : "f",
			value : 1.0
		}

	},

	vertexShader : [

		"uniform mat4 textureMatrixReflection;",
		"uniform mat4 textureMatrixRefraction;",
		
		"uniform float segments;",
	
		"varying vec4 vUvReflect;",
		"varying vec4 vUvRefract;",
		"varying vec3 vToEye;",
		"varying vec2 vUv;",
	
		"void main() {",
		
			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			
			// default uv coordinates. the segment uniform scales them, so
			// the normal and du/dv map are sampled more often
			"vUv = uv * segments;",
			
			// uv coordinates for texture projection
			"vUvReflect = textureMatrixReflection * vec4( position, 1.0 );",
			"vUvRefract = textureMatrixRefraction * vec4( position, 1.0 );",
			
			// calculate toEye vector
			"vToEye = cameraPosition - worldPosition.xyz;",
	
			"gl_Position = projectionMatrix * viewMatrix * worldPosition;",
	
		"}"

	].join( "\n" ),

	fragmentShader : [

		"uniform sampler2D reflectionMap;",
		"uniform sampler2D refractionMap;",
		"uniform sampler2D dudvMap;",
		"uniform sampler2D normalMap;",
		
		"uniform vec3 lightDirection;",
		"uniform vec3 lightColor;",
		
		"uniform float time;",
		"uniform float waveStrength;",
		"uniform float waveSpeed;",
		"uniform float waterReflectivity;",
		"uniform float shininess;",
		
		"varying vec4 vUvReflect;",
		"varying vec4 vUvRefract;",
		"varying vec3 vToEye;",
		"varying vec2 vUv;",
	
		"void main() {",
		
			"vec3 toEye = normalize( vToEye );",

			// distortion
			"vec2 distortedUv = texture2D( dudvMap, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;",
			"distortedUv = vUv + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );",
			"vec2 distortion = ( texture2D( dudvMap, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;",
			
			// distort uv coordiantes
			"vec4 reflectTexCoords = vec4( vUvReflect );",
			"reflectTexCoords.xy += distortion;",
			
			"vec4 refractTexCoords = vec4( vUvRefract );",
			"refractTexCoords.xy += distortion;",
			
			// sample textures
			"vec4 reflectColor = texture2DProj( reflectionMap, reflectTexCoords );",
			"vec4 refractColor = texture2DProj( refractionMap, refractTexCoords );",
			
			// calculate normal
			"vec4 normalColor  = texture2D( normalMap, distortedUv );",	
			"vec3 normal = vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 );",
			"normal = normalize( normal );",
			
			// fresnel effect	
			"float theta = max( dot( toEye, normal ), 0.0 );",
			"float reflectance = waterReflectivity + ( 1.0 - waterReflectivity ) * pow( ( 1.0 - theta ), 5.0 );",
			
			// light calculation
			"vec3 reflectedLight = normalize( reflect( -lightDirection, normal ) );",
			"float specular = pow( max( dot( reflectedLight, toEye ), 0.0 ) , shininess );",
			"vec4 specularColor =  vec4( lightColor * specular, 0.0 );",

			// mix both textures and add lighting
			"gl_FragColor = mix( refractColor, reflectColor, reflectance ) + specularColor;",
		
		"}"

	].join( "\n" )
};
},{"three":1}],95:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "001" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "002", true );
	} );
	
	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],96:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "002" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// create interactive box
	var boxInteraction = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.BLUE_DARK
	} ) );
	boxInteraction.matrixAutoUpdate = false;
	boxInteraction.position.set( 50, 5, 0 );
	boxInteraction.castShadow = true;
	boxInteraction.updateMatrix();
	this.world.addObject3D( boxInteraction );

	this.actionManager.createInteractiveObject( boxInteraction, this.actionManager.COLLISIONTYPES.AABB, this.actionManager.RAYCASTPRECISION.FACE, "Label.Action", function() {

		// nothing happens here...
	} );

	// create first box with AABB collision detection
	var boxAABB = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	boxAABB.matrixAutoUpdate = false;
	boxAABB.position.set( 17, 15, 0 );
	boxAABB.castShadow = true;
	boxAABB.updateMatrix();
	this.world.addObject3D( boxAABB );

	this.actionManager.createActionObject( boxAABB, this.actionManager.COLLISIONTYPES.AABB );

	// create second box with OBB collision detection
	var boxOBB = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 20 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	boxOBB.matrixAutoUpdate = false;
	boxOBB.position.set( -17, 5, 0 );
	boxOBB.rotation.set( 0, Math.PI * 0.2, 0 );
	boxOBB.castShadow = true;
	boxOBB.updateMatrix();
	this.world.addObject3D( boxOBB );

	this.actionManager.createActionObject( boxOBB, this.actionManager.COLLISIONTYPES.OBB );

	// create plain object
	var boxPlain = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.BLUE_WHITE
	} ) );
	boxPlain.matrixAutoUpdate = false;
	boxPlain.position.set( -50, 5, 0 );
	boxPlain.castShadow = true;
	boxPlain.updateMatrix();
	this.world.addObject3D( boxPlain );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "003", true );	
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -50;
	directionalLight.shadow.camera.right = 50;
	directionalLight.shadow.camera.top = 50;
	directionalLight.shadow.camera.bottom = -50;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );

	// start rendering
	this._render();

};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],97:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self, index = 0;

function Stage() {

	StageBase.call( this, "003" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// create interactive box
	var interactiveBox = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	interactiveBox.matrixAutoUpdate = false;
	interactiveBox.position.set( 20, 5, 0 );
	interactiveBox.castShadow = true;
	interactiveBox.updateMatrix();
	this.world.addObject3D( interactiveBox );

	this.actionManager.createInteractiveObject( interactiveBox, this.actionManager.COLLISIONTYPES.AABB, this.actionManager.RAYCASTPRECISION.FACE, "Label.Color", function() {

		colorMesh( interactiveBox );
	} );

	// add trigger for color change
	var colorTrigger = this.actionManager.createTrigger( "Color Change", new THREE.Vector3( -20, 0, 0 ), 10, false, function() {

		colorMesh( interactiveBox );
	} );

	// add helper object
	var helperGeometry = new THREE.SphereBufferGeometry( colorTrigger.boundingSphere.radius, 20, 20 );
	var helperMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );
	
	var helper = new THREE.Mesh( helperGeometry, helperMaterial );
	helper.position.copy(  colorTrigger.boundingSphere.center );
	this.world.addObject3D( helper );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "004", true );	
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -40;
	directionalLight.shadow.camera.right = 40;
	directionalLight.shadow.camera.top = 40;
	directionalLight.shadow.camera.bottom = -40;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );

	// start rendering
	this._render();

};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

// custom functions

function colorMesh( mesh ) {

	if ( ++index % 2 === 0 )
	{
		mesh.material.color = StageBase.COLORS.PRIMARY;
	}
	else
	{
		mesh.material.color = StageBase.COLORS.BLUE_WHITE;
	}
}

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],98:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "004" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// create interactive box
	var boxTextScreen = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.BLUE_DARK
	} ) );
	boxTextScreen.matrixAutoUpdate = false;
	boxTextScreen.position.set( 20, 5, 0 );
	boxTextScreen.castShadow = true;
	boxTextScreen.updateMatrix();
	this.world.addObject3D( boxTextScreen );

	this.actionManager.createInteractiveObject( boxTextScreen, this.actionManager.COLLISIONTYPES.AABB, this.actionManager.RAYCASTPRECISION.FACE, "Label.TextScreen", function() {

		self.userInterfaceManager.showTextScreen( [ {
			name : "Name.Daniel",
			text : "TextScreen.Part1"
		}, {
			name : "Name.Peter",
			text : "TextScreen.Part2"
		}, {
			name : undefined,
			text : "TextScreen.Part3"
		} ] );
	} );

	// create interactive box
	var boxModal = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	boxModal.matrixAutoUpdate = false;
	boxModal.position.set( -20, 5, 0 );
	boxModal.castShadow = true;
	boxModal.updateMatrix();
	this.world.addObject3D( boxModal );

	this.actionManager.createInteractiveObject( boxModal, this.actionManager.COLLISIONTYPES.AABB, this.actionManager.RAYCASTPRECISION.FACE, "Label.Modal", function() {

		self.userInterfaceManager.showModalDialog( {
			headline : "Modal.Headline",
			button : "Modal.Button",
			content : "Modal.Content"
		} );
	} );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "005", true );	
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -40;
	directionalLight.shadow.camera.right = 40;
	directionalLight.shadow.camera.top = 40;
	directionalLight.shadow.camera.bottom = -40;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );
	
	// start rendering
	this._render();

};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],99:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "005" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add background music
	this.audioManager.setBackgroundMusic( "music", 0.5 );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "006", true );	
	} );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// start playing
	this.audioManager.playBackgroundMusic();

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );

	// stop playing
	this.audioManager.stopBackgroundMusic();
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],100:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

var audioFire, audioClock;

function Stage() {

	StageBase.call( this, "006" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add boxes
	var boxFire = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color :StageBase.COLORS.PRIMARY
	} ) );
	boxFire.matrixAutoUpdate = false;
	boxFire.position.set( 40, 5, 0 );
	boxFire.castShadow = true;
	boxFire.updateMatrix();
	this.world.addObject3D( boxFire );
	this.actionManager.createActionObject( boxFire, this.actionManager.COLLISIONTYPES.AABB );

	var boxClock = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.BLUE_WHITE
	} ) );
	boxClock.matrixAutoUpdate = false;
	boxClock.position.set( -40, 5, 0 );
	boxClock.castShadow = true;
	boxClock.updateMatrix();
	this.world.addObject3D( boxClock );
	this.actionManager.createActionObject( boxClock, this.actionManager.COLLISIONTYPES.AABB );

	var boxWall = new THREE.Mesh( new THREE.BoxGeometry( 1, 20, 40 ), new THREE.MeshBasicMaterial( {
		wireframe : true
	} ) );
	boxWall.matrixAutoUpdate = false;
	boxWall.position.set( -5.5, 5, 0 );
	boxWall.updateMatrix();
	boxClock.add( boxWall );
	this.actionManager.createActionObject( boxWall, this.actionManager.COLLISIONTYPES.AABB );

	// add dynamic sounds
	this.audioManager.createAudioBufferList( [ "fire", "clock" ], function( bufferList ) {

		audioFire = self.audioManager.createDynamicSound( "ambient.fire", bufferList[ 0 ], true );
		audioFire.setRefDistance( 20 );
		audioFire.setRolloffFactor( 1 );
		audioFire.setMaxDistance( 50 );

		audioClock = self.audioManager.createDynamicSound( "ambient.clock", bufferList[ 1 ], true );
		audioClock.setRefDistance( 20 );
		audioClock.setRolloffFactor( 1 );
		audioClock.setMaxDistance( 50 );
		audioClock.addDirection( 180, 0, 0 );
		audioClock.position.set( -5, 0, 0 );

		boxFire.add( audioFire );
		boxClock.add( audioClock );
	} ).load();

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "007", true );	
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -40;
	directionalLight.shadow.camera.right = 40;
	directionalLight.shadow.camera.top = 40;
	directionalLight.shadow.camera.bottom = -40;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// start playing
	audioFire.play();
	audioClock.play();

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );

	// stop playing
	audioFire.stop();
	audioClock.stop();
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],101:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "007" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add objects
	var boxBasic = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color :StageBase.COLORS.PRIMARY
	} ) );
	boxBasic.position.set( 20, 5, 0 );
	boxBasic.castShadow = true;
	this.world.addObject3D( boxBasic );

	var interactiveObject = this.actionManager.createInteractiveObject( boxBasic, this.actionManager.COLLISIONTYPES.AABB, this.actionManager.RAYCASTPRECISION.FACE, "Label.Animation", function() {

		interactiveObject.action.isActive = false;

		// create a basic animation, which animates a single value
		self.animationManager.createBasicAnimation( {
			object : boxBasic.position,
			property : "x",
			duration : 5000,
			start : boxBasic.position.x,
			end : boxBasic.position.x + 30,
			easing : Easing.Quartic.InOut
		} ).play();
	} );

	var boxHover = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.BLUE_WHITE
	} ) );
	boxHover.position.set( -40, 8, 0 );
	boxHover.castShadow = true;
	this.world.addObject3D( boxHover );
	this.actionManager.createActionObject( boxHover, this.actionManager.COLLISIONTYPES.AABB );

	// create a hover animation, which animates infinitely a property between
	// start- and end-value
	this.animationManager.createBasicAnimation( {
		object : boxHover.position,
		property : "y",
		duration : 4000,
		delayTime : 2000,
		start : boxHover.position.y,
		end : boxHover.position.y + 2,
		easing : Easing.Sinusoidal.InOut,
		loop : true
	} ).play();

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "008", true );	
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -50;
	directionalLight.shadow.camera.right = 50;
	directionalLight.shadow.camera.top = 50;
	directionalLight.shadow.camera.bottom = -50;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],102:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "008" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add materials and geometry
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 100, 20, 10 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	// add ground down
	var groundDown = new THREE.Mesh( groundGeometry, groundMaterial );
	groundDown.matrixAutoUpdate = false;
	groundDown.position.set( 0, 0, -50 );
	groundDown.rotation.x = - utils.HALF_PI;
	groundDown.updateMatrix();
	groundDown.receiveShadow = true;
	this.world.addGround( groundDown );

	// add ground up
	var groundUp = new THREE.Mesh( groundGeometry, groundMaterial );
	groundUp.matrixAutoUpdate = false;
	groundUp.position.set( 0, 7.5, 68 );
	groundUp.rotation.x = - utils.HALF_PI;
	groundUp.updateMatrix();
	groundUp.receiveShadow = true;
	this.world.addGround( groundUp );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 27.5, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// add stairs
	var stairsLoader = new JSONLoader();
	stairsLoader.load( "/assets/models/stairs.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		materials[ 0 ].color = StageBase.COLORS.PRIMARY;
		materials[ 1 ].color = StageBase.COLORS.BLUE_DARK;

		var stairs = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		stairs.receiveShadow = true;
		self.world.addObject3D( stairs );
	} );

	// add invisible ramp
	var rampGeometry = new THREE.PlaneBufferGeometry( 200, 25, 1, 1 );
	var rampMaterial = new THREE.MeshBasicMaterial( { visible: false } );

	var ramp = new THREE.Mesh( rampGeometry, rampMaterial );
	ramp.matrixAutoUpdate = false;
	ramp.position.set( 0, 2.8, 6.45 );
	ramp.rotation.x = 1.376 * Math.PI;
	ramp.updateMatrix();
	this.world.addGround( ramp );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 7.5, 75 ), 15, true, function() {

		self._changeStage( "009", true );	
	} );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],103:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "009" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// create spheres for LOD switching
	var sphereOne = new THREE.Mesh( new THREE.SphereGeometry( 10, 25, 25 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	var sphereTwo = new THREE.Mesh( new THREE.SphereGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	var sphereThree = new THREE.Mesh( new THREE.SphereGeometry( 10, 6, 6 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );

	sphereOne.matrixAutoUpdate = false;
	sphereTwo.matrixAutoUpdate = false;
	sphereThree.matrixAutoUpdate = false;

	sphereOne.castShadow = true;
	sphereTwo.castShadow = true;
	sphereThree.castShadow = true;

	// create LOD instance
	var lod = this.performanceManager.createSmoothLOD( "sphere", 10 );
	lod.matrixAutoUpdate = false;
	lod.position.set( 0, 10, 0 );
	lod.updateMatrix();

	// add objects and distances
	lod.addLevel( sphereOne, 0 );
	lod.addLevel( sphereTwo, 60 );
	lod.addLevel( sphereThree, 100 );

	this.world.addObject3D( lod );

	// create circles to visualize the LOD distances
	showLODCircles( this.world );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -40;
	directionalLight.shadow.camera.right = 40;
	directionalLight.shadow.camera.top = 40;
	directionalLight.shadow.camera.bottom = -40;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "010", true );	
	} );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

// custom functions

function showLODCircles( world ) {

	var circleOne = new THREE.Mesh( new THREE.CircleGeometry( 60, 25 ), new THREE.MeshBasicMaterial( {
		wireframe : true
	} ) );
	var circleTwo = new THREE.Mesh( new THREE.CircleGeometry( 100, 25 ), new THREE.MeshBasicMaterial( {
		wireframe : true
	} ) );

	circleOne.rotation.set( utils.HALF_PI, 0, 0 );
	circleTwo.rotation.set( utils.HALF_PI, 0, 0 );

	world.addObject3D( circleOne );
	world.addObject3D( circleTwo );
}

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],104:[function(require,module,exports){
(function (global){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self, box, sphere;

function Stage() {

	StageBase.call( this, "010" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// create first mesh for impostor demo
	sphere = new THREE.Mesh( new THREE.SphereGeometry( 10, 25, 25 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	sphere.matrixAutoUpdate = false;
	sphere.position.set( -20, 10, 0 );
	sphere.updateMatrix();
	sphere.visible = false;
	this.world.addObject3D( sphere );

	// create second mesh for impostor demo
	box = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshLambertMaterial( {
		color : StageBase.COLORS.PRIMARY
	} ) );
	box.matrixAutoUpdate = false;
	box.position.set( 20, 10, 0 );
	box.updateMatrix();
	box.visible = false;
	this.world.addObject3D( box );
	
	// add impostor
	var impostorSphere = this.performanceManager.createImpostor( "sphere", sphere, 512 );
	this.world.addObject3D( impostorSphere.billboard );
	
	var impostorBox = this.performanceManager.createImpostor( "box", box, 512 );
	this.world.addObject3D( impostorBox.billboard );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	var directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( -100, 50, -100 );
	directionalLight.shadow.camera.left = -40;
	directionalLight.shadow.camera.right = 40;
	directionalLight.shadow.camera.top = 40;
	directionalLight.shadow.camera.bottom = -40;
	directionalLight.shadow.darkness = 0.5;
	this.settingsManager.adjustLight( directionalLight );
	this.world.addObject3D( directionalLight );

	// add trigger for stage change
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "011", true );	
	} );
	
	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
	
	// generate impostors
	this.performanceManager.generateImpostors();
	
	// add special event handler for demo
	global.document.addEventListener( "keydown", onKeyDown );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );

	// remove special event handler for demo
	global.document.removeEventListener( "keydown", onKeyDown );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

// custom functions

function onKeyDown( event ) {

	switch ( event.keyCode )
	{
		case 73:
			// i
			sphere.visible = !sphere.visible;
			box.visible = !box.visible;
			break;
		case 71:
			// g
			self.performanceManager.generateImpostors();
			break;
	}
}

module.exports = Stage;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],105:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var self;

function Stage() {

	StageBase.call( this, "011" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );

	// light
	var ambientLight = new THREE.AmbientLight( 0x111111 );
	this.world.addObject3D( ambientLight );

	// add trigger for ending
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "012", true );	
	} );

	// post processing
	this.renderer.preparePostProcessing( this.world, this.camera );
	this.renderer.addGrayscaleEffect();
	this.renderer.addHBlurEffect();
	this.renderer.addVBlurEffect();
	this.renderer.addVignetteEffect( {
		renderToScreen : true
	} );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {

	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"three":1}],106:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var ParticleEffect = require( "../particle/ParticleEffect" );
var Interpolator = require( "../particle/operator/Interpolator" );
var SphereEmitter = require( "../particle/emitter/SphereEmitter" );

var self, particles;

function Stage() {

	StageBase.call( this, "012" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );
	
	// particle texture
	var texture = new THREE.TextureLoader().load( "/assets/textures/Blossom_1_S.png" );
	
	// particle emitter
	var emitter = new SphereEmitter({
		origin: new THREE.Vector3( 0, 10, 0),
		defaultDirection: true
	});
	
	// particle effect
	particles = new ParticleEffect({
		numberOfParticles : 5000,
		emitter : emitter,
		texture : texture,
		rotateTexture: true,
		transparent: true,
		sortParticles: true
	});
	
	// color interpolator
	var colorInterpolator = new Interpolator();
	
	colorInterpolator.addValue( 0.0, new THREE.Color( 0xff0000 ) );
	colorInterpolator.addValue( 0.4, new THREE.Color( 0x00ff00 ) );
	colorInterpolator.addValue( 0.7, new THREE.Color( 0x0000ff ) );
	
	// add interpolator to particle effect
	particles.addInterpolatorToProperty( colorInterpolator, "color" );

	// add trigger for ending
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self._changeStage( "013", true );
	} );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
	
	particles.destroy();
};

Stage.prototype._render = function() {
	
	particles.update( self._delta );
	
	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"../particle/ParticleEffect":75,"../particle/emitter/SphereEmitter":79,"../particle/operator/Interpolator":80,"three":1}],107:[function(require,module,exports){
"use strict";

var THREE = require( "three" );

var StageBase = require( "../core/StageBase" );
var JSONLoader = require( "../etc/JSONLoader" );
var utils = require( "../etc/Utils" );
var Easing = require( "../animation/Easing" );

var Water = require ( "../etc/Water" );

var self, water, box, sphere;

function Stage() {

	StageBase.call( this, "013" );

	self = this;
}

Stage.prototype = Object.create( StageBase.prototype );
Stage.prototype.constructor = Stage;

Stage.prototype.setup = function() {

	StageBase.prototype.setup.call( this );

	// player setup
	this.world.player.position.set( 0, 0, -75 );
	this.world.player.setDirection( new THREE.Vector3( 0, 0, 1 ) );
	this.world.player.updateMatrixWorld();

	// load texts
	this.textManager.load( this.stageId );

	// add ground
	var groundGeometry = new THREE.Geometry().fromBufferGeometry( new THREE.PlaneBufferGeometry( 200, 200, 20, 20 ) );
	var groundMaterial = new THREE.MeshBasicMaterial( {
		vertexColors : THREE.FaceColors
	} );

	var ground = new THREE.Mesh( groundGeometry, groundMaterial );
	ground.matrixAutoUpdate = false;
	ground.rotation.x = - utils.HALF_PI;
	ground.updateMatrix();
	ground.receiveShadow = true;
	this.world.addGround( ground );

	// color faces
	utils.colorFaces( groundGeometry, StageBase.COLORS.PRIMARY, StageBase.COLORS.BLUE_DARK );

	// add sign
	var signLoader = new JSONLoader();
	signLoader.load( "/assets/models/sign.json", function( geometry, materials ) {

		self.settingsManager.adjustMaterials( materials, self.renderer );

		var sign = new THREE.Mesh( geometry, new THREE.MultiMaterial( materials ) );
		sign.position.set( 0, 20, 75 );
		sign.rotation.set( 0, - utils.HALF_PI, 0 );
		self.world.addObject3D( sign );

		self.animationManager.createBasicAnimation( {
			object : sign.position,
			property : "y",
			duration : 5000,
			start : sign.position.y,
			end : sign.position.y + 5,
			easing : Easing.Sinusoidal.InOut,
			loop : true
		} ).play();
	} );
	
	// add trigger for ending
	var stageTrigger = this.actionManager.createTrigger( "Change Stage", new THREE.Vector3( 0, 0, 75 ), 15, true, function() {

		self.userInterfaceManager.showModalDialog( {
			headline : "Modal.Headline",
			button : "Modal.Button",
			content : "Modal.Content"
		} );

		self.saveGameManager.remove();	
	} );
	
	// add some moving objects to demonstrate the water effect
	box = new THREE.Mesh( new THREE.BoxGeometry( 5, 5, 5 ), new THREE.MeshBasicMaterial( {
		color : StageBase.COLORS.BLUE_DARK
	} ) );
	
	this.world.addObject3D( box );
	
	sphere = new THREE.Mesh( new THREE.SphereGeometry( 2.5, 10, 10 ), new THREE.MeshBasicMaterial( {
		color : StageBase.COLORS.BLUE_WHITE
	} ) );
	
	this.world.addObject3D( sphere );
	
	// create water 
	water = new Water( this.renderer, this.camera, this.world, {
		width: 200,
		height: 200,
		segments: 3,
		lightDirection: new THREE.Vector3( 0.7, 0.7, 0 )
	});
	
	water.position.set( 0, 1, 0 );
	water.rotation.set( Math.PI * -0.5, 0, 0 );
	water.updateMatrix();
	this.world.addObject3D( water );

	// start rendering
	this._render();
};

Stage.prototype.start = function() {

	StageBase.prototype.start.call( this );

	// set information panel text
	this.userInterfaceManager.setInformationPanelText( "InformationPanel.Text" );
};

Stage.prototype.destroy = function() {

	StageBase.prototype.destroy.call( this );
};

Stage.prototype._render = function() {
	
	// update the water
	water.update( self.timeManager.elapsedTime );
	
	// animate the moving objects
	var step = self.timeManager.elapsedTime * 0.5;
	
	box.position.set( Math.cos( step  ) * 20, 10, Math.sin( step ) * 20 );
	sphere.position.set( Math.sin( step ) * 50, 10, Math.cos( step ) * 50 );
	
	StageBase.prototype._render.call( self );
};

module.exports = Stage;
},{"../animation/Easing":11,"../core/StageBase":25,"../etc/JSONLoader":33,"../etc/Utils":45,"../etc/Water":46,"three":1}],108:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element chat.
 * 
 * @author Human Interactive
 */
"use strict";

var UiElement = require( "./UiElement" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var self;

/**
 * Creates the chat-ui.
 * 
 * @constructor
 * @augments UiElement
 */
function Chat() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$input : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$messages : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_timer : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	self = this;
}

Chat.prototype = Object.create( UiElement.prototype );
Chat.prototype.constructor = Chat;

/**
 * Initializes the control.
 */
Chat.prototype.init = function() {

	this._$root = global.document.querySelector( "#chat" );
	this._$messages = global.document.querySelector( "#messages" );
	this._$input = this._$root.querySelector( ".form-control" );

	eventManager.subscribe( TOPIC.MULTIPLAYER.MESSAGE, this._onMessage );
};

/**
 * Toggles the chat-ui and sends the message. While the input field for writing
 * a chat message is visible, the controls are disabled. That means typing wasd
 * won't move the player.
 */
Chat.prototype.toggle = function() {

	if ( this._$root.style.display === "block" )
	{
		// if the input field contains text,
		// send it to the server and to the message box(ui)
		this._checkAndSend();

		// hide input field
		this.hide();

		// capture controls
		eventManager.publish( TOPIC.CONTROLS.CAPTURE, {
			isCaptured : true
		} );
	}
	else
	{
		// show input field
		this.show();

		// release controls
		eventManager.publish( TOPIC.CONTROLS.CAPTURE, {
			isCaptured : false
		} );
	}
};

/**
 * Shows the chat-ui.
 */
Chat.prototype.show = function() {

	this._$root.style.display = "block";
	this._$input.focus();
	this.isActive = true;
};

/**
 * Hides the chat-ui.
 */
Chat.prototype.hide = function() {

	this._$root.style.display = "none";
	this._$input.value = "";
	this.isActive = false;
};

/**
 * Posts a message to the chat-box.
 * 
 * @param {stirng} message - The message to post.
 */
Chat.prototype._postMessage = function( message ) {

	// clear timeout
	clearTimeout( this._timer );

	// create new DOM-entry for message
	var node = global.document.createElement( "div" );
	node.textContent = message;
	this._$messages.appendChild( node );

	// show message box
	this._$messages.style.display = "block";

	// scroll to bottom (to latest messages)
	this._$messages.scrollTop = this._$messages.scrollHeight;

	// after some time, hide message box
	this._timer = setTimeout( function() {

		self._$messages.style.display = "none";
	}, 10000 );
};

/**
 * Checks and sends the message.
 */
Chat.prototype._checkAndSend = function() {

	var message = this._$input.value.trim();

	if ( message !== "" )
	{
		// post message
		this._postMessage( message );

		// publish chat message for sending to server
		eventManager.publish( TOPIC.MULTIPLAYER.CHAT, message );
	}
};

/**
 * Posts a message from other players to a chat-box.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
Chat.prototype._onMessage = function( message, data ) {

	self._postMessage( data.message );
};

module.exports = new Chat();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../messaging/EventManager":69,"../messaging/Topic":71,"./UiElement":117}],109:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element development panel. Only if the development
 * mode is active, this control is part of the UI.
 * 
 * @author Human Interactive
 */

"use strict";

var UiElement = require( "./UiElement" );

/**
 * Creates the development panel.
 * 
 * @constructor
 * @augments UiElement
 */
function DevelopmentPanel() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$content : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
}

DevelopmentPanel.prototype = Object.create( UiElement.prototype );
DevelopmentPanel.prototype.constructor = DevelopmentPanel;

/**
 * Initializes the control.
 */
DevelopmentPanel.prototype.init = function() {

	this._$root = global.document.querySelector( "#development-panel" );
	this._$content = this._$root.querySelector( ".content" );
};

/**
 * Sets the text of the development panel.
 * 
 * @param {string} text - The text of the development panel.
 */
DevelopmentPanel.prototype.setText = function( text ) {

	this._$content.innerHTML = text;
};

module.exports = new DevelopmentPanel();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./UiElement":117}],110:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element information panel.
 * 
 * @author Human Interactive
 */

"use strict";

var UiElement = require( "./UiElement" );

/**
 * Creates the information panel.
 * 
 * @constructor
 * @augments UiElement
 */
function InformationPanel() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$content : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
}

InformationPanel.prototype = Object.create( UiElement.prototype );
InformationPanel.prototype.constructor = InformationPanel;

/**
 * Initializes the control.
 */
InformationPanel.prototype.init = function() {

	this._$root = global.document.querySelector( "#information-panel" );
	this._$content = this._$root.querySelector( ".content" );
};

/**
 * Sets the text of the information panel.
 * 
 * @param {string} textKey - The text key of the information panel.
 */
InformationPanel.prototype.setText = function( textKey ) {

	this._$content.innerHTML = this._textManager.get( textKey );
};

module.exports = new InformationPanel();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./UiElement":117}],111:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element interaction label.
 * 
 * @author Human Interactive
 */

"use strict";

var UiElement = require( "./UiElement" );

/**
 * Creates the interaction label.
 * 
 * @constructor
 * @augments UiElement
 */
function InteractionLabel() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$content : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );
}

InteractionLabel.prototype = Object.create( UiElement.prototype );
InteractionLabel.prototype.constructor = InteractionLabel;

/**
 * Initializes the control.
 */
InteractionLabel.prototype.init = function() {

	this._$root = global.document.querySelector( "#interaction-label" );
	this._$content = this._$root.querySelector( ".content" );
};

/**
 * Shows the interaction label.
 * 
 * @param {string} textKey - The text key of the corresponding action.
 */
InteractionLabel.prototype.show = function( textKey ) {

	if ( this.isActive === false )
	{
		this._$content.textContent = this._textManager.get( textKey );
		this._$root.style.display = "block";
		this.isActive = true;
	}
};

/**
 * Hides the interaction label.
 */
InteractionLabel.prototype.hide = function() {

	if ( this.isActive === true )
	{
		this._$root.style.display = "none";
		this.isActive = false;
	}
};

module.exports = new InteractionLabel();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./UiElement":117}],112:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element loading screen.
 * 
 * @author Human Interactive
 */
"use strict";

var UiElement = require( "./UiElement" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var self;

/**
 * Creates the loading screen.
 * 
 * @constructor
 * @augments UiElement
 */
function LoadingScreen() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$progress : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$progressBar : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$text : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_transitionEndEvent : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isActive : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isReady : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );

	self = this;
}

LoadingScreen.prototype = Object.create( UiElement.prototype );
LoadingScreen.prototype.constructor = LoadingScreen;

/**
 * Initializes the control.
 */
LoadingScreen.prototype.init = function() {

	this._transitionEndEvent = this._getTransitionEndEvent();

	this._$root = global.document.querySelector( "#loading-screen" );
	this._$progress = this._$root.querySelector( ".progress" );
	this._$progressBar = this._$root.querySelector( ".progress-bar" );
	this._$text = this._$root.querySelector( ".text" );

	// subscriptions
	eventManager.subscribe( TOPIC.STAGE.LOADING.PROGRESS, this._onUpdate );
	eventManager.subscribe(  TOPIC.STAGE.READY, this._onReady );
};

/**
 * Shows the loading screen.
 * 
 * @param {function} callback - This function is executed, when the loading
 * screen is shown.
 */
LoadingScreen.prototype.show = function( callback ) {

	// callback
	function onTransitionEnd( event ) {

		if ( event.target.id === self._$root.id )
		{
			// remove event listener, so it runs only once
			self._$root.removeEventListener( self._transitionEndEvent, onTransitionEnd );
			if ( typeof callback === "function" )
			{
				callback();
			}
		}
	}

	// add event-listener
	this._$root.addEventListener( this._transitionEndEvent, onTransitionEnd );

	// show loading screen
	this._$root.classList.add( "fadeIn" );

	// set flags
	this.isActive = true;
	this.isReady = false;
};

/**
 * Hides the loading screen.
 */
LoadingScreen.prototype.hide = function() {

	// callback
	function onTransitionEnd( event ) {

		if ( event.target.id === self._$root.id )
		{
			// remove event listener, so it runs only once
			self._$root.removeEventListener( self._transitionEndEvent, onTransitionEnd );

			// reset CSS classes
			self._$text.classList.remove( "fadeIn" );
			self._$progress.classList.remove( "fadeOut" );

			// reset progress bar
			self._$progressBar.style.width = "0%";
		}
	}

	// add event-listener
	this._$root.addEventListener( this._transitionEndEvent, onTransitionEnd );

	// hide loading screen
	this._$root.classList.remove( "fadeIn" );

	// set flags
	this.isActive = false;
};

/**
 * This method updates the progress bar.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
LoadingScreen.prototype._onUpdate = function( message, data ) {

	if ( data.isApplicationStart === false )
	{
		self._$progressBar.style.width = data.loadingProgress + "%";
	}
};

/**
 * Sets loading screen to ready.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
LoadingScreen.prototype._onReady = function( message, data ) {

	if ( data.isApplicationStart === false )
	{
		self.isReady = true;
		self._$progress.classList.add( "fadeOut" );
		self._$text.classList.add( "fadeIn" );
	}
};

module.exports = new LoadingScreen();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../messaging/EventManager":69,"../messaging/Topic":71,"./UiElement":117}],113:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element menu.
 * 
 * @author Human Interactive
 */

"use strict";

var UiElement = require( "./UiElement" );
var environment = require( "../core/Environment" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var self;
/**
 * Creates the menu.
 * 
 * @constructor
 * @augments UiElement
 */
function Menu() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$button : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$text : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$progress : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$progressBar : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
	} );

	self = this;
}

Menu.prototype = Object.create( UiElement.prototype );
Menu.prototype.constructor = Menu;

/**
 * Initializes the control.
 */
Menu.prototype.init = function() {

	this._$root = global.document.querySelector( "#menu" );
	this._$button = this._$root.querySelector( ".btn" );
	this._$text = this._$root.querySelector( ".text" );
	this._$progress = this._$root.querySelector( ".progress" );
	this._$progressBar = this._$root.querySelector( ".progress-bar" );

	// subscriptions
	eventManager.subscribe( TOPIC.STAGE.LOADING.PROGRESS, this._onUpdate );
	eventManager.subscribe( TOPIC.STAGE.READY, this._onReady );

	this._$button.addEventListener( "click", this._onClick );
};

/**
 * Shows the menu.
 * 
 */
Menu.prototype.show = function() {

	this._$root.style.display = "block";
	this._$text.style.display = "none";
	this._$button.style.display = "block";
};

/**
 * Hides the menu.
 */
Menu.prototype.hide = function() {

	this._$root.style.display = "none";
};

/**
 * Click-Handler for Menu-Button
 */
Menu.prototype._onClick = function() {

	global.document.dispatchEvent( new global.Event( "lockPointer" ) );

	if ( environment.isFirefox() === true )
	{
		self._$button.style.display = "none";
		self._$text.style.display = "block";
	}
};

/**
 * This method updates the progress bar.
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
Menu.prototype._onUpdate = function( message, data ) {

	if ( data.isApplicationStart === true )
	{
		self._$progressBar.style.width = data.loadingProgress + "%";
	}
};

/**
 * Removes the ready progressbar and shows the play-button
 * 
 * @param {string} message - The message topic of the subscription.
 * @param {object} data - The data of the message.
 */
Menu.prototype._onReady = function( message, data ) {

	if ( data.isApplicationStart === true )
	{
		self._$button.addEventListener( "click", self._publishFinishEvent );
		self._$progress.classList.add( "fadeOut" );
		self._$button.classList.add( "fadeIn" );
	}
};

/**
 * This method is used to inform the system, that the player has started to play the stage.
 */
Menu.prototype._publishFinishEvent = function( message, data ) {

	eventManager.publish( TOPIC.STAGE.START, undefined );
	self._$button.removeEventListener( "click", self._publishFinishEvent );
};

module.exports = new Menu();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/Environment":20,"../messaging/EventManager":69,"../messaging/Topic":71,"./UiElement":117}],114:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element modal dialog.
 * 
 * @author Human Interactive
 */
"use strict";

var UiElement = require( "./UiElement" );

var self;
/**
 * Creates the modal label.
 * 
 * @constructor
 * @augments UiElement
 */
function ModalDialog() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$overlay : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$close : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$headline : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$button : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$content : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	self = this;
}

ModalDialog.prototype = Object.create( UiElement.prototype );
ModalDialog.prototype.constructor = ModalDialog;

/**
 * Initializes the control.
 */
ModalDialog.prototype.init = function() {

	this._$root = global.document.querySelector( "#modal-dialog" );
	this._$overlay = global.document.querySelector( ".md-overlay" );
	this._$close = this._$root.querySelector( ".md-close" );
	this._$headline = this._$root.querySelector( "h2" );
	this._$button = this._$root.querySelector( ".btn" );
	this._$content = this._$root.querySelector( ".md-text" );

	this._$close.addEventListener( "click", this._onClose );
	this._$overlay.addEventListener( "click", this._onClose );
};

/**
 * Shows the modal dialog.
 * 
 * @param {object} textKeys - The texts to display.
 */
ModalDialog.prototype.show = function( textKeys ) {
	
	// show modal
	this._$root.classList.add( "md-show" );

	// set texts
	this._$headline.textContent = this._textManager.get( textKeys.headline );
	this._$button.textContent = this._textManager.get( textKeys.button );
	this._$content.innerHTML = this._textManager.get( textKeys.content );

	// release pointer lock
	global.document.dispatchEvent( new global.Event( "releasePointer" ) );
	
	// set active flag
	this.isActive = true;
};

/**
 * Hides the modal dialog.
 */
ModalDialog.prototype.hide = function() {

	// hide modal
	this._$root.classList.remove( "md-show" );

	// lock pointer
	global.document.dispatchEvent( new global.Event( "lockPointer" ) );
	
	// set active flag
	this.isActive = false;
};

/**
 * This method handles event for closing the element.
 */
ModalDialog.prototype._onClose = function( event ) {

	event.stopPropagation();
	self.hide();
};

module.exports = new ModalDialog();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./UiElement":117}],115:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element performance monitor. Only if the development
 * mode is active, this control is part of the UI.
 * 
 * see https://github.com/mrdoob/stats.js/
 * 
 * @author Human Interactive
 */

"use strict";

var UiElement = require( "./UiElement" );

var self;

/**
 * Creates the performance monitor.
 * 
 * @constructor
 * @augments UiElement
 */
function PerformanceMonitor() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$fps : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$fpsText : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$fpsGraph : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$ms : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$msText : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_$msGraph : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_mode : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isActive : {
			value : true,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	self = this;
}

PerformanceMonitor.prototype = Object.create( UiElement.prototype );
PerformanceMonitor.prototype.constructor = PerformanceMonitor;

/**
 * Initializes the control.
 */
PerformanceMonitor.prototype.init = function() {

	// root element
	this._$root = global.document.querySelector( "#performance-monitor" );

	// frames per seconds
	this._$fps = this._$root.querySelector( ".fps" );
	this._$fpsText = this._$fps.querySelector( ".text" );
	this._$fpsGraph = this._$fps.querySelector( ".graph" );
	this._generateBarChart( this._$fpsGraph );

	// frametime
	this._$ms = this._$root.querySelector( ".ms" );
	this._$msText = this._$ms.querySelector( ".text" );
	this._$msGraph = this._$ms.querySelector( ".graph" );
	this._generateBarChart( this._$msGraph );

	// event handler
	this._$root.addEventListener( "click", this._onSwitchMode );
};

/**
 * Updates the control.
 */
PerformanceMonitor.prototype.update = ( function() {

	var startTime = global.performance.now(), currentTime = 0, previousTime = startTime;
	var ms = 0, msMin = Infinity, msMax = 0;
	var fps = 0, fpsMin = Infinity, fpsMax = 0;
	var frames = 0;

	return function() {

		currentTime = global.performance.now();

		ms = currentTime - startTime;
		msMin = Math.min( msMin, ms );
		msMax = Math.max( msMax, ms );

		/* jslint bitwise: true */this._$msText.textContent = ( ms | 0 ) + " MS (" + ( msMin | 0 ) + "-" + ( msMax | 0 ) + ")";
		this._updateChart( this._$msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );

		frames++;

		if ( currentTime > previousTime + 1000 )
		{

			fps = Math.round( ( frames * 1000 ) / ( currentTime - previousTime ) );
			fpsMin = Math.min( fpsMin, fps );
			fpsMax = Math.max( fpsMax, fps );

			this._$fpsText.textContent = fps + " FPS (" + fpsMin + "-" + fpsMax + ")";
			this._updateChart( this._$fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );

			previousTime = currentTime;
			frames = 0;

		}

		startTime = currentTime;

	};

}() );

/**
 * Toggles the control.
 */
PerformanceMonitor.prototype.toggle = function() {

	if ( this.isActive === false )
	{
		this.show();
	}
	else
	{
		this.hide();
	}
};

/**
 * Shows the control.
 */
PerformanceMonitor.prototype.show = function() {

	this._$root.style.display = "block";
	this.isActive = true;
	
};

/**
 * Hides the control.
 */
PerformanceMonitor.prototype.hide = function() {

	this._$root.style.display = "none";
	this.isActive = false;
};

/**
 * Generates the bar charts.
 * 
 * @param {object} $graph - The target graph object.
 */
PerformanceMonitor.prototype._generateBarChart = function( $graph ) {

	var element = null;

	while ( $graph.children.length < 74 )
	{

		element = global.document.createElement( "span" );
		element.className = "bar";
		$graph.appendChild( element );
	}
};

/**
 * Updates a graph.
 * 
 * @param {object} $graph - The target graph object.
 */
PerformanceMonitor.prototype._updateChart = function( $graph, value ) {

	var child = $graph.appendChild( $graph.firstChild );
	child.style.height = value + "px";

};

/**
 * Switches the mode of the performance monitor.
 */
PerformanceMonitor.prototype._onSwitchMode = function() {

	self._mode = ++self._mode % 2;

	switch ( self._mode )
	{
		case 0:
			self._$fps.style.display = "block";
			self._$ms.style.display = "none";
			break;

		case 1:
			self._$fps.style.display = "none";
			self._$ms.style.display = "block";
			break;
	}
};

module.exports = new PerformanceMonitor();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./UiElement":117}],116:[function(require,module,exports){
(function (global){
/**
 * @file Prototype for ui-element text screen.
 * 
 * @author Human Interactive
 */
"use strict";

var self;

var UiElement = require( "./UiElement" );
var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

/**
 * Creates the text screen.
 * 
 * @constructor
 * @augments UiElement
 */
function TextScreen() {

	UiElement.call( this );

	Object.defineProperties( this, {
		_$content : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_textKeys : {
			value : {},
			configurable : false,
			enumerable : false,
			writable : true
		},
		_completeCallback : {
			value : undefined,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isDone : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_isPrint : {
			value : false,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_textIndex : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		_printId : {
			value : 0,
			configurable : false,
			enumerable : false,
			writable : true
		},
		isActive : {
			value : false,
			configurable : false,
			enumerable : true,
			writable : true
		}
	} );

	self = this;
}

TextScreen.prototype = Object.create( UiElement.prototype );
TextScreen.prototype.constructor = TextScreen;

/**
 * Initializes the control.
 */
TextScreen.prototype.init = function() {

	this._$root = global.document.querySelector( "#text-screen" );
	this._$content = this._$root.querySelector( ".content" );
};

/**
 * Shows the text screen.
 * 
 * @param {object} textKeys - The conversation of the text screen.
 * @param {function} completeCallback - This function is executed, when all
 * texts are shown and the ui-element is going to hide.
 */
TextScreen.prototype.show = function( textKeys, completeCallback ) {

	if ( this.isActive === false )
	{
		this._textKeys = textKeys;
		this._completeCallback = completeCallback;
		this._isDone = false;

		this.isActive = true;
		this._isPrint = true;

		this._printName();
		this._printText();
		this._$root.classList.add( "slideEffect" );
		
		// lock controls
		eventManager.publish( TOPIC.CONTROLS.LOCK, {
			isLocked : true
		} );
	}
};

/**
 * Hides the text screen.
 */
TextScreen.prototype.hide = function() {

	if ( this.isActive === true )
	{
		this.isActive = false;
		this._$root.classList.remove( "slideEffect" );
		this._$content.textContent = "";
		this._textIndex = 0;
		
		// release controls
		eventManager.publish( TOPIC.CONTROLS.LOCK, {
			isLocked : false
		} );
	}
};

/**
 * Handles the "complete-order" of the player. This happens when the player
 * presses the space key.
 */
TextScreen.prototype.complete = function() {

	// text completion
	if ( this._isPrint === true )
	{
		this._isPrint = false;
		clearTimeout( this._printId );
		this._$content.textContent = "";
		this._printName();
		this._$content.textContent += self._textManager.get( this._textKeys[ this._textIndex ].text );
		// switch to next text and start printing
	}
	else if ( this._textIndex < this._textKeys.length - 1 )
	{
		this._isPrint = true;
		this._textIndex++;
		this._$content.textContent = "";
		this._printName();
		this._printText();
		// finish
	}
	else
	{
		if ( this._isDone === false )
		{
			if ( typeof this._completeCallback === "function" )
			{
				this._completeCallback();
			}
			this._isDone = true;
			this.hide();
		}
	}
};

/**
 * Prints a single text of the conversation to the text screen. The printing is
 * done letter by letter.
 * 
 * @param {number} index - The array-index of the current text.
 */
TextScreen.prototype._printText = function( index ) {

	// receive text
	var text = self._textManager.get( self._textKeys[ self._textIndex ].text );
	
	// if index is undefined, set the value to zero
	index = index || 0;

	if ( index < text.length )
	{
		// get the next character of the text
		self._$content.textContent += text[ index ];
		
		// set a timeout to print the next character
		self._printId = setTimeout( self._printText, 75, ++index );
	}
	else
	{
		self._isPrint = false;
	}

};

/**
 * Prints the name of the speaking person.
 */
TextScreen.prototype._printName = function() {

	if ( this._textKeys[ this._textIndex ].name !== undefined )
	{
		var name = this._textManager.get( this._textKeys[ this._textIndex ].name );
		this._$content.textContent += name + ": ";
	}
};

module.exports = new TextScreen();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../messaging/EventManager":69,"../messaging/Topic":71,"./UiElement":117}],117:[function(require,module,exports){
(function (global){
/**
 * @file Super prototype of UI-Elements.
 * 
 * @author Human Interactive
 */

"use strict";

var textManager = require( "../etc/TextManager" );

/**
 * Creates an ui-element.
 * 
 * @constructor
 */
function UiElement() {

	Object.defineProperties( this, {
		// a reference to the root HTML element
		_$root : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		},
		// a reference to the text manager
		_textManager : {
			value : textManager,
			configurable : false,
			enumerable : false,
			writable : false
		}
	} );
	
}

/**
 * Gets the correct transitionEnd event.
 * 
 * @returns {string} The name of the transitionEnd event.
 */
UiElement.prototype._getTransitionEndEvent = function() {

	var transition;
	var element = global.document.querySelector( "body" );

	var transitions = {
		"transition" : "transitionend",
		"OTransition" : "oTransitionEnd",
		"MozTransition" : "transitionend",
		"WebkitTransition" : "webkitTransitionEnd"
	};

	for ( transition in transitions )
	{
		if ( element.style[ transition ] !== undefined )
		{
			return transitions[ transition ];
		}
	}
};

module.exports = UiElement;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../etc/TextManager":44}],118:[function(require,module,exports){
(function (global){
/**
 * @file Interface for entire ui-handling. This prototype is used in stages to
 * access ui-based logic and to create ui-entities.
 * 
 * @author Human Interactive
 */

"use strict";

var eventManager = require( "../messaging/EventManager" );
var TOPIC = require( "../messaging/Topic" );

var system = require( "../core/System" );

var developmentPanel = require( "./DevelopmentPanel" );
var performanceMonitor = require( "./PerformanceMonitor" );
var informationPanel = require( "./InformationPanel" );
var interactionLabel = require( "./InteractionLabel" );
var loadingScreen = require( "./LoadingScreen" );
var menu = require( "./Menu" );
var textScreen = require( "./TextScreen" );
var modalDialog = require( "./ModalDialog" );
var chat = require( "./Chat" );

var self;

/**
 * Creates the user interface manager.
 * 
 * @constructor
 */
function UserInterfaceManager() {

	Object.defineProperties( this, {
		_$uiContainer : {
			value : null,
			configurable : false,
			enumerable : false,
			writable : true
		}
	} );
	
	self = this;
}

/**
 * Initializes the user interface manager.
 */
UserInterfaceManager.prototype.init = function() {

	// get reference to central ui-container
	this._$uiContainer = global.document.querySelector( "#ui-container" );

	// init controls
	informationPanel.init();
	interactionLabel.init();
	loadingScreen.init();
	menu.init();
	textScreen.init();
	modalDialog.init();
	chat.init();

	// add development information
	if ( system.isDevModeActive === true )
	{
		performanceMonitor.init();

		developmentPanel.init();
		developmentPanel.setText( "Development Mode Active: " + system.name + " Version: " + system.version );
	}

	// eventing
	this._mapGlobalEventsToTopics();
	this._initGlobalEventHandler();
};

/**
 * Updates the UserInterface-Logic, called from render-loop.
 */
UserInterfaceManager.prototype.update = function() {

	if ( system.isDevModeActive === true )
	{
		performanceMonitor.update();
	}
};

/**
 * Sets the text of the information panel.
 * 
 * @param {string} textKey - The text-content of the information panel.
 */
UserInterfaceManager.prototype.setInformationPanelText = function( textKey ) {

	informationPanel.setText( textKey );
};

/**
 * Shows the interaction label.
 * 
 * @param {string} textKey - The label of the corresponding action.
 */
UserInterfaceManager.prototype.showInteractionLabel = function( textKey ) {

	interactionLabel.show( textKey );
};

/**
 * Hides the interaction label.
 */
UserInterfaceManager.prototype.hideInteractionLabel = function() {

	interactionLabel.hide();
};

/**
 * Shows the menu.
 * 
 */
UserInterfaceManager.prototype.showMenu = function() {

	menu.show();
};

/**
 * Hides the menu.
 */
UserInterfaceManager.prototype.hideMenu = function() {

	menu.hide();
	chat.hide();
};

/**
 * Shows the text screen.
 * 
 * @param {object} textObject - The conversation of the text screen.
 * @param {function} completeCallback - This function is executed, when all
 * texts are shown and the ui-element is going to hide.
 */
UserInterfaceManager.prototype.showTextScreen = function( textKeys, completeCallback ) {

	textScreen.show( textKeys, completeCallback );
};

/**
 * Hides the text screen.
 */
UserInterfaceManager.prototype.hideTextScreen = function() {

	textScreen.hide();
};

/**
 * Shows the loading screen.
 * 
 * @param {function} callback - This function is executed, when the loading
 * screen is shown.
 */
UserInterfaceManager.prototype.showLoadingScreen = function( callback ) {

	loadingScreen.show( callback );
};

/**
 * Hides the loading screen.
 */
UserInterfaceManager.prototype.hideLoadingScreen = function() {

	loadingScreen.hide();
};

/**
 * Shows the modal dialog.
 * 
 * @param {object} textKeys - The texts to display.
 */
UserInterfaceManager.prototype.showModalDialog = function( textKeys ) {

	modalDialog.show( textKeys );
};

/**
 * Hides the modal dialog.
 */
UserInterfaceManager.prototype.hideModalDialog = function() {

	modalDialog.hide();
};

/**
 * Handles the press of the space-key.
 */
UserInterfaceManager.prototype.handleUiInteraction = function() {

	if ( textScreen.isActive === true )
	{
		textScreen.complete();
	}
	else if ( loadingScreen.isActive === true && loadingScreen.isReady === true )
	{
		eventManager.publish( TOPIC.STAGE.START, undefined );
		loadingScreen.hide();
	}
};

/**
 * Maps global events to topics.
 */
UserInterfaceManager.prototype._mapGlobalEventsToTopics = function() {

	global.window.addEventListener( "resize", function() {

		eventManager.publish( TOPIC.APPLICATION.RESIZE, undefined );
	} );
};

/**
 * Initializes global event handlers.
 */
UserInterfaceManager.prototype._initGlobalEventHandler = function() {

	global.window.addEventListener( "contextmenu", this._onContextMenu );
	global.window.addEventListener( "keydown", this._onKeyDown );
};

/**
 * This method prevents the display of the contextmenu.
 * 
 * @param {object} event - The event object.
 */
UserInterfaceManager.prototype._onContextMenu = function( event ) {

	// disable contextmenu
	event.preventDefault();
};

/**
 * Executes, when a key is pressed down.
 * 
 * @param {object} event - Default event object.
 */
UserInterfaceManager.prototype._onKeyDown = function( event ) {

	switch ( event.keyCode )
	{
		// enter
		case 13:

			if ( textScreen.isActive === false && modalDialog.isActive === false )
			{
				chat.toggle();
			}

			break;

		// space
		case 32:

			if ( chat.isActive === false )
			{
				// prevent scrolling
				event.preventDefault();

				// because pressing the space key can cause different actions,
				// the logic for this key handling is placed in a separate method
				self.handleUiInteraction();

			}

			break;

		// f
		case 70:

			if ( system.isDevModeActive === true && chat.isActive === false )
			{
				performanceMonitor.toggle();
			}

			break;
	}
};

module.exports = new UserInterfaceManager();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core/System":27,"../messaging/EventManager":69,"../messaging/Topic":71,"./Chat":108,"./DevelopmentPanel":109,"./InformationPanel":110,"./InteractionLabel":111,"./LoadingScreen":112,"./Menu":113,"./ModalDialog":114,"./PerformanceMonitor":115,"./TextScreen":116}]},{},[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118]);
